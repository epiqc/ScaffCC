/****************************************************************************************
* File: TriangleFindingProblem.quantum
*
* Author: Chen-Fu Chiang @ USherbrooke
*
* Implementation of the triangle finding algorithm specified in the
* Quantum Computer Science Program @ Government Furnished Information document
*
* GFI Document date: June 20, 2011
* GFI Document Version: 1.0.0
* GFI Document Reversion number: 188
* Recent Update: Based on https://qcs.ornl.gov/trac/qcs-scaffold/ticket/3
*****************************************************************************************/

#include <math.h>

/**********************************************
* Further Reduced Problem Size
**********************************************/

#define n 5
#define N 32    // N = 2 ^ n
#define r 3     // r = (3/5)n
#define R 8     // R = 2 ^ r
#define RR1 28  // RR1 = R(R-1)/2
#define rbar 2  // rbar = (2/5)n
#define Rbar 4  // Rbar = 2^rbar
#define CTR 3   // CRT = 2*rbar - 1
#define tm 4    // Quantum walk iterations (floor of N/R)
#define tw 2    // Quantum walk step iterations (floor of sqrt(R))
#define tg 4    // Grover iteration (pi/4)* (Sqrt(N))
#define tbarm 2 // R/Rbar
#define tbarw 2 // GFI originally had sqrt(R) but now changed to sqrt(Rbar)
#define cn 11   // cn = 2*n + 1

// Define globals first to propagate
#include "TFP_Oracle.scaffold"

/**************************************************************
* External module : the Oracle
***************************************************************/
extern qmodule EdgeORACLE(qbit node1[], int node1offset, qbit node2[],
                         int node2offset, qbit result);

/******************************************************************
* Determine if a Node is a |00...0> and store the result in qubit
* Inverse of it must be run (after getting the final evaluation)
* to transform the input bits back
*******************************************************************/
qmodule ZeroNodeTest(qbit w[n], qbit dum[n - 1]) {
  int j = 0;
  for (j = 0; j < n; j++) {
    X(w[j]);
  }

  Toffoli(dum[0], w[1], w[0]);
  for (j = 1; j < n - 2; j++) {
    Toffoli(dum[j], dum[j - 1], w[j + 1]);
  }

  Toffoli(dum[n - 2], dum[n - 3], w[n - 1]);
}

qmodule InvZeroNodeTest(qbit w[n], qbit dum[n - 1]) {
  int j = 0;
  Toffoli(dum[n - 2], dum[n - 3], w[n - 1]);

  for (j = n - 3; j > 0; j--) {
    Toffoli(dum[j], dum[j - 1], w[j + 1]);
  }

  Toffoli(dum[0], w[1], w[0]);

  for (j = 0; j < n; j++) {
    X(w[j]);
  }
}

/******************************************************************************
*  Here we reuse the ancillae ctrbit[14] to see if input is an all 1s
*  or all 0 Register. If all-0 test, the flg bit would be 0; if all-1, flg = 1
*  We could have used length(input) to determine the "possible" value of k
*  However, since we reuse ctrbit2 a lot as input, which is of size n-1, that
*  is always greater than the value k (normally r or rbar).
*******************************************************************************/
qmodule RegTest(qbit input[], qbit dum[], int k, int flg) {
  int j = 0;

  if (flg == 0) {
    for (j = 0; j < k; j++) {
      X(input[j]);
    }
  }

  Toffoli(dum[0], input[1], input[0]);
  for (j = 1; j < k - 2; j++) {
    Toffoli(dum[j], dum[j - 1], input[j + 1]);
  }

  if (k >= 3)
    Toffoli(dum[k - 2], dum[k - 3], input[k - 1]);
}

qmodule InvRegTest(qbit input[], qbit dum[], int k, int flg) {
  int j = 0;

  if (k >= 3)
    Toffoli(dum[k - 2], dum[k - 3], input[k - 1]);

  for (j = k - 3; j > 0; j--) {
    Toffoli(dum[j], dum[j - 1], input[j + 1]);
  }

  Toffoli(dum[0], input[1], input[0]);

  if (flg == 0) {
    for (j = 0; j < k; j++) {
      X(input[j]);
    }
  }
}

/***********************************************************
* CompareIndex
* See if two indices are the same (could be r or rbar in size)
* Para: ireg and treg are the two indices we are comparing
*		dum is the global ctrbit2[14] we can reuse
*		each bit comparison is written to dum array
***********************************************************/
qmodule CompareIndex(qbit ireg[], int iregOffset, qbit treg[], int tregOffset,
                    qbit dum[], int j) {
  int i = 0;

  for (i = 0; i < j; i++) {
    CNOT(treg[tregOffset + i], ireg[iregOffset + i]);
    CNOT(dum[i], treg[tregOffset + i]);
    X(dum[i]);
  }
}

/***********************************************************
* InvCompareIndex
* Inverse of CompareIndex
* Para: ireg and treg are the two indices we are comparing
*		dum is the global ctrbit2[14] we can reuse and it
*		records the bit-wise comparison
***********************************************************/
qmodule InvCompareIndex(qbit ireg[], int iregOffset, qbit treg[], int tregOffset,
                       qbit dum[], int j) {

  int i = 0;

  for (i = j - 1; i > -1; i--) {
    X(dum[i]);
    CNOT(dum[i], treg[tregOffset + i]);
    CNOT(treg[tregOffset + i], ireg[iregOffset + i]);
  }
}

/***********************************************************
* CompareIJ
* Para: quantum integer ireg, array index idxIJ (note here
* the idxIJ is an element of type quIntr, not an array of quIntr)
* Calls CompareIndex to get the bitwise comparision of indices
* Calls RegTest to see if the bitwise comparison is all 1
* Because of this module is called by many elementary comparison
* operations, such as FetchT, FetchE, and etc. Hence,
* we need to pass those parameters (idxIJ, ctrbit2, ctrbit)
* to many modules, even these parameters are not specified in the
* GFI document
***********************************************************/
qmodule CompareIJ(qbit ireg[], int iregOffset, qbit idxIJ[], int idxOffset,
                 qbit ctrbit2[], qbit ctrbit[], int len) {
  CompareIndex(ireg, iregOffset, idxIJ, idxOffset, ctrbit2, len);
  RegTest(ctrbit2, ctrbit, len, 1);
}

qmodule InvCompareIJ(qbit ireg[], int iregOffset, qbit idxIJ[r], int idxOffset,
                    qbit ctrbit2[], qbit ctrbit[], int len) {
  InvRegTest(ctrbit2, ctrbit, len, 1);
  InvCompareIndex(ireg, iregOffset, idxIJ, idxOffset, ctrbit2, len);
}

/***********************************************************
* ctrCTRincr
* Increment the cTri by 1; considering element at
* location 0 is the least significant bit. So we are
* starting from the most significant bit  The reverse of
* this operation would be a decrement.
* Assuming that overflow case will not occur
***********************************************************/
qmodule ctrCTRincr(qbit cTri[], qbit ctrQ, qbit ctrbit2[], int k) {
  int i = 0;
  int j = 0;

  /***************************************************************************
  * the value of if the first t elements (0 till t-1) in cTri are all 1s is
  *stored at
  * ctrbit2[t] where t should be greater than 1
  *****************************************************************************/

  CNOT(ctrbit2[0], ctrQ);

  for (i = 1; i < k; i++) {
    Toffoli(ctrbit2[i], ctrbit2[i - 1], cTri[i - 1]);
  }

  for (i = k - 1; i > 0; i--) {
    CNOT(cTri[i], ctrbit2[i]);
    // uncompute ctrbit2 array
    Toffoli(ctrbit2[i], ctrbit2[i - 1], cTri[i - 1]);
  }

  CNOT(cTri[0], ctrbit2[0]);

  // uncompute
  CNOT(ctrbit2[0], ctrQ);
}

/***********************************************************
* ctrCTRdecr
* decrement the cTri by 1; similar to increment case but
* we have to test the all 0s case, instead of all 1s case.
* Assuming that overflow case will not occur
***********************************************************/
qmodule ctrCTRdecr(qbit cTri[], qbit ctrQ, qbit ctrbit2[], int k) {
  int i = 0;
  int j = 0;

  for (i = 0; i < k - 1; i++) {
    /************************************************************************
    * have to do so because we want to do an all zero test by using Toffoli
    * the most significant bit does not need to be included
    **************************************************************************/
    X(cTri[i]);
  }

  /***************************************************************************
  * the value of if the first t elements (0 till t-1) in cTri are all 0s is
  *stored at
  * ctrbit2[t] where t should be greater than 1
  *****************************************************************************/
  CNOT(ctrbit2[0], ctrQ);

  for (i = 1; i < k; i++) {
    Toffoli(ctrbit2[i], ctrbit2[i - 1], cTri[i - 1]);
  }

  for (i = k - 1; i > 0; i--) {
    CNOT(cTri[i], ctrbit2[i]);

    // correctly undo X operation on cTri (restore)
    X(cTri[i - 1]);

    // uncompute ctrbit2 array
    Toffoli(ctrbit2[i], ctrbit2[i - 1], cTri[i - 1]);
  }

  // restoring element at location 0
  X(cTri[0]);

  CNOT(cTri[0], ctrbit2[0]);

  // uncompute
  CNOT(ctrbit2[0], ctrQ);
}

/***********************************************************
* Controlled Toffoli (for 4 control bits)
************************************************************/
qmodule ctrEvaluate16(qbit target, qbit ctr3, qbit ctr2, qbit ctr1) {
  qbit tmp[1];
  Toffoli(tmp[0], ctr2, ctr1);
  Toffoli(target, ctr3, tmp[0]);

  // uncompute
  Toffoli(tmp[0], ctr2, ctr1);
}

/***********************************************
* Measure a node
************************************************/
qmodule nodeMeasure(qbit w[n], cbit ret[n]) {
  int i;

  for (i = 0; i < n; i++) {
    ret[i] = MeasX(w[i]);
  }
}

/***********************************************
* Measure array of nodes and store the value
************************************************/
qmodule TMeasure(qbit T[R * n], cbit res[R * n]) {
  int i;
  int j;

  for (i = 0; i < R; i++) {
    for (j = 0; j < n; j++) {
      res[i * n + j] = MeasX(T[i * n + j]);
    }
  }
}

/*****************************************************
* Measure array of edge connection and store the value
******************************************************/
qmodule EMeasure(qbit E[RR1], cbit fin[RR1]) {
  int i;

  for (i = 0; i < RR1; i++) {
    fin[i] = MeasX(E[i]);
  }
}

/*************************************************************************
* Algorithms 2 - 20 that are summoned by Algorithm 1 (QWTFP).
* I reordered where the algorithms appear to avoid compilation haphazard.
* Hence, they do not appear in their numerical (2-20) order.
* Here is the order 2-5, 7-14, 6, 16-17, 19-20, 18, 15, 1.
* QWTFP (algorithm 1) is moved to the botoom of this program.
*************************************************************************/
/**************************************************************
* 	Algorithm 2: ZERO
*	Initializes the qubits in a register to 0
*	Para: qbit reg[] of size n
***************************************************************/
qmodule ZERO(qbit reg) { PrepZ(reg, 0); }

/***********************************************************************
* 	Algorithm 3: INITIALIZE
*	Sets each qubit in the n-qubit register reg to 0 and
*	then calls the Hadamard gate to place reg into superpostion
*	Para: qbit reg[] of size 1
*	Comment: Along with a loop, we can use this module for
*	to perform INITIALIZE work on input register of size greater than 1.
***********************************************************************/

qmodule INITIALIZE(qbit reg) {
  PrepZ(reg, 0);
  H(reg);
}

/**************************************************************
* 	Algorithm 4: HADAMARD
*	Applies the Hadamard primitive to each qubit in the register
*	Para: qbit reg[] of size n
* 	Comment: This modules applies the Hadamard primitive to each
* 	qubit in the register, that is a combination of for loop
*	of size n and n uses of Hadamard primitive. Whenever we
*	encounter the invocation of this module, we directly
*	use a combination of for loop along with the Hadamard
* 	primitive (H) to perform such a task.
***************************************************************/

/**************************************************************
* 	Algorithm 5: SETUP
*	Para: E a (R(R-1)/2)-qubit reg
*         T a quNode[R]register:
*	      T[j] a quNote for j = 0,1,..., R-1
***************************************************************/
qmodule SETUP(qbit E[RR1], qbit T[R * n]) {
  int j = 0;
  int k = 0;
  int jk = 0;
  int l = 0;

  for (l = 0; l < RR1; l++) {
    PrepZ(E[l], 0);
  }

  // Comment: This step seems redundant since previous step already ZERO all
  // elements
  for (j = 0; j < R - 1; j++) {
    for (k = j + 1; k < R; k++) {
      jk = ((k * (k - 1)) / 2) + j;
      PrepZ(E[jk], 0);

      // Note: In Oracle implementation, the oracle takes 3 parameters;
      // hence, we have 3 parameters here.
      // EdgeORACLE(T[j], T[k], E[jk]);
      EdgeORACLE(T, j * n, T, k * n, E[jk]);
    }
  }
}

/**************************************************************
* 	Algorithm 7
*	Para: w a quNode
*		  qbit ctrbit
***************************************************************/
qmodule DIFFUSENode(qbit w[n], qbit ctrbit[]) {
  int j = 0;
  qbit tmpphase[1];

  // To generate the (|0>-|1>)/sqrt(2) state for recording phase later
  PrepZ(tmpphase[0], 0);
  X(tmpphase[0]);
  H(tmpphase[0]);

  for (j = 0; j < n; j++) {
    H(w[j]);
  }
  // get a minus sign for the state
  X(tmpphase[0]);

  // now need to reset the minus sign if the stat is |000...0>
  ZeroNodeTest(w, ctrbit);
  CNOT(tmpphase[0], ctrbit[n - 2]);
  InvZeroNodeTest(w, ctrbit);

  // uncompute tmpphase
  H(tmpphase[0]);
  X(tmpphase[0]);

  for (j = 0; j < n; j++) {
    H(w[j]);
  }
}

/**************************************************************
* 	Algorithm 7-1
*	Para: alpha: quNode of size n
*		  beta: quantum registers of size r
*		  qbit ctrbit2
*		  qbit ctrbit
***************************************************************/
// perform Diffuse on two registers of size n (this is quNode) and r,
// respectively
qmodule DIFFUSEVI(qbit alpha[n], qbit beta[r], qbit ctrbit2[], qbit ctrbit[]) {
  // a, b are always n - 1
  int j = 0;
  int i = 0;
  qbit tmpphase[1];

  // To generate the (|0>-|1>)/sqrt(2) state for recording phase later
  PrepZ(tmpphase[0], 0);
  X(tmpphase[0]);
  H(tmpphase[0]);

  // since quNode is always of size n
  for (j = 0; j < n; j++) {
    H(alpha[j]);
  }

  for (i = 0; i < r; i++) {
    H(beta[i]);
  }

  X(tmpphase[0]);

  ZeroNodeTest(alpha, ctrbit);
  // ctrbit2 is also of size n-1, hence, we have extra n-r = 6 bits left after
  // Zero RegTest
  RegTest(beta, ctrbit2, r, 0);
  Toffoli(ctrbit2[r - 1], ctrbit2[r - 2], ctrbit[n - 2]);
  CNOT(tmpphase[0], ctrbit2[r - 1]);

  // uncompute
  Toffoli(ctrbit2[r - 1], ctrbit2[r - 2], ctrbit[n - 2]);
  InvRegTest(beta, ctrbit2, r, 0);
  InvZeroNodeTest(alpha, ctrbit);

  // uncompute tmpphase
  H(tmpphase[0]);
  X(tmpphase[0]);

  for (j = 0; j < n; j++) {
    H(alpha[j]);
  }

  for (i = 0; i < r; i++) {
    H(beta[i]);
  }
}

/********************************************************************
* 	Algorithm 7-2
*	Para: ta, ma:  are quantum registers(iota and sigma) of GCQWRegs
*		  qbit ctrbit2
*		  qbit ctrbit
*********************************************************************/
// perform Diffuse on two registers of size rbar and r, respectively
qmodule DIFFUSEGC(qbit ta[rbar], qbit ma[r], qbit ctrbit2[], qbit ctrbit[]) {
  int i = 0;
  int j = 0;
  qbit tmpphase[1];

  // To generate the (|0>-|1>)/sqrt(2) state for recording phase later
  PrepZ(tmpphase[0], 0);
  X(tmpphase[0]);
  H(tmpphase[0]);

  for (i = 0; i < rbar; i++) {
    H(ta[i]);
  }

  for (j = 0; j < r; j++) {
    H(ma[j]);
  }

  // get minus sign for all states
  X(tmpphase[0]);

  // remove minus sign for |00..0>
  RegTest(ta, ctrbit, rbar, 0);
  // ctrbit2 is also of size n-1, hence, we have extra n-r = 6 bits left after
  // RegTest
  RegTest(ma, ctrbit2, r, 0);
  Toffoli(ctrbit2[r - 1], ctrbit2[r - 2], ctrbit[rbar - 2]);
  CNOT(tmpphase[0], ctrbit2[r - 1]);

  // uncompute
  Toffoli(ctrbit2[r - 1], ctrbit2[r - 2], ctrbit[rbar - 2]);
  InvRegTest(ma, ctrbit2, r, 0);
  InvRegTest(ta, ctrbit, rbar, 0);

  // uncompute tmpphase
  H(tmpphase[0]);
  X(tmpphase[0]);

  for (i = 0; i < rbar; i++) {
    H(ta[i]);
  }

  for (j = 0; j < r; j++) {
    H(ma[j]);
  }
}

/**************************************************************
* 	Algorithm 8
*	Para: I	quIntr
*	      T an array of R quNodes
*	      Td a quNode register (that is n qubits)
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
***************************************************************/
qmodule FetchT(qbit I[], int Ioffset, qbit T[R * n], qbit Td[n],
              qbit idxIJ[R * r], qbit ctrbit2[n - 1], qbit ctrbit[n - 1]) {
  int j = 0;
  int k = 0;

  for (j = 0; j < R; j++) {
    CompareIJ(I, Ioffset, idxIJ, j * r, ctrbit2, ctrbit, r);

    for (k = 0; k < n; k++) {
      Toffoli(Td[k], T[j * n + k], ctrbit[r - 2]);
    }
    InvCompareIJ(I, Ioffset, idxIJ, j * r, ctrbit2, ctrbit, r);
  }
}

/**************************************************************
* 	Algorithm 8-1
*	Para: I	an arry of r qubits
*	      T an array of R qubits
*	      Td an array of Rbar qubits
*         b integer (in this case it is 1)
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
***************************************************************/
qmodule FetchTr1(qbit I[], int Ioffset, qbit T[R], qbit Td, int b,
                qbit idxIJ[R * r], qbit ctrbit2[n - 1], qbit ctrbit[n - 1]) {
  int j = 0;
  int k = 0;

  for (j = 0; j < R; j++) {
    CompareIJ(I, Ioffset, idxIJ, j * r, ctrbit2, ctrbit, r);
    for (k = 0; k < b; k++) {
      // in this case, k is always 0
      Toffoli(Td, T[j], ctrbit[r - 2]);
    }
    InvCompareIJ(I, Ioffset, idxIJ, j * r, ctrbit2, ctrbit, r);
  }
}

/**************************************************************
* 	Algorithm 8-2
*	Para: iota	an arry of rbar qubits
*	      tau an array of R qubits
*	      Td an array of Rbar qubits
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
***************************************************************/
qmodule FetchTrbarr(qbit iota[rbar], qbit tau[Rbar * r], qbit Td[r],
                   qbit idxIJ[R * r], qbit ctrbit2[n - 1], qbit ctrbit[n - 1]) {
  int j = 0;
  int k = 0;

  for (j = 0; j < Rbar; j++) {
    CompareIJ(iota, 0, idxIJ, j * r, ctrbit2, ctrbit, r);
    for (k = 0; k < r; k++) {
      Toffoli(Td[k], tau[j * r + k], ctrbit[rbar - 2]);
    }
    InvCompareIJ(iota, 0, idxIJ, j * r, ctrbit2, ctrbit, r);
  }
}

/**************************************************************
* 	Algorithm 9
*	Para: i	an array of r qubits
*	      T an array of R quNodes
*	      Td a quNode register (that is n qubits)
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
***************************************************************/
qmodule StoreT(qbit I[r], qbit T[R * n], qbit Td[n], qbit idxIJ[R * r],
              qbit ctrbit2[n - 1], qbit ctrbit[n - 1]) {
  int j = 0;
  int k = 0;

  for (j = 0; j < R; j++) {
    CompareIJ(I, 0, idxIJ, j * r, ctrbit2, ctrbit, r);
    for (k = 0; k < n; k++) {
      Toffoli(T[j * n + k], Td[k], ctrbit[r - 2]);
    }
    InvCompareIJ(I, 0, idxIJ, j * r, ctrbit2, ctrbit, r);
  }
}

/**************************************************************
* 	Algorithm 9-1
*	Para: i	an array of rbar qubits
*	      T an array of Rbar quIntr
*	      Td  r qubits
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
***************************************************************/
qmodule StoreTrbarr(qbit I[rbar], qbit T[Rbar * r], qbit Td[r],
                   qbit idxIJ[R * r], qbit ctrbit2[n - 1], qbit ctrbit[n - 1]) {
  int j = 0;
  int k = 0;

  for (j = 0; j < Rbar; j++) {
    CompareIJ(I, 0, idxIJ, j * r, ctrbit2, ctrbit, r);
    for (k = 0; k < r; k++) {
      Toffoli(T[j * r + k], Td[k], ctrbit[rbar - 2]);
    }
    InvCompareIJ(I, 0, idxIJ, j * r, ctrbit2, ctrbit, r);
  }
}

/**************************************************************
* 	Algorithm 10
*	Para: i	an array of rbar qubits
*	      T an array of R quNodes
*	      Td a quNode register (that is n qubits)
*	      b integer	(given) [cannot use the global variable n]
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
*	Comment: As seen in later function calls, the parameter b
*	could be of values other than n or r.
***************************************************************/
qmodule FetchStoreT(qbit I[rbar], qbit T[Rbar], qbit Td, int b,
                   qbit idxIJ[R * r], qbit ctrbit2[n - 1], qbit ctrbit[n - 1]) {
  int j = 0;
  int k = 0;

  for (j = 0; j < Rbar; j++) {
    CompareIJ(I, 0, idxIJ, j * r, ctrbit2, ctrbit, r);
    for (k = 0; k < b; k++) {
      // Here it is only one bit, hence, do not use SWAP but Swap
      // Throughout the whole program, when this module is summoned, the
      // parameter b is always 1
      // Since b is always 1, k is always 0
      ctrSwap(T[j], Td, ctrbit[rbar - 2]);
    }
    InvCompareIJ(I, 0, idxIJ, j * r, ctrbit2, ctrbit, r);
  }
}

/**************************************************************
* 	Algorithm 11
*	Para: i	an array of r qubits
*	      E qbit[] of size (R(R-1)/2)
*	      Ed qbit[] of size R
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
***************************************************************/
qmodule FetchE(qbit I[], int Ioffset, qbit E[RR1], qbit Ed[R], qbit idxIJ[R * r],
              qbit ctrbit2[n - 1], qbit ctrbit[n - 1]) {
  int j = 0;

  int k = 0;
  int kj = 0;
  int jk = 0;

  for (j = 0; j < R; j++) {
    CompareIJ(I, Ioffset, idxIJ, j * r, ctrbit2, ctrbit, r);
    for (k = 0; k < j; k++) {
      kj = ((j * (j - 1)) / 2) + k;
      Toffoli(Ed[k], E[kj], ctrbit[r - 2]);
    }

    for (k = j + 1; k < R; k++) {
      jk = ((k * (k - 1)) / 2) + j;
      Toffoli(Ed[k], E[jk], ctrbit[r - 2]);
    }
    InvCompareIJ(I, Ioffset, idxIJ, j * r, ctrbit2, ctrbit, r);
  }
}

/**************************************************************
* 	Algorithm 12
*	Para: I qubit array of size r
*	      E qbit[] of size (R(R-1)/2)
*	      Ed qbit[] of size R
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
***************************************************************/
qmodule FetchStoreE(qbit I[], qbit E[RR1], qbit Ed[R], qbit idxIJ[R * r],
                   qbit ctrbit2[n - 1], qbit ctrbit[n - 1]) {
  int j = 0;
  int k = 0;
  int kj = 0;
  int jk = 0;

  for (j = 0; j < R; j++) {
    CompareIJ(I, 0, idxIJ, j * r, ctrbit2, ctrbit, r);
    for (k = 0; k < j; k++) {
      kj = ((j * (j - 1)) / 2) + k;
      // Note: only 1 bit change, should be Swap, not SWAP(given in GFI
      // document)
      // depreciated; because of ctrNode; Swap(E[kj], Ed[k]);
      ctrSwap(E[kj], Ed[k], ctrbit[r - 2]);
    }

    for (k = j + 1; k < R; k++) {
      // Maybe we can reuse the variable kj without using variable jk
      jk = ((k * (k - 1)) / 2) + j;
      // Note: only 1 bit change, should be Swap, not SWAP(given in GFI
      // document)
      // depreciated; because of ctrNode; Swap(E[jk], Ed[k]);
      ctrSwap(E[jk], Ed[k], ctrbit[r - 2]);
    }
    InvCompareIJ(I, 0, idxIJ, j * r, ctrbit2, ctrbit, r);
  }
}

/**************************************************************
* 	Algorithm 13
*	Para: T quNode[R] register
*	      Td a quNode: qbit[] of size n
*	      Ed qbit[] of size R
***************************************************************/
qmodule UPDATE(qbit T[R * n], qbit Td[n], qbit Ed[R]) {
  int j = 0;

  for (j = 0; j < R; j++) {
    EdgeORACLE(T, j * n, Td, 0, Ed[j]);
  }
}

/**************************************************************
* 	Algorithm 14
*	Para: Td a quNode: qbit[] of size n
*	      v a quNode: qbit[] of size n
***************************************************************/
qmodule SWAP(qbit Td[n], qbit v[n]) {
  int j = 0;
  for (j = 0; j < n - 1; j++) {
    // three CNOT is a simple bit-wise Swap
    CNOT(Td[j], v[j]);
    CNOT(v[j], Td[j]);
    CNOT(Td[j], v[j]);
  }
}

/**************************************************************
* 	Algorithm 6
*	Para: T an array of quNodes
*	      i a register of size r
*	      v a quNode register (that is n qubits)
*	      E a (R(R-1)/2)-qubit register
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
***************************************************************/
qmodule QWSH(qbit T[R * n], qbit i[r], qbit v[n], qbit E[RR1], qbit idxIJ[R * r],
            qbit ctrbit2[n - 1], qbit ctrbit[n - 1]) {
  qbit Td[n];
  qbit Ed[R];
  int j;

  for (j = 0; j < n; j++) {
    PrepZ(Td[j], 0);
    PrepZ(Ed[j], 0);
  }

  // Diffuse on i and v registers

  DIFFUSEVI(v, i, ctrbit2, ctrbit);

  FetchT(i, 0, T, Td, idxIJ, ctrbit2, ctrbit);

  FetchStoreE(i, E, Ed, idxIJ, ctrbit2, ctrbit);

  UPDATE(T, Td, Ed);

  StoreT(i, T, Td, idxIJ, ctrbit2, ctrbit);

  SWAP(Td, v);

  StoreT(i, T, Td, idxIJ, ctrbit2, ctrbit);

  UPDATE(T, Td, Ed);

  FetchStoreE(i, E, Ed, idxIJ, ctrbit2, ctrbit);

  FetchT(i, 0, T, Td, idxIJ, ctrbit2, ctrbit);
}

/*****************************************************************************************************
* ASK: For Alg 16-17, we dunno know if test[0] would be 0 or 1 when it is passed
*in
* the OR function is not reversible. If test[0] is always 0 when passed in,
* then we can simply follow the suggestion. I assume it is always a 0 when
*passed in
******************************************************************************************************/

/**************************************************************
* 	Algorithm 16
*	Para: E: qbit[(R(R-1))/2]
*		  test: qbit[1]
***************************************************************/
qmodule TriangleTestT(qbit E[RR1], qbit test) {
  int i = 0;
  int j = 0;
  int k = 0;
  int ij = 0;
  int ik = 0;
  int jk = 0;
  qbit dum[1];
  qbit triCnt[3 * r];
  qbit lctrbit[3 * r];

  for (i = 0; i < R; i++) {
    for (j = i + 1; j < R; j++) {
      ij = i + (j * (j - 1)) / 2;
      for (k = j + 1; k < R; k++) {
        ik = i + (k * (k - 1)) / 2;
        jk = j + (k * (k - 1)) / 2;

        ctrEvaluate16(dum[0], E[jk], E[ij], E[ik]);

        // increment triCnt based on the value of dum[0]
        ctrCTRincr(triCnt, dum[0], lctrbit, 3 * r);

        // uncompute dum[0]
        ctrEvaluate16(dum[0], E[jk], E[ij], E[ik]);
      }
    }
  }

  // if triCnt is all 0, then we do not need to set test[0] to 1
  RegTest(triCnt, lctrbit, 3 * r, 0);
  CNOT(test, lctrbit[3 * r - 2]);
  X(test);
  InvRegTest(triCnt, lctrbit, 3 * r, 0);

  // uncompute triCnt
  for (i = 0; i < R; i++) {
    for (j = i + 1; j < R; j++) {
      ij = i + (j * (j - 1)) / 2;
      for (k = j + 1; k < R; k++) {
        ik = i + (k * (k - 1)) / 2;
        jk = j + (k * (k - 1)) / 2;

        ctrEvaluate16(dum[0], E[jk], E[ij], E[ik]);

        // deccrement triCnt based on the value of dum[0]
        ctrCTRdecr(triCnt, dum[0], lctrbit, 3 * r);

        // uncompute dum[0]
        ctrEvaluate16(dum[0], E[jk], E[ij], E[ik]);
      }
    }
  }
}

/**************************************************************
* 	Algorithm 17
*	Para: T: a quNode[R] register
*		  E: qbit[(R(R-1))/2]
*		  w: a quNode: qbit[] of size n
*		  test: qbit[1]
***************************************************************/
qmodule TriangleTestTw(qbit T[R * n], qbit E[RR1], qbit w[n], qbit test) {
  qbit Ed[R];
  int i = 0;
  int j = 0;
  int ij = 0;
  qbit dum[1];
  qbit triCnt[3 * r];
  qbit lctrbit[3 * r];

  PrepZ(test, 0);

  for (i = 0; i < R; i++) {
    // Store value into Ed register
    EdgeORACLE(T, i * n, w, 0, Ed[i]);
  }

  for (i = 0; i < R; i++) {
    for (j = i + 1; j < R; j++) {
      ij = i + (j * (j + 1)) / 2;

      ctrEvaluate16(dum[0], E[ij], E[i], E[j]);

      // increment triCnt based on the value of dum[0]
      ctrCTRincr(triCnt, dum[0], lctrbit, 3 * r);

      // uncompute dum[0]
      ctrEvaluate16(dum[0], E[ij], E[i], E[j]);
    }
  }

  // if triCnt is all 0, then we do not need to set test[0] to 1
  RegTest(triCnt, lctrbit, 3 * r, 0);
  CNOT(test, lctrbit[3 * r - 2]);
  X(test);
  InvRegTest(triCnt, lctrbit, 3 * r, 0);

  for (i = 0; i < R; i++) {
    for (j = i + 1; j < R; j++) {
      ij = i + (j * (j + 1)) / 2;

      ctrEvaluate16(dum[0], E[ij], E[i], E[j]);

      // increment triCnt based on the value of dum[0]
      ctrCTRdecr(triCnt, dum[0], lctrbit, 3 * r);

      // uncompute dum[0]
      ctrEvaluate16(dum[0], E[ij], E[i], E[j]);
    }
  }

  for (i = 0; i < R; i++) {
    // Uncompute Ed register
    EdgeORACLE(T, i * n, w, 0, Ed[i]);
  }
}

/**************************************************************
* 	Algorithm 20
*	Para: T: a quNode[R] register
*		  E: qbit[(R(R-1))/2]
*		  w: a quNode: qbit[] of size n
*		  GCQWRegs (Graph Collision Workspace Registers)
* 		  Td: quNode (that is qbit[n])
*		  Ed: qbit[R]
*		  taud: qbit[r]
*		  Ewd: 	qbit
* 		  Edd:  qbit[Rbar]
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
***************************************************************/

qmodule GCQWalkStep(qbit T[R * n], qbit E[RR1], qbit w[n],
                   /*GCQWRegs GC,*/ qbit Td[n], qbit Ed[R], qbit taud[r],
                   qbit Ewd, qbit Edd[Rbar], qbit idxIJ[R * r],
                   qbit ctrbit2[n - 1], qbit ctrbit[n - 1], qbit tau[Rbar * r],
                   qbit sigma[r], qbit iota[rbar], qbit Ew[Rbar],
                   qbit cTri[2 * rbar - 1], qbit triTestT, qbit triTestTw) {
  int j;

  // Perform the Diffuse function on iota and sigma
  DIFFUSEGC(iota, sigma, ctrbit2, ctrbit);

  /*****************************************
  * Prepare data register for SWAP and Update
  * Computing taud
  *****************************************/
  FetchTrbarr(iota, tau, taud, idxIJ, ctrbit2, ctrbit);

  // Computig Td
  FetchT(taud, 0, T, Td, idxIJ, ctrbit2, ctrbit);

  FetchStoreT(iota, Ew, Ewd, 1, idxIJ, ctrbit2, ctrbit);

  // Computing Ed
  FetchE(taud, 0, E, Ed, idxIJ, ctrbit2, ctrbit);

  // Fetching and computing Edd
  for (j = 0; j < Rbar; j++) {
    FetchTr1(tau, j * r, Ed, Edd[j], 1, idxIJ, ctrbit2, ctrbit);
  }

  // Update cTri using current edge values in Ewd
  for (j = 0; j < Rbar; j++) {
    Toffoli(ctrbit[0], Ewd, Ew[j]);
    Toffoli(ctrbit[1], ctrbit[0], Edd[j]);

    ctrCTRdecr(cTri, ctrbit[1], ctrbit2, 2 * rbar - 1);

    // uncompute
    Toffoli(ctrbit[1], ctrbit[0], Edd[j]);
    Toffoli(ctrbit[0], Ewd, Ew[j]);
  }

  // Erase current edge values in Ewd
  EdgeORACLE(Td, 0, w, 0, Ewd);

  // Prepare data register for SWAP
  for (j = 0; j < Rbar; j++) { // Uncompute Edd
    FetchTr1(tau, j * r, Ed, Edd[j], 1, idxIJ, ctrbit2, ctrbit);
  }

  FetchE(taud, 0, E, Ed, idxIJ, ctrbit2, ctrbit); // Uncompute Ed

  FetchT(taud, 0, T, Td, idxIJ, ctrbit2, ctrbit); // Uncompute Td

  StoreTrbarr(iota, tau, taud, idxIJ, ctrbit2, ctrbit);

  for (j = 0; j < r; j++) {
    Swap(taud[j], sigma[j]);
  }

  // Uncompute data registers after SWAP operation
  StoreTrbarr(iota, tau, taud, idxIJ, ctrbit2, ctrbit);

  FetchT(taud, 0, T, Td, idxIJ, ctrbit2, ctrbit);

  FetchE(taud, 0, E, Ed, idxIJ, ctrbit2, ctrbit);

  for (j = 0; j < Rbar; j++) {
    FetchTr1(tau, j * r, Ed, Edd[j], 1, idxIJ, ctrbit2, ctrbit);
  }

  // Compute new edge info in Ewd
  EdgeORACLE(Td, 0, w, 0, Ewd);

  // Update Ewd and cTri using  any new triangles involving Ewd
  for (j = 0; j < Rbar; j++) {
    Toffoli(ctrbit[0], Ewd, Ew[j]);
    Toffoli(ctrbit[1], ctrbit[0], Edd[j]);

    ctrCTRdecr(cTri, ctrbit[1], ctrbit2, 2 * rbar - 1);

    // uncompute
    Toffoli(ctrbit[1], ctrbit[0], Edd[j]);
    Toffoli(ctrbit[0], Ewd, Ew[j]);
  }

  // Restore data and data registers to initial state
  for (j = 0; j < Rbar; j++) {
    FetchTr1(tau, j * r, Ed, Edd[j], 1, idxIJ, ctrbit2, ctrbit);
  }

  FetchE(taud, 0, E, Ed, idxIJ, ctrbit2, ctrbit);
  FetchStoreT(iota, Ew, Ewd, 1, idxIJ, ctrbit2, ctrbit);

  FetchT(taud, 0, T, Td, idxIJ, ctrbit2, ctrbit);

  FetchTrbarr(iota, tau, taud, idxIJ, ctrbit2, ctrbit);
}

/**************************************************************
* 	Algorithm 19
*	Para: T: a quNode[R] register
*		  E: qbit[(R(R-1))/2]
*		  w: a quNode: qbit[] of size n
*		  GCQWRegs (Graph Collision Workspace Registers)
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
***************************************************************/
qmodule GCQWalk(qbit T[R * n], qbit E[RR1], qbit w[n],
               /*GCQWRegs GC,*/ qbit idxIJ[R * r], qbit ctrbit2[n - 1],
               qbit ctrbit[n - 1], qbit tau[Rbar * r], qbit sigma[r],
               qbit iota[rbar], qbit Ew[Rbar], qbit cTri[2 * rbar - 1],
               qbit triTestT, qbit triTestTw) {
  qbit Td[n];
  qbit Ed[R];
  qbit taud[r];
  qbit Ewd[1];
  qbit Edd[Rbar];
  qbit tmpphase[1];

  int j = 0;
  int k = 0;

  // To generate the (|0>-|1>)/sqrt(2) state for recording phase later
  PrepZ(tmpphase[0], 0);
  X(tmpphase[0]);
  H(tmpphase[0]);

  for (j = 0; j < Rbar; j++) {
    for (k = 0; k < r; k++) {
      H(tau[j * r + k]);
    }
  }

  // Apply Hadamard to Walk Registers
  for (j = 0; j < rbar; j++) {
    H(iota[j]);
  }

  for (j = 0; j < r; j++) {
    H(sigma[j]);
  }

  // Zero the workspace registers
  for (j = 0; j < n; j++) {
    PrepZ(Td[j], 0);
  }

  for (j = 0; j < R; j++) {
    PrepZ(Ed[j], 0);
  }

  /*********************************************************
  * In GFI, it comments that Ew and cTri should be 0
  * and those two operations are not included in the pesudocode
  * ASK: to be included?
* CUT HERE
  **********************************************************/
  for (j = 0; j < Rbar; j++) {
    PrepZ(Ew[j], 0);
  }

  for (j = 0; j < 2 * rbar - 1; j++) {
    PrepZ(cTri[j], 0);
  }
  /*********************************************************
* CUT HERE
  **********************************************************/
  for (j = 0; j < r; j++) {
    PrepZ(taud[0], 0);
  }

  PrepZ(Ewd[0], 0);

  for (j = 0; j < Rbar; j++) {
    PrepZ(Edd[j], 0);
  }

  // Set up the walk state
  for (j = 0; j < Rbar; j++) {
    FetchT(tau, j * r, T, Td, idxIJ, ctrbit2, ctrbit);

    // can directly write result into Ew since it is initialized in 0
    EdgeORACLE(Td, 0, w, 0, Ew[j]);
    FetchT(tau, j * r, T, Td, idxIJ, ctrbit2, ctrbit);
  }

  for (j = 0; j < Rbar; j++) {
    FetchE(tau, j * r, E, Ed, idxIJ, ctrbit2, ctrbit);
    for (k = j + 1; k < Rbar; k++) {
      FetchTr1(tau, k * r, Ed, Edd[k], 1, idxIJ, ctrbit2, ctrbit);

      Toffoli(ctrbit[0], Ew[j], Ew[k]);
      Toffoli(ctrbit[1], ctrbit[0], Edd[k]);

      ctrCTRincr(cTri, ctrbit[1], ctrbit2, 2 * rbar - 1);

      // uncompute
      Toffoli(ctrbit[1], ctrbit[0], Edd[k]);
      Toffoli(ctrbit[0], Ew[j], Ew[k]);

      FetchTr1(tau, k * r, Ed, Edd[k], 1, idxIJ, ctrbit2, ctrbit);
    }
    FetchE(tau, j * r, E, Ed, idxIJ, ctrbit2, ctrbit);
  }

  // Execute the Graph Collision Random Walk
  for (j = 0; j < tbarm; j++) {
    RegTest(cTri, ctrbit, CTR, 0);
    X(ctrbit[CTR - 2]);
    X(triTestT);
    Toffoli(ctrbit[CTR - 1], ctrbit[CTR - 2], triTestT);

    // phase flip
    CNOT(tmpphase[0], ctrbit[CTR - 1]);

    // uncompute
    Toffoli(ctrbit[CTR - 1], ctrbit[CTR - 2], triTestT);
    X(triTestT);
    X(ctrbit[CTR - 2]);
    InvRegTest(cTri, ctrbit, CTR, 0);

    // uncompute tmpphase
    H(tmpphase[0]);
    X(tmpphase[0]);

    for (k = 0; k < tbarw; k++) {
      GCQWalkStep(T, E, w, /*GC,*/ Td, Ed, taud, Ewd[0], Edd, idxIJ, ctrbit2,
                  ctrbit, tau, sigma, iota, Ew, cTri, triTestT, triTestTw);
    }
  }
}

/**************************************************************
* 	Algorithm 19i
*	Para: T: a quNode[R] register
*		  E: qbit[(R(R-1))/2]
*		  w: a quNode: qbit[] of size n
*		  GCQWRegs (Graph Collision Workspace Registers)
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
***************************************************************/
qmodule InvGCQWalk(qbit T[R * n], qbit E[RR1], qbit w[n],
                  /*GCQWRegs GC,*/ qbit idxIJ[R * r], qbit ctrbit2[n - 1],
                  qbit ctrbit[n - 1], qbit tau[Rbar * r], qbit sigma[r],
                  qbit iota[rbar], qbit Ew[Rbar], qbit cTri[2 * rbar - 1],
                  qbit triTestT, qbit triTestTw) {
  qbit Td[n];
  qbit Ed[R];
  qbit taud[r];
  qbit Ewd[1];
  qbit Edd[Rbar];
  qbit tmpphase[1];

  int j = 0;
  int k = 0;

  // To generate the (|0>-|1>)/sqrt(2) state for recording phase later
  PrepZ(tmpphase[0], 0);
  X(tmpphase[0]);
  H(tmpphase[0]);

  for (j = 0; j < Rbar; j++) {
    for (k = 0; k < r; k++) {
      H(tau[j * r + k]);
    }
  }

  // Apply Hadamard to Walk Registers
  for (j = 0; j < rbar; j++) {
    H(iota[j]);
  }

  for (j = 0; j < r; j++) {
    H(sigma[j]);
  }

  // Zero the workspace registers
  for (j = 0; j < n; j++) {
    PrepZ(Td[j], 0);
  }

  for (j = 0; j < R; j++) {
    PrepZ(Ed[j], 0);
  }

  /*********************************************************
  * In GFI, it comments that Ew and cTri should be 0
  * and those two operations are not included in the pesudocode
  * ASK: to be included?
* CUT HERE
  **********************************************************/
  for (j = 0; j < Rbar; j++) {
    PrepZ(Ew[j], 0);
  }

  for (j = 0; j < 2 * rbar - 1; j++) {
    PrepZ(cTri[j], 0);
  }
  /*********************************************************
* CUT HERE
  **********************************************************/
  for (j = 0; j < r; j++) {
    PrepZ(taud[0], 0);
  }

  PrepZ(Ewd[0], 0);

  for (j = 0; j < Rbar; j++) {
    PrepZ(Edd[j], 0);
  }

  // Execute the Graph Collision Random Walk
  for (j = tbarm - 1; j >= 0; j--) {
    for (k = tbarw - 1; k >= 0; k--) {
      GCQWalkStep(T, E, w, /*GC,*/ Td, Ed, taud, Ewd[0], Edd, idxIJ, ctrbit2,
                  ctrbit, tau, sigma, iota, Ew, cTri, triTestT, triTestTw);
    }

    // uncompute tmpphase
    X(tmpphase[0]);
    H(tmpphase[0]);

    // uncompute
    InvRegTest(cTri, ctrbit, CTR, 0);
    X(ctrbit[CTR - 2]);
    X(triTestT);
    Toffoli(ctrbit[CTR - 1], ctrbit[CTR - 2], triTestT);

    // phase flip
    CNOT(tmpphase[0], ctrbit[CTR - 1]);

    Toffoli(ctrbit[CTR - 1], ctrbit[CTR - 2], triTestT);
    X(triTestT);
    X(ctrbit[CTR - 2]);
    RegTest(cTri, ctrbit, CTR, 0);
  }

  for (j = Rbar - 1; j >= 0; j--) {
    FetchE(tau, j * r, E, Ed, idxIJ, ctrbit2, ctrbit);
    for (k = Rbar - 1; k >= j + 1; k--) {
      FetchTr1(tau, k * r, Ed, Edd[k], 1, idxIJ, ctrbit2, ctrbit);

      Toffoli(ctrbit[0], Ew[j], Ew[k]);
      Toffoli(ctrbit[1], ctrbit[0], Edd[k]);

      ctrCTRincr(cTri, ctrbit[1], ctrbit2, 2 * rbar - 1);

      // uncompute
      Toffoli(ctrbit[1], ctrbit[0], Edd[k]);
      Toffoli(ctrbit[0], Ew[j], Ew[k]);

      FetchTr1(tau, k * r, Ed, Edd[k], 1, idxIJ, ctrbit2, ctrbit);
    }
    FetchE(tau, j * r, E, Ed, idxIJ, ctrbit2, ctrbit);
  }

  // Set up the walk state
  for (j = Rbar - 1; j >= 0; j--) {
    FetchT(tau, j * r, T, Td, idxIJ, ctrbit2, ctrbit);

    // can directly write result into Ew since it is initialized in 0
    EdgeORACLE(Td, 0, w, 0, Ew[j]);
    FetchT(tau, j * r, T, Td, idxIJ, ctrbit2, ctrbit);
  }
}

/**************************************************************
* 	Algorithm 18
*	Para: T: a quNode[R] register
*		  E: qbit[(R(R-1))/2]
*		  w: a quNode: qbit[] of size n
*		  GCQWRegs (Graph Collision Workspace Registers)
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
***************************************************************/
qmodule TriangleEdgeSearch(qbit T[R * n], qbit E[RR1], qbit w[n],
                          /*GCQWRegs GC,*/ qbit idxIJ[R * r],
                          qbit ctrbit2[n - 1], qbit ctrbit[n - 1],
                          qbit tau[Rbar * r], qbit sigma[r], qbit iota[rbar],
                          qbit Ew[Rbar], qbit cTri[2 * rbar - 1], qbit triTestT,
                          qbit triTestTw) {
  int i = 0;
  qbit tmpphase[1];

  // To generate the (|0>-|1>)/sqrt(2) state for recording phase later
  PrepZ(tmpphase[0], 0);
  X(tmpphase[0]);
  H(tmpphase[0]);

  // Grover Search on w using graph collision to T, w
  for (i = 0; i < n; i++) {
    H(w[i]);
  }

  for (i = 0; i < tg; i++) {
    GCQWalk(T, E, w, idxIJ, ctrbit2, ctrbit, tau, sigma, iota, Ew, cTri,
            triTestT, triTestTw);

    RegTest(cTri, ctrbit, CTR, 0);
    X(ctrbit[CTR - 2]);
    Toffoli(ctrbit[CTR - 1], ctrbit[CTR - 2], triTestT);
    // phase kickback
    CNOT(tmpphase[0], ctrbit[CTR - 1]);

    // uncompute
    Toffoli(ctrbit[CTR - 1], ctrbit[CTR - 2], triTestT);
    X(ctrbit[CTR - 2]);
    InvRegTest(cTri, ctrbit, CTR, 0);

    // TODO: Assume the inverse function will be present when provided the
    // original circuit
    InvGCQWalk(T, E, w, /*GC,*/ idxIJ, ctrbit2, ctrbit, tau, sigma, iota, Ew,
               cTri, triTestT, triTestTw);

    // Diffuse on the node
    DIFFUSENode(w, ctrbit);
  }

  // uncompute tmpphase
  H(tmpphase[0]);
  X(tmpphase[0]);
}

/****************************************************************************************
* 	Algorithm 15
*	Para: T: a quNode[R] register
*		  E: qbit[(R(R-1))/2]
*		  w: a quNode: qbit[] of size n
*		  GCQWRegs (Graph Collision Workspace Registers)
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
*	Comment: triTestT set to 1 is T contains the triangle from G
*			 triTestTw set to 1 when w is a node of the triangle with
*the other edge in T
*****************************************************************************************/
qmodule TestTriangleEdges(qbit T[R * n], qbit E[RR1], qbit w[n],
                         /*GCQWRegs GC,*/ qbit idxIJ[R * r],
                         qbit ctrbit2[n - 1], qbit ctrbit[n - 1],
                         qbit tau[Rbar * r], qbit sigma[r], qbit iota[rbar],
                         qbit Ew[Rbar], qbit cTri[2 * rbar - 1], qbit triTestT,
                         qbit triTestTw) {
  /**********************************************
  * set triTestT to 1 if T contains the triangle
  ***********************************************/
  TriangleTestT(E, triTestT);

  /************************************************************************
  * Grover with Graph collision
  * Mistake in the GFI document; TriangleEdgeSearch function does not need
  * triTestT parameter as it is embeded in GC register; here I removed that
  * parameter from the code
  *************************************************************************/
  TriangleEdgeSearch(T, E, w, /*GC,*/ idxIJ, ctrbit2, ctrbit, tau, sigma, iota,
                     Ew, cTri, triTestT, triTestTw);

  /****************************************************************************************
  * Marking T, w and copy that value
  * The data structure of GCQWRegs misses the field "iota" in statement of
  *algorithm 15
  ******************************************************************************************/
  TriangleTestTw(T, E, w, triTestTw);
}

/****************************************************************************************
* 	Algorithm 15i
*	Para: T: a quNode[R] register
*		  E: qbit[(R(R-1))/2]
*		  w: a quNode: qbit[] of size n
*		  GCQWRegs (Graph Collision Workspace Registers)
*		  qbit idxIJ[r][R]
*		  qbit ctrbit2[n-1]
*		  qbit ctrbit[n-1]
*	Comment: Inverts the TestTriangleEdges function for additional
*processing
*****************************************************************************************/
qmodule InvTestTriangleEdges(qbit T[R * n], qbit E[RR1], qbit w[n],
                            /*GCQWRegs GC,*/ qbit idxIJ[R * r],
                            qbit ctrbit2[n - 1], qbit ctrbit[n - 1],
                            qbit tau[Rbar * r], qbit sigma[r], qbit iota[rbar],
                            qbit Ew[Rbar], qbit cTri[2 * rbar - 1],
                            qbit triTestT, qbit triTestTw) {
  TriangleTestTw(T, E, w, triTestTw);
  TriangleEdgeSearch(T, E, w, /*GC,*/ idxIJ, ctrbit2, ctrbit, tau, sigma, iota,
                     Ew, cTri, triTestT, triTestTw);
  TriangleTestT(E, triTestT);
}

int main() {
  cbit testTMeasure[1];
  cbit ret[n];
  cbit res[R * n];
  cbit fin[RR1];

  int j = 0;
  int k = 0;
  int l = 0;

  // Required quantum registers (the initial circuit input)
  // Suppose n = 15 then
  // T: 512 * 15 ; v:15; E:130816; w:15 (1 extra bit for phase);
  // testTEdge: 1; test: 1; GC: 678
  // Hence, the total initial quantum circuit input is approx 145000

  qbit T[R * n];
  qbit i[r];
  qbit v[n];
  qbit E[RR1];
  qbit w[n];
  qbit testTEdge[1];
  qbit test[1];
  qbit TEPhase[1];

  // now we declare with size 14. It should be sufficient for cases where n is
  // not greater than 15
  qbit ctrbit[14];
  qbit ctrbit2[14];

  /*******************************************************************
  * used for index matching
  * each element inside idxIJ (let say idxIJ[k]) is physically wired
  * close to the quNode T[k] such that when and index i is given,
  * we compare i and idxIJ[k] for k = 0 ... 511 until we find a match
  * Once match is found, we continue with the corresponding T[k] to
  * proceed with corresonding operation.
  * The initialization of this index, in physical implementation, is not
  * needed because we can just hardwire the NOT gates (to turn 0 to 1)
  * to let idxIJ[k] to represent the number k (in binary presentation).
  * However, in simulation, we need to do the initialization.
  ***********************************************************************/
  qbit idxIJ[R * r];

  // used for initializing idxIJ from 0 to 511
  int bin[r];

  // the quotient
  int quo = 0;

  // Graph Collision Register
  /*GCQWRegs GC;*/
  qbit tau[Rbar * r];
  qbit sigma[r];
  qbit iota[rbar];
  qbit Ew[Rbar];
  qbit cTri[2 * rbar - 1];
  // qubit holding test results for the triangle in T
  qbit triTestT[1];
  // qubit holding test results for the triangle in T and w
  qbit triTestTw[1];

  PrepZ(test[0], 0);
  PrepZ(testTEdge[0], 0);

  for (j = 0; j < R; j++) {
    for (l = 0; l < r; l++)
      bin[l] = 0;

    for (k = 0; k < n; k++) {
      INITIALIZE(T[j * n + k]);
    }

    /**************************************************************************
    * Initialize idxIJ[j]; this loop could have been merged with previous loop
    *  used for the binary presentation but for readability, we separate them.
    ***************************************************************************/
    for (l = 0; l < r; l++) {
      if ((j & (int)pow(2, l)) == 1)
        X(idxIJ[j * r + l]);
    }
  }

  for (j = 0; j < r; j++) {
    INITIALIZE(i[j]);
  }

  for (j = 0; j < n; j++) {
    INITIALIZE(v[j]);
  }

  for (j = 0; j < n; j++) {
    PrepZ(w[j], 0);
  }

  for (j = 0; j < Rbar; j++) {
    for (k = 0; k < r; k++) {
      PrepZ(tau[j * r + k], 0);
    }
  }

  for (j = 0; j < rbar; j++) {
    PrepZ(iota[j], 0);
  }

  for (j = 0; j < r; j++) {
    PrepZ(sigma[j], 0);
  }

  for (j = 0; j < Rbar; j++) {
    PrepZ(Ew[j], 0);
  }

  for (j = 0; j < 2 * rbar - 1; j++) {
    PrepZ(cTri[j], 0);
  }

  PrepZ(triTestT[0], 0);
  PrepZ(triTestTw[0], 0);

  // Set up E with the edget information for T
  SETUP(E, T);

  // To generate the (|0>-|1>)/sqrt(2) state for recording phase later
  X(TEPhase[0]);
  H(TEPhase[0]);

  // Quantum Walk on the Hamming Graph
  for (j = 0; j < tm; j++) {
    // Test T for triangle edges
    TestTriangleEdges(T, E, w, /*GC,*/ idxIJ, ctrbit2, ctrbit, tau, sigma, iota,
                      Ew, cTri, triTestT[0], triTestTw[0]);

    /***************************************************
    * Phase flip for TE
    * and undo the X operation during the EvaluateOR
    ***************************************************/
    EvaluateOR(TEPhase[0], triTestT[0], triTestTw[0]);
    X(triTestT[0]);
    X(triTestTw[0]);

    // TODO: Assume the inverse function will be present when provided the
    // original circuit
    InvTestTriangleEdges(T, E, w, /*GC,*/ idxIJ, ctrbit2, ctrbit, tau, sigma,
                         iota, Ew, cTri, triTestT[0], triTestTw[0]);

    // Quantum Walk on H(V,R)
    for (k = 0; k < tw; k++) {
      QWSH(T, i, v, E, idxIJ, ctrbit2, ctrbit);
    }
  }

  // Final Check for triangle edges in T
  TestTriangleEdges(T, E, w, /*GC,*/ idxIJ, ctrbit2, ctrbit, tau, sigma, iota,
                    Ew, cTri, triTestT[0], triTestTw[0]);

  // if triTestTw is 1, then testTMeasure should be set to 1
  // Because EvaluateOR applies X on the control bits and normally we need to
  // uncompute
  // But here we are close to the end of the program and we do not need
  // triTestT, triTestTw anymore.
  // Hence, we can skip the step of finding a dummy qubit to do InvEvaluateOR
  EvaluateOR(testTEdge[0], triTestT[0], triTestTw[0]);
  testTMeasure[0] = MeasX(testTEdge[0]);
}
