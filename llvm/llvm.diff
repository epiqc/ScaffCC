diff -Naur /data/project/xiangzhai/llvm-31/CMakeLists.txt llvm/CMakeLists.txt
--- /data/project/xiangzhai/llvm-31/CMakeLists.txt	2017-10-12 11:11:50.061432631 +0800
+++ llvm/CMakeLists.txt	2017-10-12 11:09:30.884117685 +0800
@@ -268,21 +268,11 @@
   "${LLVM_BINARY_DIR}/tools/llvm-config/LibraryDependencies.inc")
 set(LLVMBUILDCMAKEFRAG
   "${LLVM_BINARY_DIR}/LLVMBuild.cmake")
-
-# Create the list of optional components that are enabled
-if (LLVM_USE_INTEL_JITEVENTS)
-  set(LLVMOPTIONALCOMPONENTS IntelJITEvents)
-endif (LLVM_USE_INTEL_JITEVENTS)
-if (LLVM_USE_OPROFILE)
-  set(LLVMOPTIONALCOMPONENTS ${LLVMOPTIONALCOMPONENTS} OProfileJIT)
-endif (LLVM_USE_OPROFILE)
-
 message(STATUS "Constructing LLVMBuild project information")
 execute_process(
   COMMAND ${PYTHON_EXECUTABLE} ${LLVMBUILDTOOL}
             --native-target "${LLVM_NATIVE_ARCH}"
             --enable-targets "${LLVM_TARGETS_TO_BUILD}"
-            --enable-optional-components "${LLVMOPTIONALCOMPONENTS}"
             --write-library-table ${LLVMCONFIGLIBRARYDEPENDENCIESINC}
             --write-cmake-fragment ${LLVMBUILDCMAKEFRAG}
             ERROR_VARIABLE LLVMBUILDOUTPUT
diff -Naur /data/project/xiangzhai/llvm-31/docs/AliasAnalysis.html llvm/docs/AliasAnalysis.html
--- /data/project/xiangzhai/llvm-31/docs/AliasAnalysis.html	2017-10-12 11:11:50.073432755 +0800
+++ llvm/docs/AliasAnalysis.html	2017-10-12 11:09:30.895117786 +0800
@@ -1060,7 +1060,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-01-30 15:05:41 -0800 (Mon, 30 Jan 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/BitCodeFormat.html llvm/docs/BitCodeFormat.html
--- /data/project/xiangzhai/llvm-31/docs/BitCodeFormat.html	2017-10-12 11:11:50.074432765 +0800
+++ llvm/docs/BitCodeFormat.html	2017-10-12 11:09:30.895117786 +0800
@@ -1464,7 +1464,7 @@
  src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a>
  <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
 <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-Last modified: $Date$
+Last modified: $Date: 2011-04-22 17:30:22 -0700 (Fri, 22 Apr 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/Bugpoint.html llvm/docs/Bugpoint.html
--- /data/project/xiangzhai/llvm-31/docs/Bugpoint.html	2017-10-12 11:11:50.074432765 +0800
+++ llvm/docs/Bugpoint.html	2017-10-12 11:09:30.895117786 +0800
@@ -232,7 +232,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-31 04:21:59 -0700 (Mon, 31 Oct 2011) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/CodeGenerator.html llvm/docs/CodeGenerator.html
--- /data/project/xiangzhai/llvm-31/docs/CodeGenerator.html	2017-10-12 11:11:50.075432775 +0800
+++ llvm/docs/CodeGenerator.html	2017-10-12 11:09:30.896117795 +0800
@@ -3182,7 +3182,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-04-15 13:22:36 -0700 (Sun, 15 Apr 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/CodingStandards.html llvm/docs/CodingStandards.html
--- /data/project/xiangzhai/llvm-31/docs/CodingStandards.html	2017-10-12 11:11:50.075432775 +0800
+++ llvm/docs/CodingStandards.html	2017-10-12 11:09:30.896117795 +0800
@@ -1561,7 +1561,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-03-27 04:25:16 -0700 (Tue, 27 Mar 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/CommandGuide/index.html llvm/docs/CommandGuide/index.html
--- /data/project/xiangzhai/llvm-31/docs/CommandGuide/index.html	2017-10-12 11:11:50.075432775 +0800
+++ llvm/docs/CommandGuide/index.html	2017-10-12 11:09:30.897117804 +0800
@@ -135,7 +135,7 @@
   src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a>
 
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-02-26 00:35:53 -0800 (Sun, 26 Feb 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/CommandLine.html llvm/docs/CommandLine.html
--- /data/project/xiangzhai/llvm-31/docs/CommandLine.html	2017-10-12 11:11:50.077432796 +0800
+++ llvm/docs/CommandLine.html	2017-10-12 11:09:30.898117814 +0800
@@ -1969,7 +1969,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-04-22 17:30:22 -0700 (Fri, 22 Apr 2011) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/CompilerWriterInfo.html llvm/docs/CompilerWriterInfo.html
--- /data/project/xiangzhai/llvm-31/docs/CompilerWriterInfo.html	2017-10-12 11:11:50.077432796 +0800
+++ llvm/docs/CompilerWriterInfo.html	2017-10-12 11:09:30.898117814 +0800
@@ -260,7 +260,7 @@
 
   <a href="http://misha.brukman.net">Misha Brukman</a><br>
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-27 15:56:32 -0700 (Thu, 27 Oct 2011) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/DebuggingJITedCode.html llvm/docs/DebuggingJITedCode.html
--- /data/project/xiangzhai/llvm-31/docs/DebuggingJITedCode.html	2017-10-12 11:11:50.077432796 +0800
+++ llvm/docs/DebuggingJITedCode.html	2017-10-12 11:09:30.898117814 +0800
@@ -178,7 +178,7 @@
   <a href="mailto:reid.kleckner@gmail.com">Reid Kleckner</a>,
   <a href="mailto:eliben@gmail.com">Eli Bendersky</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-05-01 00:58:54 -0700 (Tue, 01 May 2012) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/DeveloperPolicy.html llvm/docs/DeveloperPolicy.html
--- /data/project/xiangzhai/llvm-31/docs/DeveloperPolicy.html	2017-10-12 11:11:50.077432796 +0800
+++ llvm/docs/DeveloperPolicy.html	2017-10-12 11:09:30.899117823 +0800
@@ -636,7 +636,7 @@
   Written by the 
   <a href="mailto:llvm-oversight@cs.uiuc.edu">LLVM Oversight Group</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-03-27 04:25:16 -0700 (Tue, 27 Mar 2012) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/ExceptionHandling.html llvm/docs/ExceptionHandling.html
--- /data/project/xiangzhai/llvm-31/docs/ExceptionHandling.html	2017-10-12 11:11:50.078432806 +0800
+++ llvm/docs/ExceptionHandling.html	2017-10-12 11:09:30.899117823 +0800
@@ -556,7 +556,7 @@
   src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a>
 
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-03-27 04:25:16 -0700 (Tue, 27 Mar 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/ExtendingLLVM.html llvm/docs/ExtendingLLVM.html
--- /data/project/xiangzhai/llvm-31/docs/ExtendingLLVM.html	2017-10-12 11:11:50.078432806 +0800
+++ llvm/docs/ExtendingLLVM.html	2017-10-12 11:09:30.899117823 +0800
@@ -372,7 +372,7 @@
 
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a>
   <br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-03-22 22:50:46 -0700 (Thu, 22 Mar 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/FAQ.html llvm/docs/FAQ.html
--- /data/project/xiangzhai/llvm-31/docs/FAQ.html	2017-10-12 11:11:50.078432806 +0800
+++ llvm/docs/FAQ.html	2017-10-12 11:09:30.899117823 +0800
@@ -941,7 +941,7 @@
   src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a>
 
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-03-27 04:25:16 -0700 (Tue, 27 Mar 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/GarbageCollection.html llvm/docs/GarbageCollection.html
--- /data/project/xiangzhai/llvm-31/docs/GarbageCollection.html	2017-10-12 11:11:50.078432806 +0800
+++ llvm/docs/GarbageCollection.html	2017-10-12 11:09:30.899117823 +0800
@@ -1382,7 +1382,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-03-02 20:32:33 -0800 (Fri, 02 Mar 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/GCCFEBuildInstrs.html llvm/docs/GCCFEBuildInstrs.html
--- /data/project/xiangzhai/llvm-31/docs/GCCFEBuildInstrs.html	2017-10-12 11:11:50.078432806 +0800
+++ llvm/docs/GCCFEBuildInstrs.html	2017-10-12 11:09:30.899117823 +0800
@@ -272,7 +272,7 @@
   src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a>
 
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-04-22 17:30:22 -0700 (Fri, 22 Apr 2011) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/GetElementPtr.html llvm/docs/GetElementPtr.html
--- /data/project/xiangzhai/llvm-31/docs/GetElementPtr.html	2017-10-12 11:11:50.078432806 +0800
+++ llvm/docs/GetElementPtr.html	2017-10-12 11:09:30.900117832 +0800
@@ -747,7 +747,7 @@
   <a href="http://validator.w3.org/check/referer"><img
   src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-31 06:04:26 -0700 (Mon, 31 Oct 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/GettingStarted.html llvm/docs/GettingStarted.html
--- /data/project/xiangzhai/llvm-31/docs/GettingStarted.html	2017-10-12 11:11:50.079432816 +0800
+++ llvm/docs/GettingStarted.html	2017-10-12 11:09:30.900117832 +0800
@@ -1757,7 +1757,7 @@
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.x10sys.com/rspencer/">Reid Spencer</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-03-27 04:25:16 -0700 (Tue, 27 Mar 2012) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/GettingStartedVS.html llvm/docs/GettingStartedVS.html
--- /data/project/xiangzhai/llvm-31/docs/GettingStartedVS.html	2017-10-12 11:11:50.079432816 +0800
+++ llvm/docs/GettingStartedVS.html	2017-10-12 11:09:30.900117832 +0800
@@ -362,7 +362,7 @@
   src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a>
 
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-01-25 14:00:23 -0800 (Wed, 25 Jan 2012) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/HowToReleaseLLVM.html llvm/docs/HowToReleaseLLVM.html
--- /data/project/xiangzhai/llvm-31/docs/HowToReleaseLLVM.html	2017-10-12 11:11:50.079432816 +0800
+++ llvm/docs/HowToReleaseLLVM.html	2017-10-12 11:09:30.902117850 +0800
@@ -575,7 +575,7 @@
   src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a>
   <br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-31 04:21:59 -0700 (Mon, 31 Oct 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/HowToSubmitABug.html llvm/docs/HowToSubmitABug.html
--- /data/project/xiangzhai/llvm-31/docs/HowToSubmitABug.html	2017-10-12 11:11:50.079432816 +0800
+++ llvm/docs/HowToSubmitABug.html	2017-10-12 11:09:30.902117850 +0800
@@ -341,7 +341,7 @@
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a>
   <br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-31 04:21:59 -0700 (Mon, 31 Oct 2011) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/index.html llvm/docs/index.html
--- /data/project/xiangzhai/llvm-31/docs/index.html	2017-10-12 11:11:50.086432888 +0800
+++ llvm/docs/index.html	2017-10-12 11:09:30.908117905 +0800
@@ -281,6 +281,6 @@
   src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a>
 
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-02-26 14:26:37 -0800 (Sun, 26 Feb 2012) $
 </address>
 </body></html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/LangRef.html llvm/docs/LangRef.html
--- /data/project/xiangzhai/llvm-31/docs/LangRef.html	2017-10-12 11:11:50.081432837 +0800
+++ llvm/docs/LangRef.html	2017-10-12 11:09:30.903117859 +0800
@@ -8505,7 +8505,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-04-16 12:39:33 -0700 (Mon, 16 Apr 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/Lexicon.html llvm/docs/Lexicon.html
--- /data/project/xiangzhai/llvm-31/docs/Lexicon.html	2017-10-12 11:11:50.081432837 +0800
+++ llvm/docs/Lexicon.html	2017-10-12 11:09:30.903117859 +0800
@@ -284,7 +284,7 @@
  src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a><a
  href="http://llvm.org/">The LLVM Team</a><br>
 <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-Last modified: $Date$
+Last modified: $Date: 2012-01-05 00:18:41 -0800 (Thu, 05 Jan 2012) $
 </address>
 <!-- vim: sw=2
 -->
diff -Naur /data/project/xiangzhai/llvm-31/docs/LinkTimeOptimization.html llvm/docs/LinkTimeOptimization.html
--- /data/project/xiangzhai/llvm-31/docs/LinkTimeOptimization.html	2017-10-12 11:11:50.081432837 +0800
+++ llvm/docs/LinkTimeOptimization.html	2017-10-12 11:09:30.903117859 +0800
@@ -393,7 +393,7 @@
 
   Devang Patel and Nick Kledzik<br>
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-31 04:21:59 -0700 (Mon, 31 Oct 2011) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/LLVMBuild.html llvm/docs/LLVMBuild.html
--- /data/project/xiangzhai/llvm-31/docs/LLVMBuild.html	2017-10-12 11:11:50.079432816 +0800
+++ llvm/docs/LLVMBuild.html	2017-10-12 11:09:30.902117850 +0800
@@ -272,11 +272,6 @@
           components. For example, the <i>X86</i> target might define a library
           group for all of the <i>X86</i> components. That library group might
           then be included in the <i>all-targets</i> library group.</p></li>
-
-        <li><i>installed</i> <b>[optional]</b> <b>[boolean]</b>
-          <p>Whether this library is installed. Libraries that are not installed
-          are only reported by <tt>llvm-config</tt> when it is run as part of a
-          development directory.</p></li>
       </ul>
     </li>
 
diff -Naur /data/project/xiangzhai/llvm-31/docs/MakefileGuide.html llvm/docs/MakefileGuide.html
--- /data/project/xiangzhai/llvm-31/docs/MakefileGuide.html	2017-10-12 11:11:50.081432837 +0800
+++ llvm/docs/MakefileGuide.html	2017-10-12 11:09:30.904117868 +0800
@@ -1033,7 +1033,7 @@
 
   <a href="mailto:rspencer@x10sys.com">Reid Spencer</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-04-22 17:30:22 -0700 (Fri, 22 Apr 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/Packaging.html llvm/docs/Packaging.html
--- /data/project/xiangzhai/llvm-31/docs/Packaging.html	2017-10-12 11:11:50.081432837 +0800
+++ llvm/docs/Packaging.html	2017-10-12 11:09:30.904117868 +0800
@@ -113,7 +113,7 @@
   <a href="http://validator.w3.org/check/referer"><img
   src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-31 04:21:59 -0700 (Mon, 31 Oct 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/Passes.html llvm/docs/Passes.html
--- /data/project/xiangzhai/llvm-31/docs/Passes.html	2017-10-12 11:11:50.082432847 +0800
+++ llvm/docs/Passes.html	2017-10-12 11:09:30.904117868 +0800
@@ -2060,7 +2060,7 @@
 
   <a href="mailto:rspencer@x10sys.com">Reid Spencer</a><br>
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-01-31 19:51:43 -0800 (Tue, 31 Jan 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/ProgrammersManual.html llvm/docs/ProgrammersManual.html
--- /data/project/xiangzhai/llvm-31/docs/ProgrammersManual.html	2017-10-12 11:11:50.082432847 +0800
+++ llvm/docs/ProgrammersManual.html	2017-10-12 11:09:30.905117878 +0800
@@ -4128,7 +4128,7 @@
   <a href="mailto:dhurjati@cs.uiuc.edu">Dinakar Dhurjati</a> and
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-04-18 13:28:55 -0700 (Wed, 18 Apr 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/Projects.html llvm/docs/Projects.html
--- /data/project/xiangzhai/llvm-31/docs/Projects.html	2017-10-12 11:11:50.082432847 +0800
+++ llvm/docs/Projects.html	2017-10-12 11:09:30.905117878 +0800
@@ -482,7 +482,7 @@
   <a href="mailto:criswell@uiuc.edu">John Criswell</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a>
   <br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-31 04:21:59 -0700 (Mon, 31 Oct 2011) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/ReleaseNotes.html llvm/docs/ReleaseNotes.html
--- /data/project/xiangzhai/llvm-31/docs/ReleaseNotes.html	2017-10-12 11:11:50.083432857 +0800
+++ llvm/docs/ReleaseNotes.html	2017-10-12 11:09:30.905117878 +0800
@@ -29,6 +29,12 @@
   <p>Written by the <a href="http://llvm.org/">LLVM Team</a></p>
 </div>
 
+<h1 style="color:red">These are in-progress notes for the upcoming LLVM 3.1
+release.<br>
+You may prefer the
+<a href="http://llvm.org/releases/3.0/docs/ReleaseNotes.html">LLVM 3.0
+Release Notes</a>.</h1>
+
 <!-- *********************************************************************** -->
 <h2>
   <a name="intro">Introduction</a>
@@ -68,9 +74,9 @@
 
 <p>The LLVM 3.1 distribution currently consists of code from the core LLVM
    repository (which roughly includes the LLVM optimizers, code generators and
-   supporting tools), and the Clang repository. In addition to this code, the
-   LLVM Project includes other sub-projects that are in development.  Here we
-   include updates on these subprojects.</p>
+   supporting tools), and the Clang repository.  In
+   addition to this code, the LLVM Project includes other sub-projects that are
+   in development.  Here we include updates on these subprojects.</p>
 
 <!--=========================================================================-->
 <h3>
@@ -88,22 +94,16 @@
    production-quality compiler for C, Objective-C, C++ and Objective-C++ on x86
    (32- and 64-bit), and for Darwin/ARM targets.</p>
 
-<p>In the LLVM 3.1 time-frame, the Clang team has made many improvements.
-   Highlights include:</p>
+<p>In the LLVM 3.1 time-frame, the Clang team has made many improvements:</p>
 <ul>
-  <li>Greatly expanded <a href="http://clang.llvm.org/cxx_status.html">C++11
-      support</a> including lambdas, initializer lists, constexpr, user-defined
-      literals, and atomics.</li>
-  <li>A new <a href="http://clang.llvm.org/docs/Tooling.html">tooling</a>
-      library to ease building of clang-based standalone tools.</li>
-  <li>Extended support for
-      <a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html">literals in
-      Objective C</a>.</li>
-</ul>
-
-<p>For more details about the changes to Clang since the 3.0 release, see the
-   <a href="http://clang.llvm.org/docs/ReleaseNotes.html">Clang release
-   notes.</a></p>
+  <li>C++11 support is greatly expanded including lambdas, initializer lists, constexpr, user-defined literals, and atomics.</li>
+  <li>...</li>
+</ul>
+
+  <p>For more details about the changes to Clang since the 2.9 release, see the
+<a href="http://clang.llvm.org/docs/ReleaseNotes.html">Clang release notes</a>
+</p>
+
 
 <p>If Clang rejects your code but another compiler accepts it, please take a
    look at the <a href="http://clang.llvm.org/compatibility.html">language
@@ -118,7 +118,6 @@
 </h3>
 
 <div>
-
 <p><a href="http://dragonegg.llvm.org/">DragonEgg</a> is a
    <a href="http://gcc.gnu.org/wiki/plugins">gcc plugin</a> that replaces GCC's
    optimizers and code generators with LLVM's. It works with gcc-4.5 and gcc-4.6
@@ -129,7 +128,8 @@
 
 <p>The 3.1 release has the following notable changes:</p>
 
-<ul>
+  <ul>
+
   <li>Partial support for gcc-4.7. Ada support is poor, but other languages work
       fairly well.</li>
 
@@ -144,6 +144,7 @@
       aliasing and type ranges to the LLVM optimizers.</li>
 
   <li>A regression test-suite was added.</li>
+
 </ul>
 
 </div>
@@ -164,9 +165,7 @@
    implementations of this and other low-level routines (some are 3x faster than
    the equivalent libgcc routines).</p>
 
-<p>As of 3.1, compiler-rt includes the helper functions for atomic operations,
-   allowing atomic operations on arbitrary-sized quantities to work.  These
-   functions follow the specification defined by gcc and are used by clang.</p>
+<p>....</p>
 
 </div>
 
@@ -177,11 +176,12 @@
 
 <div>
 
-<p><a href="http://lldb.llvm.org">LLDB</a> is a ground-up implementation of a
-   command line debugger, as well as a debugger API that can be used from other
-   applications.  LLDB makes use of the Clang parser to provide high-fidelity
-   expression parsing (particularly for C++) and uses the LLVM JIT for target
-   support.</p>
+<p>LLDB is a ground-up implementation of a command line debugger, as well as a
+   debugger API that can be used from other applications.  LLDB makes use of the
+   Clang parser to provide high-fidelity expression parsing (particularly for
+   C++) and uses the LLVM JIT for target support.</p>
+
+<p>...</p>
 
 </div>
 
@@ -196,16 +196,7 @@
    licensed</a> under the MIT and UIUC license, allowing it to be used more
    permissively.</p>
 
-<p>Within the LLVM 3.1 time-frame there were the following highlights:</p>
-
-<ul>
-  <li>The <code>&lt;atomic&gt;</code> header is now passing all tests, when
-      compiling with clang and linking against the support code from
-      compiler-rt.</li>
-  <li>FreeBSD now includes libc++ as part of the base system.</li>
-  <li>libc++ has been ported to Solaris and, in combination with libcxxrt and
-      clang, is working with a large body of existing code.</li>
-</ul>
+<p>...</p>
 
 </div>
 
@@ -216,12 +207,16 @@
 
 <div>
 
-<p>The <a href="http://vmkit.llvm.org/">VMKit project</a> is an implementation
-  of a Java Virtual Machine (Java VM or JVM) that uses LLVM for static and
-  just-in-time compilation.</p>
-
-<p>In the LLVM 3.1 time-frame, VMKit has had significant improvements on both
-   runtime and startup performance.</p>
+  <p>The <a href="http://vmkit.llvm.org/">VMKit project</a> is an
+  implementation of a Java Virtual Machine (Java VM or JVM) that uses LLVM for
+  static and just-in-time compilation.
+
+  <p>In the LLVM 3.1 time-frame, VMKit has had significant improvements on both
+  runtime and startup performance:</p>
+
+  <ul>
+  <li>...</li>
+  </ul>
 
 </div>
 
@@ -233,23 +228,25 @@
 
 <div>
 
-<p><a href="http://polly.llvm.org/">Polly</a> is an <em>experimental</em>
+  <p><a href="http://polly.llvm.org/">Polly</a> is an <em>experimental</em>
   optimizer for data locality and parallelism. It currently provides high-level
   loop optimizations and automatic parallelisation (using the OpenMP run time).
   Work in the area of automatic SIMD and accelerator code generation was
-  started.</p>
+  started.
 
-<p>Within the LLVM 3.1 time-frame there were the following highlights:</p>
+  <p>Within the LLVM 3.1 time-frame there were the following highlights:</p>
 
-<ul>
+  <ul>
   <li>Polly became an official LLVM project</li>
-  <li>Polly can be loaded directly into clang (enabled by '-O3 -mllvm -polly')</li>
-  <li>An automatic scheduling optimizer (derived
-      from <a href="http://pluto-compiler.sourceforge.net/">Pluto</a>) was
-      integrated. It performs loop transformations to optimize for data-locality
-      and parallelism.  The transformations include, but are not limited to
-      interchange, fusion, fission, skewing and tiling.</li>
-</ul>
+  <li>Polly can be loaded directly into clang (Enabled by '-O3 -mllvm -polly'
+  )</li>
+  <li>An automatic scheduling optimizer (derived from <a
+  href="http://pluto-compiler.sourceforge.net/">Pluto</a>) was integrated. It
+  performs loop transformations to optimize for data-locality and parallelism.
+  The transformations include, but are not limited to interchange, fusion,
+  fission, skewing and tiling.
+  </li>
+  </ul>
 
 </div>
 
@@ -267,143 +264,21 @@
    a lot of other language and tools projects.  This section lists some of the
    projects that have already been updated to work with LLVM 3.1.</p>
 
-<h3>Crack</h3>
-
-<div>
-
-<p><a href="http://code.google.com/p/crack-language/">Crack</a> aims to provide
-   the ease of development of a scripting language with the performance of a
-   compiled language. The language derives concepts from C++, Java and Python,
-   incorporating object-oriented programming, operator overloading and strong
-   typing.</p>
-
-</div>
-
-<h3>FAUST</h3>
-
-<div>
-
-<p><a href="http://faust.grame.fr/">FAUST</a> is a compiled language for
-   real-time audio signal processing. The name FAUST stands for Functional
-   AUdio STream. Its programming model combines two approaches: functional
-   programming and block diagram composition. In addition with the C, C++, Java,
-   JavaScript output formats, the Faust compiler can generate LLVM bitcode, and
-   works with LLVM 2.7-3.1.</p>
-
-</div>
-
-<h3>Glasgow Haskell Compiler (GHC)</h3>
-
-<div>
-
-<p><a href="http://www.haskell.org/ghc/">GHC</a> is an open source compiler and
-   programming suite for Haskell, a lazy functional programming language. It
-   includes an optimizing static compiler generating good code for a variety of
-   platforms, together with an interactive system for convenient, quick
-   development.</p>
-
-<p>GHC 7.0 and onwards include an LLVM code generator, supporting LLVM 2.8 and
-   later.</p>
-
-</div>
-
-<h3>Julia</h3>
-
-<div>
-
-<p><a href="https://github.com/JuliaLang/julia">Julia</a> is a high-level,
-   high-performance dynamic language for technical computing. It provides a
-   sophisticated compiler, distributed parallel execution, numerical accuracy,
-   and an extensive mathematical function library. The compiler uses type
-   inference to generate fast code without any type declarations, and uses
-   LLVM's optimization passes and JIT compiler. The
-   <a href="http://julialang.org/"> Julia Language</a> is designed
-   around multiple dispatch, giving programs a large degree of flexibility. It
-   is ready for use on many kinds of problems.</p>
-
-</div>
-
-<h3>LLVM D Compiler</h3>
-
-<div>
-
-<p><a href="https://github.com/ldc-developers/ldc">LLVM D Compiler</a> (LDC) is
-   a compiler for the D programming Language. It is based on the DMD frontend
-   and uses LLVM as backend.</p>
-
-</div>
-
-<h3>Open Shading Language</h3>
-
-<div>
-
-<p><a href="https://github.com/imageworks/OpenShadingLanguage/">Open Shading
-   Language (OSL)</a> is a small but rich language for programmable shading in
-   advanced global illumination renderers and other applications, ideal for
-   describing materials, lights, displacement, and pattern generation. It uses
-   LLVM to JIT complex shader networks to x86 code at runtime.</p>
-
-<p>OSL was developed by Sony Pictures Imageworks for use in its in-house
-   renderer used for feature film animation and visual effects, and is
-   distributed as open source software with the "New BSD" license.</p>
-
-</div>
-
-<h3>Portable OpenCL (pocl)</h3>
-
-<div>
-
-<p>In addition to producing an easily portable open source OpenCL
-   implementation, another major goal of <a href="http://pocl.sourceforge.net/">
-   pocl</a> is improving performance portability of OpenCL programs with
-   compiler optimizations, reducing the need for target-dependent manual
-   optimizations. An important part of pocl is a set of LLVM passes used to
-   statically parallelize multiple work-items with the kernel compiler, even in
-   the presence of work-group barriers. This enables static parallelization of
-   the fine-grained static concurrency in the work groups in multiple ways
-   (SIMD, VLIW, superscalar,...).</p>
-
-</div>
-
 <h3>Pure</h3>
 
-<div>
-
-<p><a href="http://pure-lang.googlecode.com/">Pure</a> is an
-   algebraic/functional programming language based on term rewriting. Programs
-   are collections of equations which are used to evaluate expressions in a
-   symbolic fashion. The interpreter uses LLVM as a backend to JIT-compile Pure
-   programs to fast native code. Pure offers dynamic typing, eager and lazy
-   evaluation, lexical closures, a hygienic macro system (also based on term
-   rewriting), built-in list and matrix support (including list and matrix
-   comprehensions) and an easy-to-use interface to C and other programming
-   languages (including the ability to load LLVM bitcode modules, and inline C,
-   C++, Fortran and Faust code in Pure programs if the corresponding
-   LLVM-enabled compilers are installed).</p>
+<p>Pure (http://pure-lang.googlecode.com/) is an algebraic/functional
+programming language based on term rewriting. Programs are collections of
+equations which are used to evaluate expressions in a symbolic fashion. The
+interpreter uses LLVM as a backend to JIT-compile Pure programs to fast native
+code. Pure offers dynamic typing, eager and lazy evaluation, lexical closures, a
+hygienic macro system (also based on term rewriting), built-in list and matrix
+support (including list and matrix comprehensions) and an easy-to-use interface
+to C and other programming languages (including the ability to load LLVM bitcode
+modules, and inline C, C++, Fortran and Faust code in Pure programs if the
+corresponding LLVM-enabled compilers are installed).</p>
 
 <p>Pure version 0.54 has been tested and is known to work with LLVM 3.1 (and
-   continues to work with older LLVM releases >= 2.5).</p>
-
-</div>
-
-<h3>TTA-based Co-design Environment (TCE)</h3>
-
-<div>
-
-<p><a href="http://tce.cs.tut.fi/">TCE</a> is a toolset for designing
-   application-specific processors (ASP) based on the Transport triggered
-   architecture (TTA). The toolset provides a complete co-design flow from C/C++
-   programs down to synthesizable VHDL/Verilog and parallel program binaries.
-   Processor customization points include the register files, function units,
-   supported operations, and the interconnection network.</p>
-
-<p>TCE uses Clang and LLVM for C/C++ language support, target independent
-   optimizations and also for parts of code generation. It generates new
-   LLVM-based code generators "on the fly" for the designed TTA processors and
-   loads them in to the compiler backend as runtime libraries to avoid
-   per-target recompilation of larger parts of the compiler chain.</p>
-
-</div>
+continues to work with older LLVM releases >= 2.5).</p>
 
 </div>
 
@@ -454,6 +329,7 @@
       A full featured assembler and direct-to-object support for ARM.</li>
   <li><a href="#blockplacement">Basic Block Placement</a>
       Probability driven basic block placement.</li>
+  <li>....</li>
 </ul>
 
 </div>
@@ -469,22 +345,18 @@
 <p>LLVM IR has several new features for better support of new targets and that
    expose new optimization opportunities:</p>
 
-<ul>
-  <li>A new type representing 16 bit <i>half</i> floating point values has
-      been added.</li>
-  <li>IR now supports vectors of pointers, including vector GEPs.</li>
-  <li>Module flags have been introduced. They convey information about the
-      module as a whole to LLVM subsystems. This is currently used to encode
-      Objective C ABI information.</li>
-  <li>Loads can now have range metadata attached to them to describe the
-      possible values being loaded.</li>
-  <li>The <tt>llvm.ctlz</tt> and <tt>llvm.cttz</tt> intrinsics now have an
-    additional argument which indicates whether the behavior of the intrinsic
-    is undefined on a zero input. This can be used to generate more efficient
-    code on platforms that only have instructions which don't return the type
-    size when counting bits in 0.</li>
-</ul>
-
+  <ul>
+    <li>IR support for half float</li>
+    <li>IR support for vectors of pointers, including vector GEPs.</li>
+    <li>Module flags have been introduced. They convey information about the
+        module as a whole to LLVM subsystems.</li>
+    <li>Loads can now have range metadata attached to them to describe the
+        possible values being loaded.</li>
+    <li>Inline cost heuristics have been completely overhauled and now closely
+        model constant propagation through call sites, disregard trivially dead
+        code costs, and can model C++ STL iterator patterns.</li>
+    <li>....</li>
+  </ul>
 </div>
 
 <!--=========================================================================-->
@@ -507,9 +379,7 @@
       post-vectorization cleanup passes. For more information, see the EuroLLVM
       2012 slides: <a href="http://llvm.org/devmtg/2012-04-12/Slides/Hal_Finkel.pdf">
       Autovectorization with LLVM</a>.</li>
-  <li>Inline cost heuristics have been completely overhauled and now closely
-      model constant propagation through call sites, disregard trivially dead
-      code costs, and can model C++ STL iterator patterns.</li>
+  <li>....</li>
 </ul>
 
 </div>
@@ -529,9 +399,7 @@
     to the LLVM MC Project Blog Post</a>.</p>
 
 <ul>
-  <li>The integrated assembler can optionally emit debug information when
-      assembling a </tt>.s</tt> file. It can be enabled by passing the
-      <tt>-g</tt> option to <tt>llvm-mc</tt>.</li>
+  <li>....</li>
 </ul>
 
 </div>
@@ -568,9 +436,6 @@
       representation of large clobber lists on call instructions.  The register
       mask operand references a bit mask of preserved registers. Everything else
       is clobbered.</li>
-  <li>The DWARF debug info writer gained support for emitting data for the
-      <a href="SourceLevelDebugging.html#acceltable">name accelerator tables
-      DWARF extension</a>. It is used by LLDB to speed up name lookup.</li>
 </ul>
 
 <p> We added new TableGen infrastructure to support bundling for
@@ -604,14 +469,13 @@
 <p>New features and major changes in the X86 target include:</p>
 
 <ul>
-  <li>Greatly improved support for AVX2.</li>
-  <li>Lots of bug fixes and improvements for AVX1.</li>
-  <li>Support for the FMA4 and XOP instruction set extensions.</li>
+  <li>Bug fixes and improved support for AVX1</li>
+  <li>Support for AVX2 (still incomplete at this point)</li>
   <li>Call instructions use the new register mask operands for faster compile
   times and better support for different calling conventions.  The old WINCALL
   instructions are no longer needed.</li>
   <li>DW2 Exception Handling is enabled on Cygwin and MinGW.</li>
-  <li>Support for implicit TLS model used with MSVC runtime.</li>
+  <li>Support for implicit TLS model used with MS VC runtime</li>
 </ul>
 
 </div>
@@ -656,47 +520,28 @@
 </h3>
 
 <div>
-New features and major changes in the MIPS target include:</p>
+
+<p>This release has seen major new work on just about every aspect of the MIPS
+  backend.  Some of the major new features include:</p>
 
 <ul>
-  <li>MIPS32 little-endian direct object code emission is functional.</li>
-  <li>MIPS64 little-endian code generation is largely functional for N64 ABI in assembly printing mode with the exception of handling of long double (f128) type.</li>
-  <li>Support for new instructions has been added, which includes swap-bytes
-   instructions (WSBH and DSBH), floating point multiply-add/subtract and
-   negative multiply-add/subtract instructions, and floating
-   point load/store instructions with reg+reg addressing (LWXC1, etc.)</li>
-  <li>Various fixes to improve performance have been implemented.</li>
-  <li>Post-RA scheduling is now enabled at -O3.</li>
-  <li>Support for soft-float code generation has been added.</li>
-  <li>clang driver's support for MIPS 64-bits targets.</li>
-  <li>Support for MIPS floating point ABI option in clang driver.</li>
+  <li>....</li>
 </ul>
 </div>
 
 <!--=========================================================================-->
 <h3>
-<a name="PTX">PTX Target Improvements</a>
+<a name="OtherTS">Other Target Specific Improvements</a>
 </h3>
 
 <div>
 
-<p>An outstanding conditional inversion bug was fixed in this release.</p>
-
-<p><b>NOTE</b>: LLVM 3.1 marks the last release of the PTX back-end, in its
-  current form. The back-end is currently being replaced by the NVPTX
-  back-end, currently in SVN ToT.</p>
-
-</div>
+<p>Support for Qualcomm's Hexagon VLIW processor has been added.</p>
 
-<!--=========================================================================-->
-<h3>
-<a name="OtherTS">Other Target Specific Improvements</a>
-</h3>
+<ul>
+  <li>....</li>
 
-<div>
 
-<ul>
-  <li>Support for Qualcomm's Hexagon VLIW processor has been added.</li>
 </ul>
 
 </div>
@@ -713,12 +558,6 @@
    from the previous release.</p>
 
 <ul>
-  <li>LLVM's build system now requires a python 2 interpreter to be present at
-      build time. A perl interpreter is no longer required.</li>
-  <li>The C backend has been removed.  It had numerous problems, to the point of
-      not being able to compile any nontrivial program.</li>
-  <li>The Alpha, Blackfin and SystemZ targets have been removed due to lack of
-      maintenance.</li>
   <li>LLVM 3.1 removes support for reading LLVM 2.9 bitcode files. Going
       forward, we aim for all future versions of LLVM to read bitcode files and
       <tt>.ll</tt> files produced by LLVM 3.0 and later.</li>
@@ -728,6 +567,7 @@
   <li>LLVM 3.0 and earlier automatically added the returns_twice fo functions
       like setjmp based on the name. This functionality was removed in 3.1.
       This affects Clang users, if -ffreestanding is used.</li>
+  <li>....</li>
 </ul>
 
 </div>
@@ -774,9 +614,9 @@
 <li><code>llvm::getTrapFunctionName()</code></li>
 <li><code>llvm::EnableSegmentedStacks</code></li>
 </ul></li>
-
-  <li>The <code>MDBuilder</code> class has been added to simplify the creation
-      of metadata.</li>
+  <li>The MDBuilder class has been added to simplify the creation of
+      metadata.</li>
+  <li>....</li>
 </ul>
 
 </div>
@@ -793,37 +633,16 @@
 
 
 <ul>
-  <li><tt>llvm-stress</tt> is a command line tool for generating random
-      <tt>.ll</tt> files to fuzz different LLVM components. </li>
-  <li>The <tt>llvm-ld</tt> tool has been removed.  The clang driver provides a
-      more reliable solution for turning a set of bitcode files into a binary.
-      To merge bitcode files <tt>llvm-link</tt> can be used instead.</li>
+  <li>llvm-stress is a command line tool for generating random .ll files to fuzz
+      different LLVM components. </li>
+  <li>llvm-ld has been removed.  Use llvm-link or Clang instead.</li>
+  <li>....</li>
 </ul>
 
-</div>
-
-
-<!--=========================================================================-->
-<h3>
-<a name="python">Python Bindings</a>
-</h3>
-
-<div>
-
-<p>Officially supported Python bindings have been added! Feature support is far
-from complete. The current bindings support interfaces to:</p>
 <ul>
-  <li>Object File Interface</li>
-  <li>Disassembler</li>
+  <li>....</li>
 </ul>
 
-<p>Using the Object File Interface, it is possible to inspect binary object files.
-Think of it as a Python version of readelf or llvm-objdump.</p>
-
-<p>Support for additional features is currently being developed by community
-contributors. If you are interested in shaping the direction of the Python
-bindings, please express your intent on IRC or the developers list.</p>
-
 </div>
 
 </div>
@@ -848,13 +667,18 @@
   <p>Known problem areas include:</p>
 
 <ul>
-  <li>The CellSPU, MSP430, PTX and XCore backends are experimental.</li>
+  <li>The Alpha, Blackfin, CellSPU, MSP430, PTX, SystemZ and
+      XCore backends are experimental, and the Alpha, Blackfin and SystemZ
+      targets have already been removed from mainline.</li>
 
   <li>The integrated assembler, disassembler, and JIT is not supported by
       several targets.  If an integrated assembler is not supported, then a
       system assembler is required.  For more details, see the <a
       href="CodeGenerator.html#targetfeatures">Target Features Matrix</a>.
   </li>
+
+  <li>The C backend has numerous problems and is not being actively maintained.
+    Depending on it for anything serious is not advised.</li>
 </ul>
 
 </div>
@@ -890,7 +714,7 @@
   src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a>
 
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-05-13 03:04:01 -0700 (Sun, 13 May 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/SourceLevelDebugging.html llvm/docs/SourceLevelDebugging.html
--- /data/project/xiangzhai/llvm-31/docs/SourceLevelDebugging.html	2017-10-12 11:11:50.083432857 +0800
+++ llvm/docs/SourceLevelDebugging.html	2017-10-12 11:09:30.906117887 +0800
@@ -2855,7 +2855,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-04-02 17:43:49 -0700 (Mon, 02 Apr 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/SystemLibrary.html llvm/docs/SystemLibrary.html
--- /data/project/xiangzhai/llvm-31/docs/SystemLibrary.html	2017-10-12 11:11:50.083432857 +0800
+++ llvm/docs/SystemLibrary.html	2017-10-12 11:09:30.906117887 +0800
@@ -310,7 +310,7 @@
 
   <a href="mailto:rspencer@x10sys.com">Reid Spencer</a><br>
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-31 04:21:59 -0700 (Mon, 31 Oct 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/TableGenFundamentals.html llvm/docs/TableGenFundamentals.html
--- /data/project/xiangzhai/llvm-31/docs/TableGenFundamentals.html	2017-10-12 11:11:50.084432868 +0800
+++ llvm/docs/TableGenFundamentals.html	2017-10-12 11:09:30.906117887 +0800
@@ -966,7 +966,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-03-27 04:25:16 -0700 (Tue, 27 Mar 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/TestingGuide.html llvm/docs/TestingGuide.html
--- /data/project/xiangzhai/llvm-31/docs/TestingGuide.html	2017-10-12 11:11:50.084432868 +0800
+++ llvm/docs/TestingGuide.html	2017-10-12 11:09:30.906117887 +0800
@@ -900,7 +900,7 @@
 
   John T. Criswell, Daniel Dunbar, Reid Spencer, and Tanya Lattner<br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-04-18 01:02:25 -0700 (Wed, 18 Apr 2012) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl1.html llvm/docs/tutorial/LangImpl1.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl1.html	2017-10-12 11:11:50.086432888 +0800
+++ llvm/docs/tutorial/LangImpl1.html	2017-10-12 11:09:30.909117914 +0800
@@ -342,7 +342,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-04-22 17:30:22 -0700 (Fri, 22 Apr 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl2.html llvm/docs/tutorial/LangImpl2.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl2.html	2017-10-12 11:11:50.087432899 +0800
+++ llvm/docs/tutorial/LangImpl2.html	2017-10-12 11:09:30.909117914 +0800
@@ -1225,7 +1225,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-16 01:06:54 -0700 (Sun, 16 Oct 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl3.html llvm/docs/tutorial/LangImpl3.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl3.html	2017-10-12 11:11:50.087432899 +0800
+++ llvm/docs/tutorial/LangImpl3.html	2017-10-12 11:09:30.910117924 +0800
@@ -1262,7 +1262,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-16 01:06:54 -0700 (Sun, 16 Oct 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl4.html llvm/docs/tutorial/LangImpl4.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl4.html	2017-10-12 11:11:50.087432899 +0800
+++ llvm/docs/tutorial/LangImpl4.html	2017-10-12 11:09:30.910117924 +0800
@@ -1147,7 +1147,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-16 01:06:54 -0700 (Sun, 16 Oct 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl5.html llvm/docs/tutorial/LangImpl5.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl5.html	2017-10-12 11:11:50.088432909 +0800
+++ llvm/docs/tutorial/LangImpl5.html	2017-10-12 11:09:30.910117924 +0800
@@ -1766,7 +1766,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-16 01:06:54 -0700 (Sun, 16 Oct 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl6.html llvm/docs/tutorial/LangImpl6.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl6.html	2017-10-12 11:11:50.088432909 +0800
+++ llvm/docs/tutorial/LangImpl6.html	2017-10-12 11:09:30.910117924 +0800
@@ -1823,7 +1823,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-16 01:06:54 -0700 (Sun, 16 Oct 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl7.html llvm/docs/tutorial/LangImpl7.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl7.html	2017-10-12 11:11:50.088432909 +0800
+++ llvm/docs/tutorial/LangImpl7.html	2017-10-12 11:09:30.910117924 +0800
@@ -2158,7 +2158,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-10-16 01:06:54 -0700 (Sun, 16 Oct 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl8.html llvm/docs/tutorial/LangImpl8.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/LangImpl8.html	2017-10-12 11:11:50.088432909 +0800
+++ llvm/docs/tutorial/LangImpl8.html	2017-10-12 11:09:30.911117933 +0800
@@ -353,7 +353,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-04-22 17:30:22 -0700 (Fri, 22 Apr 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl1.html llvm/docs/tutorial/OCamlLangImpl1.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl1.html	2017-10-12 11:11:50.088432909 +0800
+++ llvm/docs/tutorial/OCamlLangImpl1.html	2017-10-12 11:09:30.911117933 +0800
@@ -359,7 +359,7 @@
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="mailto:idadesub@users.sourceforge.net">Erick Tryzelaar</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-04-22 17:30:22 -0700 (Fri, 22 Apr 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl2.html llvm/docs/tutorial/OCamlLangImpl2.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl2.html	2017-10-12 11:11:50.088432909 +0800
+++ llvm/docs/tutorial/OCamlLangImpl2.html	2017-10-12 11:09:30.911117933 +0800
@@ -1037,7 +1037,7 @@
   <a href="mailto:sabre@nondot.org">Chris Lattner</a>
   <a href="mailto:erickt@users.sourceforge.net">Erick Tryzelaar</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-04-22 17:30:22 -0700 (Fri, 22 Apr 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl3.html llvm/docs/tutorial/OCamlLangImpl3.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl3.html	2017-10-12 11:11:50.089432919 +0800
+++ llvm/docs/tutorial/OCamlLangImpl3.html	2017-10-12 11:09:30.911117933 +0800
@@ -1087,7 +1087,7 @@
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="mailto:idadesub@users.sourceforge.net">Erick Tryzelaar</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-07-15 13:03:30 -0700 (Fri, 15 Jul 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl4.html llvm/docs/tutorial/OCamlLangImpl4.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl4.html	2017-10-12 11:11:50.089432919 +0800
+++ llvm/docs/tutorial/OCamlLangImpl4.html	2017-10-12 11:09:30.912117942 +0800
@@ -1021,7 +1021,7 @@
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="mailto:idadesub@users.sourceforge.net">Erick Tryzelaar</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-04-22 17:30:22 -0700 (Fri, 22 Apr 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl5.html llvm/docs/tutorial/OCamlLangImpl5.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl5.html	2017-10-12 11:11:50.089432919 +0800
+++ llvm/docs/tutorial/OCamlLangImpl5.html	2017-10-12 11:09:30.912117942 +0800
@@ -1554,7 +1554,7 @@
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="mailto:idadesub@users.sourceforge.net">Erick Tryzelaar</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-04-22 17:30:22 -0700 (Fri, 22 Apr 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl6.html llvm/docs/tutorial/OCamlLangImpl6.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl6.html	2017-10-12 11:11:50.089432919 +0800
+++ llvm/docs/tutorial/OCamlLangImpl6.html	2017-10-12 11:09:30.912117942 +0800
@@ -1568,7 +1568,7 @@
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="mailto:idadesub@users.sourceforge.net">Erick Tryzelaar</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-04-22 17:30:22 -0700 (Fri, 22 Apr 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl7.html llvm/docs/tutorial/OCamlLangImpl7.html
--- /data/project/xiangzhai/llvm-31/docs/tutorial/OCamlLangImpl7.html	2017-10-12 11:11:50.089432919 +0800
+++ llvm/docs/tutorial/OCamlLangImpl7.html	2017-10-12 11:09:30.912117942 +0800
@@ -1898,7 +1898,7 @@
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
   <a href="mailto:idadesub@users.sourceforge.net">Erick Tryzelaar</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2011-04-22 17:30:22 -0700 (Fri, 22 Apr 2011) $
 </address>
 </body>
 </html>
diff -Naur /data/project/xiangzhai/llvm-31/docs/WritingAnLLVMBackend.html llvm/docs/WritingAnLLVMBackend.html
--- /data/project/xiangzhai/llvm-31/docs/WritingAnLLVMBackend.html	2017-10-12 11:11:50.084432868 +0800
+++ llvm/docs/WritingAnLLVMBackend.html	2017-10-12 11:09:30.907117896 +0800
@@ -2526,7 +2526,7 @@
   <a href="http://www.woo.com">Mason Woo</a> and <a href="http://misha.brukman.net">Misha Brukman</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a>
   <br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-03-01 07:14:19 -0800 (Thu, 01 Mar 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/docs/WritingAnLLVMPass.html llvm/docs/WritingAnLLVMPass.html
--- /data/project/xiangzhai/llvm-31/docs/WritingAnLLVMPass.html	2017-10-12 11:11:50.085432878 +0800
+++ llvm/docs/WritingAnLLVMPass.html	2017-10-12 11:09:30.907117896 +0800
@@ -1947,7 +1947,7 @@
 
   <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
   <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
-  Last modified: $Date$
+  Last modified: $Date: 2012-04-08 04:52:52 -0700 (Sun, 08 Apr 2012) $
 </address>
 
 </body>
diff -Naur /data/project/xiangzhai/llvm-31/.gitignore llvm/.gitignore
--- /data/project/xiangzhai/llvm-31/.gitignore	2017-10-12 11:11:50.061432631 +0800
+++ llvm/.gitignore	2017-10-12 11:09:30.884117685 +0800
@@ -34,6 +34,7 @@
 # External projects that are tracked independently.
 projects/*
 !projects/sample
+!projects/LLVMBuild.txt
 !projects/CMakeLists.txt
 !projects/Makefile
 # Clang, which is tracked independently.
diff -Naur /data/project/xiangzhai/llvm-31/include/llvm/ADT/Hashing.h llvm/include/llvm/ADT/Hashing.h
--- /data/project/xiangzhai/llvm-31/include/llvm/ADT/Hashing.h	2017-10-12 11:11:50.096432991 +0800
+++ llvm/include/llvm/ADT/Hashing.h	2017-10-12 11:09:30.919118006 +0800
@@ -413,7 +413,6 @@
 /// combining them, this (as an optimization) directly combines the integers.
 template <typename InputIteratorT>
 hash_code hash_combine_range_impl(InputIteratorT first, InputIteratorT last) {
-  typedef typename std::iterator_traits<InputIteratorT>::value_type ValueT;
   const size_t seed = get_execution_seed();
   char buffer[64], *buffer_ptr = buffer;
   char *const buffer_end = buffer_ptr + array_lengthof(buffer);
diff -Naur /data/project/xiangzhai/llvm-31/include/llvm/Analysis/LoopInfo.h llvm/include/llvm/Analysis/LoopInfo.h
--- /data/project/xiangzhai/llvm-31/include/llvm/Analysis/LoopInfo.h	2017-10-12 11:11:50.103433063 +0800
+++ llvm/include/llvm/Analysis/LoopInfo.h	2017-10-12 11:09:30.925118062 +0800
@@ -293,7 +293,6 @@
 
     // Loop over the predecessors of the header node...
     BlockT *Header = getHeader();
-    typedef GraphTraits<BlockT*> BlockTraits;
     typedef GraphTraits<Inverse<BlockT*> > InvBlockTraits;
     for (typename InvBlockTraits::ChildIteratorType PI =
          InvBlockTraits::child_begin(Header),
diff -Naur /data/project/xiangzhai/llvm-31/include/llvm/Intrinsics.td llvm/include/llvm/Intrinsics.td
--- /data/project/xiangzhai/llvm-31/include/llvm/Intrinsics.td	2017-10-12 11:11:50.117433207 +0800
+++ llvm/include/llvm/Intrinsics.td	2017-10-12 11:09:30.938118181 +0800
@@ -139,6 +139,15 @@
 
 def llvm_vararg_ty     : LLVMType<isVoid>;   // this means vararg here
 
+// Scaffold
+def llvm_abit_ty      : LLVMType<i8>;
+def llvm_cbit_ty      : LLVMType<i1>;      //  
+def llvm_qbit_ty      : LLVMType<i16>;      //  
+
+// RKQC
+def rkqc_qint_ty      : LLVMType<i16>;      //
+
+
 
 //===----------------------------------------------------------------------===//
 // Intrinsic Definitions.
@@ -175,6 +184,40 @@
   string GCCBuiltinName = name;
 }
 
+// Scaffold
+def int_CNOT : Intrinsic<[], [llvm_anyint_ty, llvm_anyint_ty], [], "llvm.CNOT">;
+def int_X : Intrinsic<[], [llvm_anyint_ty], [], "llvm.X">;        
+def int_Y : Intrinsic<[], [llvm_anyint_ty], [], "llvm.Y">;        
+def int_Z : Intrinsic<[], [llvm_anyint_ty], [], "llvm.Z">;        
+def int_H : Intrinsic<[], [llvm_anyint_ty], [], "llvm.H">;        
+def int_T : Intrinsic<[], [llvm_anyint_ty], [], "llvm.T">;        
+def int_Tdag : Intrinsic<[], [llvm_anyint_ty], [], "llvm.Tdag">;        
+def int_S : Intrinsic<[], [llvm_anyint_ty], [], "llvm.S">;        
+def int_Sdag : Intrinsic<[], [llvm_anyint_ty], [], "llvm.Sdag">;        
+def int_Rx : Intrinsic<[], [llvm_anyint_ty, llvm_double_ty], [], "llvm.Rx">;        
+def int_Ry : Intrinsic<[], [llvm_anyint_ty, llvm_double_ty], [], "llvm.Ry">;        
+def int_Rz : Intrinsic<[], [llvm_anyint_ty, llvm_double_ty], [], "llvm.Rz">;        
+def int_PrepX : Intrinsic<[], [llvm_anyint_ty, llvm_i32_ty], [], "llvm.PrepX">;        
+def int_PrepZ : Intrinsic<[], [llvm_anyint_ty, llvm_i32_ty], [], "llvm.PrepZ">;        
+def int_MeasX : Intrinsic<[llvm_cbit_ty], [llvm_anyint_ty], [], "llvm.MeasX">;
+def int_MeasZ : Intrinsic<[llvm_cbit_ty], [llvm_anyint_ty], [], "llvm.MeasZ">;
+def int_Toffoli : Intrinsic<[], [llvm_anyint_ty, llvm_anyint_ty, llvm_anyint_ty], [], "llvm.Toffoli">;        
+def int_Fredkin : Intrinsic<[], [llvm_anyint_ty, llvm_anyint_ty, llvm_anyint_ty], [], "llvm.Fredkin">;        
+
+// RKQC
+def int_cnot : Intrinsic<[], [llvm_anyint_ty, llvm_anyint_ty], [], "llvm.rkqc.cnot">;
+def int_NOT : Intrinsic<[], [llvm_anyint_ty], [], "llvm.rkqc.NOT">;        
+def int_toffoli : Intrinsic<[], [llvm_anyint_ty, llvm_anyint_ty, llvm_anyint_ty], [], "llvm.rkqc.toffoli">;        
+
+def int_a_swap_b : Intrinsic<[], [llvm_anyint_ty, llvm_anyint_ty, llvm_i32_ty], [], "llvm.rkqc.a_swap_b">;
+def int_a_eq_a_plus_b : Intrinsic<[], [llvm_anyint_ty, llvm_anyint_ty, llvm_i32_ty], [], "llvm.rkqc.a_eq_a_plus_b">;
+def int_a_eq_a_minus_b : Intrinsic<[], [llvm_anyint_ty, llvm_anyint_ty, llvm_i32_ty], [], "llvm.rkqc.a_eq_a_minus_b">;
+def int_a_eq_a_plus_b_times_c : Intrinsic<[], [llvm_anyint_ty, llvm_anyint_ty, llvm_anyint_ty, llvm_i32_ty], [], "llvm.rkqc.a_eq_a_plus_b_times_c">;
+def int_assign_value_of_b_to_a : Intrinsic<[], [llvm_anyint_ty, llvm_anyint_ty, llvm_i32_ty], [], "llvm.rkqc.assign_value_of_b_to_a">;
+def int_assign_value_of_0_to_a : Intrinsic<[], [llvm_anyint_ty, llvm_i32_ty], [], "llvm.rkqc.assign_value_of_0_to_a">;
+def int_assign_value_of_1_to_a : Intrinsic<[], [llvm_anyint_ty, llvm_i32_ty], [], "llvm.rkqc.assign_value_of_1_to_a">;
+
+
 
 //===--------------- Variable Argument Handling Intrinsics ----------------===//
 //
diff -Naur /data/project/xiangzhai/llvm-31/include/llvm/SymbolTableListTraits.h llvm/include/llvm/SymbolTableListTraits.h
--- /data/project/xiangzhai/llvm-31/include/llvm/SymbolTableListTraits.h	2017-10-12 11:11:50.133433372 +0800
+++ llvm/include/llvm/SymbolTableListTraits.h	2017-10-12 11:09:30.951118301 +0800
@@ -46,7 +46,6 @@
   /// getListOwner - Return the object that owns this list.  If this is a list
   /// of instructions, it returns the BasicBlock that owns them.
   ItemParentClass *getListOwner() {
-    typedef iplist<ValueSubClass> ItemParentClass::*Sublist;
     size_t Offset(size_t(&((ItemParentClass*)0->*ItemParentClass::
                            getSublistAccess(static_cast<ValueSubClass*>(0)))));
     iplist<ValueSubClass>* Anchor(static_cast<iplist<ValueSubClass>*>(this));
diff -Naur /data/project/xiangzhai/llvm-31/include/llvm/Type.h llvm/include/llvm/Type.h
--- /data/project/xiangzhai/llvm-31/include/llvm/Type.h	2017-10-12 11:11:50.137433413 +0800
+++ llvm/include/llvm/Type.h	2017-10-12 11:09:30.955118337 +0800
@@ -370,6 +370,8 @@
   static IntegerType *getInt16Ty(LLVMContext &C);
   static IntegerType *getInt32Ty(LLVMContext &C);
   static IntegerType *getInt64Ty(LLVMContext &C);
+  static IntegerType *getInt128Ty(LLVMContext &C);
+
 
   //===--------------------------------------------------------------------===//
   // Convenience methods for getting pointer types with one of the above builtin
diff -Naur /data/project/xiangzhai/llvm-31/include/scaffold/QtmGateArg.h llvm/include/scaffold/QtmGateArg.h
--- /data/project/xiangzhai/llvm-31/include/scaffold/QtmGateArg.h	1970-01-01 08:00:00.000000000 +0800
+++ llvm/include/scaffold/QtmGateArg.h	2017-10-12 11:09:30.956118347 +0800
@@ -0,0 +1,46 @@
+//===----------------- QtmGateArg.cpp ----------------------===//
+// This file implements the Scaffold Quantum Gate Argument Class
+//
+//
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//
+//
+//
+//===----------------------------------------------------------------------===//
+
+
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Constants.h"
+
+using namespace llvm;
+
+namespace {
+  class QtmGateArg{ //arguments to qgate calls
+
+  public: 
+    Value* argPtr;
+    int argNum;
+    bool isQbit;
+    bool isCbit;
+    bool isUndef;
+    bool isPtr;
+    int valOrIndex; //Value if not Qbit, Index if Qbit & not a Ptr
+    double angle;
+
+    QtmGateArg(): argPtr(NULL), argNum(-1), isQbit(false), isCbit(false), isUndef(false), isPtr(false), valOrIndex(-1), angle(0.0){ }
+
+    void dump() //originally print_qgateArg
+    {
+      errs()<< "Printing QGate Argument:\n";
+      if(argPtr) errs() << "  Name: "<<argPtr->getName()<<"\n";
+      errs() << "  Arg Num: "<<argNum<<"\n"
+	     << "  isUndef: "<<isUndef
+	     << "  isQbit: "<<isQbit
+	     << "  isCbit: "<<isCbit
+	     << "  isPtr: "<<isPtr << "\n"
+	     << "  Value or Index: "<<valOrIndex<<"\n";
+    }                       
+  }; // End of struct QtmGateArg
+} // End of anonymous namespace
diff -Naur /data/project/xiangzhai/llvm-31/include/scaffold/QtmGate.h llvm/include/scaffold/QtmGate.h
--- /data/project/xiangzhai/llvm-31/include/scaffold/QtmGate.h	1970-01-01 08:00:00.000000000 +0800
+++ llvm/include/scaffold/QtmGate.h	2017-10-12 11:09:30.956118347 +0800
@@ -0,0 +1,389 @@
+//===----------------- QtmInst.cpp ----------------------===//
+// This file implements the Scaffold Quantum Instruction Class
+//
+//
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//
+//
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "QtmInst"
+#include <vector>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/ADT/SCCIterator.h"
+#include "llvm/Argument.h"
+#include "llvm/ADT/ilist.h"
+#include "llvm/Constants.h"
+#include "llvm/IntrinsicInst.h"
+#include "scaffold/QtmGateArg.h"
+
+
+using namespace llvm;
+using namespace std;
+
+#define MAX_GATE_ARGS 30
+#define MAX_BT_COUNT 15 //max backtrace allowed - to avoid infinite recursive loops
+
+bool debugQtmInst = false;
+
+namespace {
+  
+  struct qArgInfo{
+    string name;
+    int index;
+    qArgInfo(): name("none"), index(-1){ }
+  };
+  
+  struct qGate{
+    Function* qFunc;
+    int numArgs;
+    qArgInfo args[MAX_GATE_ARGS];
+    double angle;
+    qGate():qFunc(NULL), numArgs(0), angle(0.0) { }
+  };
+
+  struct QtmInst : public ModulePass {
+    static char ID; // Pass identification
+    
+    vector<QtmGateArg> tmpDepQbit;
+    
+    int btCount; //backtrace count
+
+    QtmInst() : ModulePass(ID) {}
+    
+    bool checkIfQbitOrCbit(Type* varType);
+
+    bool backtraceOperand(Value* opd, int opOrIndex);
+    void analyzeCallInst(Function* F,Instruction* pinst);
+
+    void print_qgate(qGate qg);
+
+    
+    bool runOnModule (Module &M);    
+    
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();  
+      AU.addRequired<CallGraph>();    
+    }
+    
+  }; // End of struct QtmInst
+} // End of anonymous namespace
+
+char QtmInst::ID = 0;
+static RegisterPass<QtmInst> X("QtmInst", "Get gate and operands for a Qtm Inst");
+
+
+bool QtmInst::checkIfQbitOrCbit(Type* varType)
+{
+  if(varType->isPointerTy()){
+    Type *elementType = varType->getPointerElementType();
+    if (elementType->isIntegerTy(16) || elementType->isIntegerTy(1)){ //qbit* or cbit*
+      return true;	      
+    }
+  }
+  else if (varType->isIntegerTy(16) || varType->isIntegerTy(1)){ //qbit or cbit
+    return true;
+  }
+  return false;
+}
+
+bool QtmInst::backtraceOperand(Value* opd, int opOrIndex)
+{
+  if(opOrIndex == 0) //backtrace for operand
+    {
+
+      if(Argument *fArg = dyn_cast<Argument>(opd))
+	{
+	  Type* argType = fArg->getType();
+	  bool isQtm = checkIfQbitOrCbit(argType);
+	  if(isQtm){
+	    tmpDepQbit[0].argPtr = opd;
+	    return true;
+	  } 
+	}
+
+      if (AllocaInst *AI = dyn_cast<AllocaInst>(opd)) {
+	Type *allocatedType = AI->getAllocatedType();
+    
+	if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+	  Type *elementType = arrayType->getElementType();
+	  bool isQtm = checkIfQbitOrCbit(elementType);
+	  if(isQtm){
+	    tmpDepQbit[0].argPtr = opd;
+	    return true;
+	  }
+	}
+      }
+
+      if(btCount>MAX_BT_COUNT)
+	return false;
+      
+      if(isa<GetElementPtrInst>(opd))
+	{
+	  Instruction* pInst = dyn_cast<Instruction>(opd);
+	  backtraceOperand(pInst->getOperand(0),0);
+	  unsigned numOps = pInst->getNumOperands();
+
+	  //NOTE: getelemptr instruction can have multiple indices. Currently considering last operand as desired index for qubit. This may not be true for multi-dimensional qubit arrays 
+	  if(ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(numOps-1))){
+	    if(tmpDepQbit.size()==1){
+	      tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+	    }
+	  }
+	  else{
+
+	    if(tmpDepQbit[0].isQbit && !(tmpDepQbit[0].isPtr)){
+     	      //NOTE: getelemptr instruction can have multiple indices. consider last operand as desired index for qubit. This may not be true for multi-dimensional qubit arrays
+	      backtraceOperand(pInst->getOperand(numOps-1),1);
+	      
+	    }
+
+	  }	 
+	  /*
+	    //For multi-dimensional qubit array, we may need to backtrace multiple pointer values
+	    for(unsigned iop=1;iop<numOps;iop++){ //first opd was already backtraced
+	      backtraceOperand(pInst->getOperand(iop),0);
+
+	    }*/
+	  return true;
+	}
+      
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	unsigned numOps = pInst->getNumOperands();
+	for(unsigned iop=0;iop<numOps;iop++){
+	  btCount++;
+	  backtraceOperand(pInst->getOperand(iop),0);
+	  btCount--;
+	}
+	return true;
+      }
+      else{
+	return true;
+      }
+    }
+  else if(opOrIndex == 0){ //opOrIndex == 1; i.e. Backtracing for Index    
+    if(btCount>MAX_BT_COUNT) //prevent infinite backtracing
+      return true;
+
+    if(ConstantInt *CI = dyn_cast<ConstantInt>(opd)){
+      tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+      return true;
+    }      
+
+    if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+      unsigned numOps = pInst->getNumOperands();
+      for(unsigned iop=0;iop<numOps;iop++){
+	btCount++;
+	backtraceOperand(pInst->getOperand(iop),1);
+	btCount--;
+      }
+    }
+
+  }
+  else{ //opOrIndex == 2: backtracing to call inst MeasZ
+    if(CallInst *endCI = dyn_cast<CallInst>(opd)){
+      if(endCI->getCalledFunction()->getName().find("llvm.Meas") != string::npos){
+	tmpDepQbit[0].argPtr = opd;
+
+	return true;
+      }
+      else{
+	if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	  unsigned numOps = pInst->getNumOperands();
+	  bool foundOne=false;
+	  for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	    btCount++;
+	    foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+	    btCount--;
+	  }
+	  return foundOne;
+	}
+      }
+    }
+    else{
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	unsigned numOps = pInst->getNumOperands();
+	bool foundOne=false;
+	for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	  btCount++;
+	  foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+	  btCount--;
+	}
+	return foundOne;
+      }
+    }
+  }
+  return false;
+}
+
+
+void QtmInst::print_qgate(qGate qg){
+  errs() << qg.qFunc->getName() << " : ";
+  for(int i=0;i<qg.numArgs;i++){
+    errs() << qg.args[i].name << "[" << qg.args[i].index << "], "  ;
+  }
+  errs() << "\n";
+}
+
+void QtmInst::analyzeCallInst(Function* F, Instruction* pInst){
+  if(CallInst *CI = dyn_cast<CallInst>(pInst))
+    {      
+      if(debugQtmInst)
+	errs() << "Call inst: " << CI->getCalledFunction()->getName() << "\n";
+
+      if(CI->getCalledFunction()->getName() == "store_cbit"){	//trace return values
+	return;
+      }      
+
+      vector<QtmGateArg> allDepQbit;                                  
+      
+      bool tracked_operand = false;
+
+      int myPrepState = -1;
+      double myRotationAngle = 0.0;
+      
+      for(unsigned iop=0;iop<CI->getNumArgOperands();iop++){
+	tmpDepQbit.clear();
+	
+	QtmGateArg tmpQGateArg;
+	btCount=0;
+	
+	tmpQGateArg.argNum = iop;
+		
+	if(isa<UndefValue>(CI->getArgOperand(iop))){
+	  errs() << "WARNING: LLVM IR code has UNDEF values. \n";
+	  tmpQGateArg.isUndef = true;	
+	  //exit(1);
+	}
+	
+	Type* argType = CI->getArgOperand(iop)->getType();
+	if(argType->isPointerTy()){
+	  tmpQGateArg.isPtr = true;
+	  Type *argElemType = argType->getPointerElementType();
+	  if(argElemType->isIntegerTy(16))
+	    tmpQGateArg.isQbit = true;
+	  if(argElemType->isIntegerTy(1))
+	    tmpQGateArg.isCbit = true;
+	}
+	else if(argType->isIntegerTy(16)){
+	  tmpQGateArg.isQbit = true;
+	  tmpQGateArg.valOrIndex = 0;	 
+	}	  	
+	else if(argType->isIntegerTy(1)){
+	  tmpQGateArg.isCbit = true;
+	  tmpQGateArg.valOrIndex = 0;	 
+	}
+
+
+	//check if argument is constant int
+	if(ConstantInt *CInt = dyn_cast<ConstantInt>(CI->getArgOperand(iop))){
+	  myPrepState = CInt->getZExtValue();	  
+	}
+	
+	//check if argument is constant float
+	if(ConstantFP *CFP = dyn_cast<ConstantFP>(CI->getArgOperand(iop))){
+	  myRotationAngle = CFP->getValueAPF().convertToDouble();
+	}	  	
+	
+        //if(tmpQGateArg.isQbit || tmpQGateArg.isCbit){
+	if(tmpQGateArg.isQbit){
+            tmpDepQbit.push_back(tmpQGateArg);	
+            tracked_operand = backtraceOperand(CI->getArgOperand(iop),0);
+	}
+
+        if(tmpDepQbit.size()>0){	  
+	  allDepQbit.push_back(tmpDepQbit[0]);
+	  assert(tmpDepQbit.size() == 1 && "tmpDepQbit SIZE GT 1");
+	  tmpDepQbit.clear();
+	}
+	
+      }
+      
+      if(allDepQbit.size() > 0){
+	if(debugQtmInst)
+	{
+	    errs() << "\nCall inst: " << CI->getCalledFunction()->getName();	    
+	    errs() << ": Found all arguments: ";       
+	    for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+	      if(allDepQbit[vb].argPtr)
+		errs() << allDepQbit[vb].argPtr->getName() <<" Index: ";
+                                
+	      //else
+		errs() << allDepQbit[vb].valOrIndex <<" ";
+	    }
+	    errs()<<"\n";
+	    
+	}
+
+          
+       string fname =  CI->getCalledFunction()->getName();  
+       qGate thisGate;
+       thisGate.qFunc =  CI->getCalledFunction();
+
+       if(myPrepState!=-1) thisGate.angle = (float)myPrepState;
+       if(myRotationAngle!=0.0) thisGate.angle = myRotationAngle;
+
+       for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+            if(allDepQbit[vb].argPtr){
+	      //errs() << allDepQbit[vb].argPtr->getName() <<" Index: ";
+	      //errs() << allDepQbit[vb].valOrIndex <<"\n";
+	      QtmGateArg param =  allDepQbit[vb];       
+                thisGate.args[thisGate.numArgs].name = param.argPtr->getName();
+		if(!param.isPtr)
+		  thisGate.args[thisGate.numArgs].index = param.valOrIndex;
+                thisGate.numArgs++;
+	    }
+       }
+
+       print_qgate(thisGate);
+
+      }    
+      allDepQbit.erase(allDepQbit.begin(),allDepQbit.end());
+    }
+}
+
+bool QtmInst::runOnModule (Module &M) {
+  
+  // iterate over all functions, and over all instructions in those functions
+  CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+  
+  //Post-order
+  for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode), E = scc_end(rootNode); sccIb != E; ++sccIb) {
+    const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+    for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(), E = nextSCC.end(); nsccI != E; ++nsccI) {
+      Function *F = (*nsccI)->getFunction();	  
+            
+      if(F && !F->isDeclaration()){
+	errs() << "\n#Function " << F->getName() << "\n";      
+       	
+	for (inst_iterator I = inst_begin(*F), E = inst_end(*F); I != E; ++I) {
+	  Instruction *Inst = &*I;                            // Grab pointer to instruction reference
+	  if(isa<CallInst>(Inst))
+	    analyzeCallInst(F,Inst);	
+
+	}
+	
+      }
+      else{
+	    if(debugQtmInst)
+	      errs() << "WARNING: Ignoring external node or dummy function.\n";
+	  }
+    }
+  }
+
+  return false;
+} // End runOnModule
diff -Naur /data/project/xiangzhai/llvm-31/lib/AsmParser/LLParser.cpp llvm/lib/AsmParser/LLParser.cpp
--- /data/project/xiangzhai/llvm-31/lib/AsmParser/LLParser.cpp	2017-10-12 11:11:50.149433536 +0800
+++ llvm/lib/AsmParser/LLParser.cpp	2017-10-12 11:09:30.965118429 +0800
@@ -167,6 +167,7 @@
     case lltok::kw_declare: if (ParseDeclare()) return true; break;
     case lltok::kw_define:  if (ParseDefine()) return true; break;
     case lltok::kw_module:  if (ParseModuleAsm()) return true; break;
+    case lltok::kw_rkqc:    if (ParseModuleAsm()) return true; break;
     case lltok::kw_target:  if (ParseTargetDefinition()) return true; break;
     case lltok::kw_deplibs: if (ParseDepLibs()) return true; break;
     case lltok::LocalVarID: if (ParseUnnamedType()) return true; break;
diff -Naur /data/project/xiangzhai/llvm-31/lib/AsmParser/LLToken.h llvm/lib/AsmParser/LLToken.h
--- /data/project/xiangzhai/llvm-31/lib/AsmParser/LLToken.h	2017-10-12 11:11:50.149433536 +0800
+++ llvm/lib/AsmParser/LLToken.h	2017-10-12 11:09:30.965118429 +0800
@@ -66,6 +66,7 @@
     kw_section,
     kw_alias,
     kw_module,
+    kw_rkqc,
     kw_asm,
     kw_sideeffect,
     kw_alignstack,
diff -Naur /data/project/xiangzhai/llvm-31/lib/CodeGen/RegisterCoalescer.cpp llvm/lib/CodeGen/RegisterCoalescer.cpp
--- /data/project/xiangzhai/llvm-31/lib/CodeGen/RegisterCoalescer.cpp	2017-10-12 11:11:50.165433701 +0800
+++ llvm/lib/CodeGen/RegisterCoalescer.cpp	2017-10-12 11:09:30.979118558 +0800
@@ -276,7 +276,7 @@
     if (SrcSub && DstSub) {
       // For now we only handle the case of identical indices in commensurate
       // registers: Dreg:ssub_1 + Dreg:ssub_1 -> Dreg
-      // FIXME: Handle Qreg:ssub_3 + Dreg:ssub_1 as QReg:dsub_1 + Dreg.
+      // FIXME: Handle Qbit:ssub_3 + Dreg:ssub_1 as QReg:dsub_1 + Dreg.
       if (SrcSub != DstSub)
         return false;
       const TargetRegisterClass *SrcRC = MRI.getRegClass(Src);
diff -Naur /data/project/xiangzhai/llvm-31/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp
--- /data/project/xiangzhai/llvm-31/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp	2017-10-12 11:11:50.175433804 +0800
+++ llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp	2017-10-12 11:09:30.987118632 +0800
@@ -3974,6 +3974,18 @@
   setValue(&I, result);
 }
 
+void SelectionDAGBuilder::visitQuantumGate(const CallInst &I){ //scaffold
+  SDValue result;
+  DebugLoc dl = getCurDebugLoc();
+  
+  result = DAG.getNode(ISD::UNDEF, dl,
+		       getValue(I.getArgOperand(0)).getValueType(),
+		       getValue(I.getArgOperand(0)));
+  
+  setValue(&I, result);
+}
+
+
 /// visitLog10 - Lower a log10 intrinsic. Handles the special sequences for
 /// limited-precision mode.
 void
@@ -5139,6 +5151,27 @@
   case Intrinsic::lifetime_end:
     // Discard region information.
     return 0;
+
+  case Intrinsic::CNOT: //scaffold
+  case Intrinsic::X:
+  case Intrinsic::Y:
+  case Intrinsic::Z:
+  case Intrinsic::H:
+  case Intrinsic::T:
+  case Intrinsic::Tdag:
+  case Intrinsic::S:
+  case Intrinsic::Sdag:
+  case Intrinsic::Rz:
+  case Intrinsic::PrepX:
+  case Intrinsic::PrepZ:
+  case Intrinsic::MeasX:
+  case Intrinsic::MeasZ:
+  case Intrinsic::Toffoli:
+  case Intrinsic::Fredkin:
+    visitQuantumGate(I);
+    return 0;   
+
+
   }
 }
 
diff -Naur /data/project/xiangzhai/llvm-31/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h
--- /data/project/xiangzhai/llvm-31/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h	2017-10-12 11:11:50.175433804 +0800
+++ llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h	2017-10-12 11:09:30.987118632 +0800
@@ -545,6 +545,8 @@
   void visitLog2(const CallInst &I);
   void visitLog10(const CallInst &I);
 
+  void visitQuantumGate(const CallInst &I); //scaffold
+
   void visitVAStart(const CallInst &I);
   void visitVAArg(const VAArgInst &I);
   void visitVAEnd(const CallInst &I);
diff -Naur /data/project/xiangzhai/llvm-31/lib/ExecutionEngine/IntelJITEvents/LLVMBuild.txt llvm/lib/ExecutionEngine/IntelJITEvents/LLVMBuild.txt
--- /data/project/xiangzhai/llvm-31/lib/ExecutionEngine/IntelJITEvents/LLVMBuild.txt	2017-10-12 11:11:50.181433866 +0800
+++ llvm/lib/ExecutionEngine/IntelJITEvents/LLVMBuild.txt	2017-10-12 11:09:30.993118687 +0800
@@ -18,6 +18,6 @@
 [common]
 
 [component_0]
-type = OptionalLibrary
+type = Library
 name = IntelJITEvents
 parent = ExecutionEngine
diff -Naur /data/project/xiangzhai/llvm-31/lib/ExecutionEngine/OProfileJIT/LLVMBuild.txt llvm/lib/ExecutionEngine/OProfileJIT/LLVMBuild.txt
--- /data/project/xiangzhai/llvm-31/lib/ExecutionEngine/OProfileJIT/LLVMBuild.txt	2017-10-12 11:11:50.184433897 +0800
+++ llvm/lib/ExecutionEngine/OProfileJIT/LLVMBuild.txt	2017-10-12 11:09:30.995118705 +0800
@@ -18,6 +18,6 @@
 [common]
 
 [component_0]
-type = OptionalLibrary
+type = Library
 name = OProfileJIT
 parent = ExecutionEngine
diff -Naur /data/project/xiangzhai/llvm-31/lib/Target/ARM/AsmParser/ARMAsmParser.cpp llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
--- /data/project/xiangzhai/llvm-31/lib/Target/ARM/AsmParser/ARMAsmParser.cpp	2017-10-12 11:11:50.219434257 +0800
+++ llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp	2017-10-12 11:09:31.027118999 +0800
@@ -4411,12 +4411,12 @@
   // vmov.f32 <sreg>, #imm
   // vmov.f64 <dreg>, #imm
   // vmov.f32 <dreg>, #imm  @ vector f32x2
-  // vmov.f32 <qreg>, #imm  @ vector f32x4
+  // vmov.f32 <qbit>, #imm  @ vector f32x4
   //
   // There are also the NEON VMOV instructions which expect an
   // integer constant. Make sure we don't try to parse an FPImm
   // for these:
-  // vmov.i{8|16|32|64} <dreg|qreg>, #imm
+  // vmov.i{8|16|32|64} <dreg|qbit>, #imm
   ARMOperand *TyOp = static_cast<ARMOperand*>(Operands[2]);
   if (!TyOp->isToken() || (TyOp->getToken() != ".f32" &&
                            TyOp->getToken() != ".f64"))
diff -Naur /data/project/xiangzhai/llvm-31/lib/Target/AVR/diff llvm/lib/Target/AVR/diff
--- /data/project/xiangzhai/llvm-31/lib/Target/AVR/diff	2017-10-12 11:10:00.837393001 +0800
+++ llvm/lib/Target/AVR/diff	1970-01-01 08:00:00.000000000 +0800
@@ -1,32 +0,0 @@
-diff --git a/lib/Target/AVR/AVRInstrInfo.td b/lib/Target/AVR/AVRInstrInfo.td
-index 61a227b..35a0f29 100644
---- a/lib/Target/AVR/AVRInstrInfo.td
-+++ b/lib/Target/AVR/AVRInstrInfo.td
-@@ -188,6 +188,12 @@ def imm16 : Operand<i16>
-     let EncoderMethod = "encodeImm<AVR::fixup_16, 2>";
- }
- 
-+// A 8-bit address (which can lead to an R_AVR_8 relocation).
-+def imm8 : Operand<i8>
-+{
-+    let EncoderMethod = "encodeImm<AVR::fixup_8, 0>";
-+}
-+
- /// A 6-bit immediate used in the ADIW/SBIW instructions.
- def imm_arith6 : Operand<i16>
- {
-diff --git a/lib/Target/AVR/MCTargetDesc/AVRELFObjectWriter.cpp b/lib/Target/AVR/MCTargetDesc/AVRELFObjectWriter.cpp
-index 4f2fd35..14bea17 100644
---- a/lib/Target/AVR/MCTargetDesc/AVRELFObjectWriter.cpp
-+++ b/lib/Target/AVR/MCTargetDesc/AVRELFObjectWriter.cpp
-@@ -39,8 +39,10 @@ unsigned AVRELFObjectWriter::getRelocType(MCContext &Ctx,
-                                           const MCValue &Target,
-                                           const MCFixup &Fixup,
-                                           bool IsPCRel) const {
-+  errs() << "DEBUG: getRelocType: " << Fixup.getKind() << "\n";
-   switch ((unsigned) Fixup.getKind()) {
-   case FK_Data_1:
-+    return ELF::R_AVR_8;
-   case FK_Data_4:
-     llvm_unreachable("unsupported relocation type");
-   case FK_Data_2:
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/CMakeLists.txt llvm/lib/Transforms/CMakeLists.txt
--- /data/project/xiangzhai/llvm-31/lib/Transforms/CMakeLists.txt	2017-10-12 11:11:50.282434905 +0800
+++ llvm/lib/Transforms/CMakeLists.txt	2017-10-12 11:09:31.082119505 +0800
@@ -4,4 +4,5 @@
 add_subdirectory(Scalar)
 add_subdirectory(IPO)
 add_subdirectory(Vectorize)
+add_subdirectory(Scaffold)
 add_subdirectory(Hello)
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/LLVMBuild.txt llvm/lib/Transforms/LLVMBuild.txt
--- /data/project/xiangzhai/llvm-31/lib/Transforms/LLVMBuild.txt	2017-10-12 11:11:50.290434987 +0800
+++ llvm/lib/Transforms/LLVMBuild.txt	2017-10-12 11:09:31.090119578 +0800
@@ -16,7 +16,7 @@
 ;===------------------------------------------------------------------------===;
 
 [common]
-subdirectories = IPO InstCombine Instrumentation Scalar Utils Vectorize
+subdirectories = IPO InstCombine Instrumentation Scalar Utils Vectorize Scaffold
 
 [component_0]
 type = Group
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Makefile llvm/lib/Transforms/Makefile
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Makefile	2017-10-12 11:11:50.290434987 +0800
+++ llvm/lib/Transforms/Makefile	2017-10-12 11:09:31.090119578 +0800
@@ -8,7 +8,7 @@
 ##===----------------------------------------------------------------------===##
 
 LEVEL = ../..
-PARALLEL_DIRS = Utils Instrumentation Scalar InstCombine IPO Vectorize Hello
+PARALLEL_DIRS = Utils Instrumentation Scalar InstCombine IPO Vectorize Hello ResourceAnalysis Scaffold
 
 include $(LEVEL)/Makefile.config
 
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/ResourceAnalysis/Makefile llvm/lib/Transforms/ResourceAnalysis/Makefile
--- /data/project/xiangzhai/llvm-31/lib/Transforms/ResourceAnalysis/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/ResourceAnalysis/Makefile	2017-10-12 11:09:31.090119578 +0800
@@ -0,0 +1,13 @@
+##===- lib/Transforms/ResourceAnalysis/Makefile -----------------------*- Makefile -*-===##
+#
+#
+#
+##===----------------------------------------------------------------------===##
+
+LEVEL = ../../..
+LIBRARYNAME = ScaffoldResourceAnalysis
+LOADABLE_MODULE = 1
+USEDLIBS =
+
+include $(LEVEL)/Makefile.common
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/ResourceAnalysis/ResourceAnalysis.cpp llvm/lib/Transforms/ResourceAnalysis/ResourceAnalysis.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/ResourceAnalysis/ResourceAnalysis.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/ResourceAnalysis/ResourceAnalysis.cpp	2017-10-12 11:09:31.090119578 +0800
@@ -0,0 +1,165 @@
+#include <iostream>
+#include <set>
+#include "llvm/Pass.h"
+#include "llvm/CallGraphSCCPass.h"
+#include "llvm/Function.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ValueSymbolTable.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instructions.h"
+
+using namespace llvm;
+using namespace std;
+
+namespace {
+  /* Func is the struct that stores resource usage information
+   * of each function, as well as the call graph
+   */
+  struct Func {
+   public:
+    string name;  // Name of the function
+    // Functions called by this function and number of times called
+    map<string, int> calls;
+    
+    /* self_bits stores the amount of qbits used by this function.
+     *
+     * total_bits stores the amount of qbits used by this function and
+     * all its children.
+     */
+    int self_bits, total_bits_min, total_bits_max, self_ops, total_ops;
+    Func(string n) : name(n),
+                     self_bits(0), total_bits_min(0), total_bits_max(0),
+                     self_ops(0), total_ops(0) {}
+  };
+  map<string, Func*> cg;  // Map from function name to Func struct
+  Func* root = NULL;      // The Func struct for the "main" function
+
+  struct ScaffoldResourceAnalysis : public CallGraphSCCPass {
+    static char ID;
+
+    ScaffoldResourceAnalysis() : CallGraphSCCPass(ID) {}
+
+    int analyzeAlloc(Instruction* inst) {
+      if (const AllocaInst *AI = dyn_cast<AllocaInst>(inst)) {
+        // AllocaInst means variable declaration
+        Type* ty = AI->getAllocatedType();
+        int sub_bits = 1;
+        /* For array types, recursively walk through each dimention
+         * and multiply all the sizes until we reach the last
+         */
+        while (ty->isArrayTy()) {
+          sub_bits *= ty->getArrayNumElements();
+          ty = ty->getArrayElementType();
+        }
+        // We only need to count qbits and cbits; skip integers
+        if (ty->getPrimitiveSizeInBits() > 8)
+          sub_bits = 0;
+        return sub_bits;
+      }
+      return 0;
+    }
+
+    int analyzeGate(Instruction* inst) {
+      if (const CallInst *CI = dyn_cast<CallInst>(inst)) {
+        string name = CI->getCalledFunction()->getName();
+        if (name.find("llvm.") != string::npos)
+          return 1;
+      }
+      return 0;
+    }
+
+    virtual bool runOnSCC(CallGraphSCC &SCC) {
+      /* Currently I don't know what does "Singular" mean in LLVM.
+       * I need more complicated test cases to figure out.
+       */
+      assert(SCC.isSingular());
+
+      // Walk through the call graph
+      for (CallGraphSCC::iterator itr = SCC.begin(); itr != SCC.end(); itr++) {
+        Function* f = (*itr)->getFunction();
+        if (!f) // External nodes will give empty function
+          continue;
+        string name = f->getName();
+        Func* fnode;
+        if (cg.find(name) == cg.end()) {
+          cg[name] = fnode = new Func(name);
+          if (name == "main")
+            root = fnode;
+          if (!f->empty()) {  // Whether this function contain code
+            int bits = 0, ops = 0;
+            for (Function::iterator f_itr = f->begin(); f_itr != f->end(); f_itr++) {
+              // Walk through each instruction in the basic block
+              for (BasicBlock::iterator bb_itr = f_itr->begin();
+                  bb_itr != f_itr->end(); bb_itr++) {
+                bits += analyzeAlloc(bb_itr);
+                ops += analyzeGate(bb_itr);
+              }
+            }
+            fnode->self_bits = bits;
+            fnode->self_ops = ops;
+          }
+        } else {
+          fnode = cg[name];
+        }
+        // Insert call graph
+        for (CallGraphNode::iterator node_itr = (*itr)->begin();
+             node_itr != (*itr)->end(); node_itr++) {
+          if (node_itr->second->getFunction())
+            fnode->calls.insert(make_pair(
+              node_itr->second->getFunction()->getName(),
+              node_itr->second->getNumReferences()));
+        }
+      }
+      return false;
+    }
+
+    void dump(Func* func, int tab, int ref) {
+      for (int i = 0; i < tab; i++)
+        std::cout << "  ";
+      if (ref)
+        cout << "(" << ref << ")";
+      std::cout << func->name << " (SB="
+                << func->self_bits << ", TBMin="
+                << func->total_bits_min << ", TBMax="
+                << func->total_bits_max << ", SOp="
+                << func->self_ops << ", TOp="
+                << func->total_ops << ")" << std::endl;
+      for (map<string, int>::iterator itr = func->calls.begin();
+           itr != func->calls.end(); itr++)
+        dump(cg[itr->first], tab + 1, itr->second);
+    }
+    
+    /* Calculate the total number of bits used by each function and
+     * its children
+     */
+    void propagate_bits(Func* func) {
+      func->total_bits_min = func->total_bits_max = func->self_bits;
+      func->total_ops = func->self_ops;
+      int max_bits = 0;
+      for (map<string, int>::iterator itr = func->calls.begin();
+           itr != func->calls.end(); itr++) {
+        propagate_bits(cg[itr->first]);
+        max_bits = max(max_bits, cg[itr->first]->total_bits_min);
+        func->total_bits_max += itr->second * cg[itr->first]->total_bits_max;
+        func->total_ops += itr->second * cg[itr->first]->total_ops;
+      }
+      func->total_bits_min += max_bits;
+    }
+
+    virtual bool doFinalization (CallGraph &CG) {
+      assert(root);
+      propagate_bits(root);
+      dump(root, 0, 0);
+      for (map<string, Func*>::iterator itr = cg.begin(); itr != cg.end(); itr++)
+        delete itr->second;
+      return false;
+    }
+  }; // end of struct ScaffoldResourceAnalysis
+}  // end of anonymous namespace
+
+char ScaffoldResourceAnalysis::ID = 0;
+
+static RegisterPass<ScaffoldResourceAnalysis> X("sra", "Scaffold resource analysis",
+                             false /* Only looks at CFG */,
+                             false /* Analysis Pass */);
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/CMakeLists.txt llvm/lib/Transforms/Scaffold/CMakeLists.txt
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/CMakeLists.txt	2017-10-12 11:09:31.090119578 +0800
@@ -0,0 +1,5 @@
+add_llvm_loadable_module( LLVMScaffold
+    FunctionClone.cpp
+    GateCount.cpp
+    Rotations.cpp
+  )
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/CriticalResourceCount.cpp llvm/lib/Transforms/Scaffold/CriticalResourceCount.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/CriticalResourceCount.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/CriticalResourceCount.cpp	2017-10-12 11:09:31.090119578 +0800
@@ -0,0 +1,823 @@
+//===----------------- CriticalResourceCount.cpp ----------------------===//
+// This file implements the Scaffold Pass of counting the number 
+//  of critical timesteps and gate parallelism in program
+//  in callgraph post-order.
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "CriticalResourceCount"
+#include <vector>
+#include <limits>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/ADT/SCCIterator.h"
+#include "llvm/Argument.h"
+#include "llvm/ADT/ilist.h"
+#include "llvm/Constants.h"
+#include "llvm/IntrinsicInst.h"
+
+
+using namespace llvm;
+using namespace std;
+
+#define MAX_GATE_ARGS 15
+#define MAX_BT_COUNT 15 //max backtrace allowed - to avoid infinite recursive loops
+#define NUM_QGATES 17
+#define _CNOT 0
+#define _H 1
+#define _S 2
+#define _T 3
+#define _X 4
+#define _Y 5
+#define _Z 6
+#define _MeasX 7
+#define _MeasZ 8
+#define _PrepX 9
+#define _PrepZ 10
+#define _Tdag 11
+#define _Sdag 12
+#define _Rz 13
+#define _Toffoli 14
+#define _Fredkin 15
+#define _All 16
+
+
+bool debugCritDataPath = false;
+
+namespace {
+  
+  struct qGateArg{ //arguments to qgate calls
+    Value* argPtr;
+    int argNum;
+    bool isQbit;
+    bool isCbit;
+    bool isUndef;
+    bool isPtr;
+    int valOrIndex; //Value if not Qbit, Index if Qbit & not a Ptr
+
+    qGateArg(): argPtr(NULL), argNum(-1), isQbit(false), isCbit(false), isUndef(false), isPtr(false), valOrIndex(-1){ }
+  };
+  
+struct qArgInfo{
+  string name;
+  int index;
+
+  qArgInfo(): name("none"), index(-1){ }
+};
+
+struct qGate{
+  Function* qFunc;
+  int numArgs;
+  qArgInfo args[MAX_GATE_ARGS];
+  qGate():qFunc(NULL), numArgs(0) { }
+};
+
+  struct TSParGateInfo{
+    unsigned long long int parallel_gates[NUM_QGATES];
+  };
+
+  struct TSInfo{
+    unsigned long long int timesteps;
+    vector<TSParGateInfo> gates;
+    TSInfo(): timesteps(0){ }
+  };  
+
+  struct MaxTSInfo{ //TimeStepInfo
+    unsigned long long int timesteps;
+    unsigned long long int parallel_gates[NUM_QGATES];
+    MaxTSInfo(): timesteps(0){ }
+  };
+
+  struct CriticalResourceCount : public ModulePass {
+    static char ID; // Pass identification
+    
+    string gate_name[NUM_QGATES];
+    vector<qGateArg> tmpDepQbit;
+    vector<Value*> vectQbit;
+    
+    int btCount; //backtrace count
+
+    vector<qArgInfo> currTimeStep; //contains set of arguments operated on currently
+    vector<string> currParallelFunc;
+    MaxTSInfo maxParallelFactor; //overall max parallel factor
+    map<string, int> gate_index;    
+    vector<unsigned long long int> curr_parallel_ts; //vector of current timesteps that are parallel; used for comparing functions
+    map<string, TSInfo > funcParallelFactor; //string is function name
+    map<string, MaxTSInfo> funcMaxParallelFactor;
+
+        
+    CriticalResourceCount() : ModulePass(ID) {}
+    
+    bool backtraceOperand(Value* opd, int opOrIndex);
+    void analyzeAllocInst(Function* F,Instruction* pinst);
+    void analyzeCallInst(Function* F,Instruction* pinst);
+    void getFunctionArguments(Function *F);
+    
+    
+    void init_gate_names(){
+        gate_name[_CNOT] = "CNOT";
+        gate_name[_H] = "H";
+        gate_name[_S] = "S";
+        gate_name[_T] = "T";
+        gate_name[_Toffoli] = "Toffoli";
+        gate_name[_X] = "X";
+        gate_name[_Y] = "Y";
+        gate_name[_Z] = "Z";
+        gate_name[_MeasX] = "MeasX";
+        gate_name[_MeasZ] = "MeasZ";
+        gate_name[_PrepX] = "PrepX";
+        gate_name[_PrepZ] = "PrepZ";
+        gate_name[_Sdag] = "Sdag";
+        gate_name[_Tdag] = "Tdag";
+        gate_name[_Fredkin] = "Fredkin";
+        gate_name[_Rz] = "Rz";
+        gate_name[_All] = "All";                    
+        
+        gate_index["CNOT"] = _CNOT;        
+        gate_index["H"] = _H;
+        gate_index["S"] = _S;
+        gate_index["T"] = _T;
+        gate_index["Toffoli"] = _Toffoli;
+        gate_index["X"] = _X;
+        gate_index["Y"] = _Y;
+        gate_index["Z"] = _Z;
+        gate_index["Sdag"] = _Sdag;
+        gate_index["Tdag"] = _Tdag;
+        gate_index["MeasX"] = _MeasX;
+        gate_index["MeasZ"] = _MeasZ;
+        gate_index["PrepX"] = _PrepX;
+        gate_index["PrepZ"] = _PrepZ;
+        gate_index["Fredkin"] = _Fredkin;
+        gate_index["Rz"] = _Rz;
+        gate_index["All"] = _All;                    
+        
+        
+        }
+        
+
+    void init_gates_as_functions();    
+    void init_critical_path_algo(Function* F);
+    void reset_current_ts_info(Function* F);
+    void print_current_ts_info();
+    void print_vector_TSGates(Function* F);
+    void print_max_critical_info(MaxTSInfo ts);
+    void update_max_critical_info(Function* F);
+    void calc_critical_time(Function* F, qGate qg);        
+    void update_currParallelFunc(TSInfo ts);                
+    void print_currParallelFunc();
+    void print_TSInfo(TSInfo ts);
+    void copy_max_parallel_factor(Function *F);
+
+    void print_qgateArg(qGateArg qg)
+    {
+      errs()<< "Printing QGate Argument:\n";
+      if(qg.argPtr) errs() << "  Name: "<<qg.argPtr->getName()<<"\n";
+      errs() << "  Arg Num: "<<qg.argNum<<"\n"
+	     << "  isUndef: "<<qg.isUndef
+	     << "  isQbit: "<<qg.isQbit
+	     << "  isCbit: "<<qg.isCbit
+	     << "  isPtr: "<<qg.isPtr << "\n"
+	     << "  Value or Index: "<<qg.valOrIndex<<"\n";
+    }                    
+    
+    void CountCriticalFunctionResources (Function *F);
+    
+    bool runOnModule (Module &M);
+    
+    
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();  
+      AU.addRequired<CallGraph>();    
+    }
+    
+  }; // End of struct CriticalResourceCount
+} // End of anonymous namespace
+
+
+
+char CriticalResourceCount::ID = 0;
+static RegisterPass<CriticalResourceCount> X("CriticalResourceCount", "Critical Resource Counter Pass");
+
+void CriticalResourceCount::getFunctionArguments(Function* F)
+{
+  for(Function::arg_iterator ait=F->arg_begin();ait!=F->arg_end();++ait)
+    {    
+      //if(ait) errs() << "Argument: "<<ait->getName()<< " ";
+
+      string argName = (ait->getName()).str();
+      Type* argType = ait->getType();
+      unsigned int argNum=ait->getArgNo();         
+
+      qGateArg tmpQArg;
+      tmpQArg.argPtr = ait;
+      tmpQArg.argNum = argNum;
+
+      if(argType->isPointerTy()){
+	tmpQArg.isPtr = true;
+
+	Type *elementType = argType->getPointerElementType();
+	if (elementType->isIntegerTy(16)){ //qbit*
+	  tmpQArg.isQbit = true;
+	  vectQbit.push_back(ait);
+	}
+	else if (elementType->isIntegerTy(1)){ //cbit*
+	  tmpQArg.isCbit = true;
+	  vectQbit.push_back(ait);
+	}
+      }
+      else if (argType->isIntegerTy(16)){ //qbit
+	tmpQArg.isQbit = true;
+	vectQbit.push_back(ait);
+      }
+      else if (argType->isIntegerTy(1)){ //cbit
+	tmpQArg.isCbit = true;
+	vectQbit.push_back(ait);
+      }
+      
+    }
+}
+
+bool CriticalResourceCount::backtraceOperand(Value* opd, int opOrIndex)
+{
+  if(opOrIndex == 0) //backtrace for operand
+    {
+      //search for opd in qbit/cbit vector
+      vector<Value*>::iterator vIter=find(vectQbit.begin(),vectQbit.end(),opd);
+      if(vIter != vectQbit.end()){
+	tmpDepQbit[0].argPtr = opd;
+	
+	return true;
+      }
+      
+      if(btCount>MAX_BT_COUNT)
+	return false;
+      
+      if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(opd))
+	{
+
+	  if(GEPI->hasAllConstantIndices()){
+	    Instruction* pInst = dyn_cast<Instruction>(opd);
+	    unsigned numOps = pInst->getNumOperands();
+
+	    backtraceOperand(pInst->getOperand(0),0);
+	    
+	    //NOTE: getelemptr instruction can have multiple indices. Currently considering last operand as desired index for qubit. Check this reasoning. 
+	    if(ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(numOps-1))){
+	      if(tmpDepQbit.size()==1){
+		tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+	      }
+	    }
+	  }
+	  
+	  else if(GEPI->hasIndices()){
+	    
+	    Instruction* pInst = dyn_cast<Instruction>(opd);
+	    unsigned numOps = pInst->getNumOperands();
+	    backtraceOperand(pInst->getOperand(0),0);
+
+	    if(tmpDepQbit[0].isQbit && !(tmpDepQbit[0].isPtr)){     
+	      //NOTE: getelemptr instruction can have multiple indices. consider last operand as desired index for qubit. Check if this is true for all.
+	      backtraceOperand(pInst->getOperand(numOps-1),1);
+	      
+	    }
+	  }
+	  else{	    
+	    Instruction* pInst = dyn_cast<Instruction>(opd);
+	    unsigned numOps = pInst->getNumOperands();
+	    for(unsigned iop=0;iop<numOps;iop++){
+	      backtraceOperand(pInst->getOperand(iop),0);
+	    }
+	  }
+	  return true;
+	}
+      
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	unsigned numOps = pInst->getNumOperands();
+	for(unsigned iop=0;iop<numOps;iop++){
+	  btCount++;
+	  backtraceOperand(pInst->getOperand(iop),0);
+	  btCount--;
+	}
+	return true;
+      }
+      else{
+	return true;
+      }
+    }
+  else if(opOrIndex == 0){ //opOrIndex == 1; i.e. Backtracing for Index    
+    if(btCount>MAX_BT_COUNT) //prevent infinite backtracing
+      return true;
+
+    if(ConstantInt *CI = dyn_cast<ConstantInt>(opd)){
+      tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+      return true;
+    }      
+
+    if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+      unsigned numOps = pInst->getNumOperands();
+      for(unsigned iop=0;iop<numOps;iop++){
+	btCount++;
+	backtraceOperand(pInst->getOperand(iop),1);
+	btCount--;
+      }
+    }
+
+  }
+  else{ //opOrIndex == 2: backtracing to call inst MeasZ
+    if(CallInst *endCI = dyn_cast<CallInst>(opd)){
+      if(endCI->getCalledFunction()->getName().find("llvm.Meas") != string::npos){
+	tmpDepQbit[0].argPtr = opd;
+
+	return true;
+      }
+      else{
+	if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	  unsigned numOps = pInst->getNumOperands();
+	  bool foundOne=false;
+	  for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	    btCount++;
+	    foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+	    btCount--;
+	  }
+	  return foundOne;
+	}
+      }
+    }
+    else{
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	unsigned numOps = pInst->getNumOperands();
+	bool foundOne=false;
+	for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	  btCount++;
+	  foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+	  btCount--;
+	}
+	return foundOne;
+      }
+    }
+  }
+  return false;
+}
+
+
+void CriticalResourceCount::analyzeAllocInst(Function* F, Instruction* pInst){
+  if (AllocaInst *AI = dyn_cast<AllocaInst>(pInst)) {
+    Type *allocatedType = AI->getAllocatedType();
+    
+    if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+      qGateArg tmpQArg;
+      
+      Type *elementType = arrayType->getElementType();
+      uint64_t arraySize = arrayType->getNumElements();
+      if (elementType->isIntegerTy(16)){
+	vectQbit.push_back(AI);
+	tmpQArg.isQbit = true;
+	tmpQArg.argPtr = AI;
+	tmpQArg.valOrIndex = arraySize;
+      }
+      
+      if (elementType->isIntegerTy(1)){
+	vectQbit.push_back(AI); //Cbit added here
+	tmpQArg.isCbit = true;
+	tmpQArg.argPtr = AI;
+	tmpQArg.valOrIndex = arraySize;
+      }
+    }
+  }
+}
+
+
+void CriticalResourceCount::init_critical_path_algo(Function* F){
+
+  MaxTSInfo structMaxInfo;
+  TSInfo vectGateInfo; //initialize an entry in the function map
+  funcParallelFactor[F->getName().str()] = vectGateInfo;
+
+  currTimeStep.clear(); //initialize critical time steps   
+
+  curr_parallel_ts.clear();
+
+  maxParallelFactor.timesteps = 0;   //initialize critical time steps
+
+  for(int i=0; i< NUM_QGATES ; i++){
+    maxParallelFactor.parallel_gates[i] = 0;
+    structMaxInfo.parallel_gates[i] = 0;
+  }
+  funcMaxParallelFactor[F->getName().str()] = structMaxInfo;
+  currParallelFunc.clear();
+}
+
+
+void CriticalResourceCount::print_vector_TSGates(Function* F){
+  map<string, TSInfo>::iterator fp = funcParallelFactor.find(F->getName().str());
+  errs() << "Printing function map \n";
+  for(vector<TSParGateInfo>::iterator vit = (*fp).second.gates.begin(); vit!=(*fp).second.gates.end(); ++vit){
+    for(int i=0; i< NUM_QGATES ; i++){
+      errs() << (*vit).parallel_gates[i] << " ";
+    }
+    errs() << "\n";
+  }
+}
+
+void CriticalResourceCount::print_currParallelFunc(){
+  errs() << "currParallelFunc: ";
+  for(vector<string>::iterator vit = currParallelFunc.begin(); vit!=currParallelFunc.end(); ++vit){
+      errs() << (*vit) << " ";
+    }
+    errs() << "\n";
+  }
+
+void CriticalResourceCount::reset_current_ts_info(Function* F){ //current timestep info
+
+  //clear arguments being operated upon
+  currTimeStep.clear(); //initialize critical time steps
+
+  curr_parallel_ts.clear(); //reset current timestep info
+
+  if(debugCritDataPath){
+    print_currParallelFunc();
+    errs() << " --------------- \n";
+  }
+
+  currParallelFunc.clear();
+
+  if(debugCritDataPath)
+    print_vector_TSGates(F);
+  
+}
+
+void CriticalResourceCount::print_current_ts_info(){ //current timestep info
+  errs() << "\n Current Critical Time Steps = "<<maxParallelFactor.timesteps << " ";
+  for(vector<string>::iterator vit = currParallelFunc.begin(); vit!=currParallelFunc.end(); ++vit)
+      errs() << (*vit) << " ";
+    errs() << "\n" ;
+  
+}
+
+void CriticalResourceCount::print_max_critical_info(MaxTSInfo ts){ //max timestep info
+    errs() << "MAX Critical Time Steps = "<<ts.timesteps << "\n";
+    errs() << "MAX Parallelism Factors: \n";
+    for(int i=0; i<NUM_QGATES; i++)
+      errs() << "\t" << gate_name[i] << ": " << ts.parallel_gates[i] << "\n";
+    errs() << "\n" ;
+}
+
+void CriticalResourceCount::print_TSInfo(TSInfo ts){
+    for(vector<TSParGateInfo>::iterator printIt = ts.gates.begin(); printIt!=ts.gates.end(); ++ printIt)
+      {
+	for(int print_var = 0; print_var < NUM_QGATES; print_var++)
+	  errs() << (*printIt).parallel_gates[print_var] << " ";
+	errs() << "\n";
+      }
+}
+
+void CriticalResourceCount::update_max_critical_info(Function* F){ //max timestep info
+
+  if(currParallelFunc.size()>1)
+  {
+
+    //add all parallel timesteps first
+    TSInfo sum_info; 
+    
+    sum_info.timesteps = 0;
+    sum_info.gates.clear();
+    
+    for(vector<string>::iterator vit=currParallelFunc.begin(); vit!=currParallelFunc.end(); ++vit){
+      map<string,TSInfo>::iterator tsIter = funcParallelFactor.find(*vit);
+      if(debugCritDataPath)
+	errs() << "Timesteps of function: " << (*vit) << " are " << (*tsIter).second.timesteps << "\n";
+      if((*tsIter).second.timesteps > sum_info.timesteps)
+	sum_info.timesteps = (*tsIter).second.timesteps;
+      
+      unsigned int vsize = sum_info.gates.size();
+      unsigned int fnsize = (*tsIter).second.gates.size();
+      
+      //errs() << "vsize = "<<vsize<< " fnSize = "<<fnsize <<"\n";
+
+      if(vsize<fnsize){
+	for(unsigned int j=0; j<vsize;j++){
+	  for(int k=0;k<NUM_QGATES;k++)
+	    sum_info.gates[j].parallel_gates[k] += (*tsIter).second.gates[j].parallel_gates[k];
+	}
+
+	for(unsigned int j=vsize;j<fnsize;j++){
+	  sum_info.gates.push_back((*tsIter).second.gates[j]);
+	}
+      }
+      else{
+	for(unsigned int j=0; j<fnsize;j++){
+	  for(int k=0;k<NUM_QGATES;k++)
+	    sum_info.gates[j].parallel_gates[k] += (*tsIter).second.gates[j].parallel_gates[k];
+	}	
+      }
+    }
+
+    //save sum_info into the vector<TSParGateInfo>
+    if(F->getName() != "main"){ //do not save for main
+      map<string,TSInfo>::iterator fnIter = funcParallelFactor.find(F->getName().str());
+      //append sum_info.gates to fnIter.second.gates
+      (*fnIter).second.gates.insert((*fnIter).second.gates.end(),sum_info.gates.begin(), sum_info.gates.end());
+    
+    }
+    
+    //compare maxParallelFactor with the data in sum_info
+    for(vector<TSParGateInfo>::iterator gateIter = sum_info.gates.begin(); gateIter!= sum_info.gates.end(); ++gateIter){
+      for(int i=0; i<NUM_QGATES; i++){            
+	if((*gateIter).parallel_gates[i] > maxParallelFactor.parallel_gates[i])
+	  maxParallelFactor.parallel_gates[i] = (*gateIter).parallel_gates[i];        
+      }        
+    }
+    
+    //update critical timestep info
+    maxParallelFactor.timesteps += sum_info.timesteps;
+  }
+  else{
+    //directly compare maxParallelFactor with the timesteps in function in currParallelFunc
+
+    map<string,TSInfo>::iterator tsIter;
+    
+    string fStr = currParallelFunc.front();
+    tsIter = funcParallelFactor.find(fStr);
+
+    if(debugCritDataPath)
+      errs() << "Timesteps of function: " << fStr << " are " << (*tsIter).second.timesteps << "\n";
+
+    //save TSInfo
+    if(F->getName() != "main"){ //do not save for main
+      map<string,TSInfo>::iterator fnIter = funcParallelFactor.find(F->getName().str());
+      //append sum_info.gates to fnIter.second.gates
+      (*fnIter).second.gates.insert((*fnIter).second.gates.end(),(*tsIter).second.gates.begin(), (*tsIter).second.gates.end());    
+    }
+    
+    //compare maxParallelFactor with the data in sum_info
+    map<string, MaxTSInfo>::iterator maxIter = funcMaxParallelFactor.find(fStr);
+
+    for(int i=0; i<NUM_QGATES; i++){            
+      if((*maxIter).second.parallel_gates[i] > maxParallelFactor.parallel_gates[i])
+	maxParallelFactor.parallel_gates[i] = (*maxIter).second.parallel_gates[i]; 
+    }        
+    
+    //update critical timestep info
+    maxParallelFactor.timesteps += (*tsIter).second.timesteps;    
+  }  
+}
+
+void CriticalResourceCount::calc_critical_time(Function* F, qGate qg){
+  string fname = qg.qFunc->getName();
+  
+  //check each arg with args in currTimeStep
+  bool is_dependency = false;
+  
+  for(vector<qArgInfo>::iterator vit = currTimeStep.begin(); (vit!=currTimeStep.end()) && (!is_dependency); ++vit)
+    {
+      for(int i = 0; i<qg.numArgs; i++){
+	if((*vit).name == qg.args[i].name) //var name matches
+	  {
+	    if((*vit).index == -1 || qg.args[i].index == -1){ //argument is a ptr, so pessimistic checking
+	      is_dependency = true; 	      
+	      break;
+	    }
+	    else{
+	      //check for index match
+	      if((*vit).index == qg.args[i].index)
+		{
+		  is_dependency = true;
+		  break;
+		} //index matches
+	    }
+	  } //var name match
+      } //for all arguments 
+    } // for currTimeStep::iterator
+  
+  if(is_dependency){ //process this time step and advance
+
+    update_max_critical_info(F);
+    
+    if(debugCritDataPath){
+      print_max_critical_info(maxParallelFactor);
+    }
+        
+    //clear info for current timestep
+    reset_current_ts_info(F);
+  }    
+  
+  //Add args to curr args
+  for(int i = 0; i<qg.numArgs; i++){
+    currTimeStep.push_back(qg.args[i]);
+  }            
+  
+  //Add timestreps of function to list of timesteps
+  //Info for this function must already be present in the func_parallelism map        
+  map<string, TSInfo>::iterator fIter = funcParallelFactor.find(fname); 
+  curr_parallel_ts.push_back((*fIter).second.timesteps);
+  
+  //Add function to currParallelFunc
+  currParallelFunc.push_back(fname);
+}
+
+
+
+void CriticalResourceCount::analyzeCallInst(Function* F, Instruction* pInst){
+  if(CallInst *CI = dyn_cast<CallInst>(pInst))
+    {      
+      if(debugCritDataPath)
+	errs() << "Call inst: " << CI->getCalledFunction()->getName() << "\n";
+
+      if(CI->getCalledFunction()->getName() == "store_cbit"){	//trace return values
+	return;
+      }
+
+      vector<qGateArg> allDepQbit;                                  
+      
+      bool tracked_all_operands = true;
+      
+      for(unsigned iop=0;iop<CI->getNumArgOperands();iop++){
+	tmpDepQbit.clear();
+	
+	qGateArg tmpQGateArg;
+	btCount=0;
+	
+	tmpQGateArg.argNum = iop;
+	
+	
+	if(isa<UndefValue>(CI->getArgOperand(iop))){
+	  errs() << "WARNING: LLVM IR code has UNDEF values. \n";
+	  tmpQGateArg.isUndef = true;	
+	  //exit(1);
+	}
+	
+	Type* argType = CI->getArgOperand(iop)->getType();
+	if(argType->isPointerTy()){
+	  tmpQGateArg.isPtr = true;
+	  Type *argElemType = argType->getPointerElementType();
+	  if(argElemType->isIntegerTy(16))
+	    tmpQGateArg.isQbit = true;
+	  if(argElemType->isIntegerTy(1))
+	    tmpQGateArg.isCbit = true;
+	}
+	else if(argType->isIntegerTy(16)){
+	  tmpQGateArg.isQbit = true;
+	  tmpQGateArg.valOrIndex = 0;	 
+	}	  	
+	else if(argType->isIntegerTy(1)){
+	  tmpQGateArg.isCbit = true;
+	  tmpQGateArg.valOrIndex = 0;	 
+	}	  	
+	
+        if(tmpQGateArg.isQbit || tmpQGateArg.isCbit){
+            tmpDepQbit.push_back(tmpQGateArg);	
+            tracked_all_operands &= backtraceOperand(CI->getArgOperand(iop),0);
+	}
+
+        if(tmpDepQbit.size()>0){	  
+	  allDepQbit.push_back(tmpDepQbit[0]);
+	  assert(tmpDepQbit.size() == 1 && "tmpDepQbit SIZE GT 1");
+	  tmpDepQbit.clear();
+	}
+	
+      }
+      
+      if(allDepQbit.size() > 0){
+	if(debugCritDataPath)
+	  {
+	    errs() << "\nCall inst: " << CI->getCalledFunction()->getName();	    
+	    errs() << ": Found all arguments: ";       
+	    for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+	      if(allDepQbit[vb].argPtr)
+		errs() << allDepQbit[vb].argPtr->getName() <<" Index: ";
+                                
+	      //else
+		errs() << allDepQbit[vb].valOrIndex <<" ";
+	    }
+	    errs()<<"\n";
+	    
+	  }
+          
+       string fname =  CI->getCalledFunction()->getName();  
+       qGate thisGate;
+       thisGate.qFunc =  CI->getCalledFunction();
+       for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+            if(allDepQbit[vb].argPtr){
+                qGateArg param =  allDepQbit[vb];       
+                thisGate.args[thisGate.numArgs].name = param.argPtr->getName();
+		if(!param.isPtr)
+		  thisGate.args[thisGate.numArgs].index = param.valOrIndex;
+                thisGate.numArgs++;
+	    }
+       }
+       
+       calc_critical_time(F,thisGate);       
+
+      }    
+      allDepQbit.erase(allDepQbit.begin(),allDepQbit.end());
+    }
+}
+
+void CriticalResourceCount::copy_max_parallel_factor(Function *F){
+  map<string, MaxTSInfo>::iterator fparIter = funcMaxParallelFactor.find(F->getName().str());
+  (*fparIter).second.timesteps = maxParallelFactor.timesteps;
+  for(int i=0;i<NUM_QGATES;i++)
+    {
+      (*fparIter).second.parallel_gates[i] = maxParallelFactor.parallel_gates[i];
+    }
+}
+
+void CriticalResourceCount::CountCriticalFunctionResources (Function *F) {
+      // Traverse instruction by instruction
+  init_critical_path_algo(F);
+  
+  
+  for (inst_iterator I = inst_begin(*F), E = inst_end(*F); I != E; ++I) {
+    Instruction *Inst = &*I;                            // Grab pointer to instruction reference
+    analyzeAllocInst(F,Inst);          
+    analyzeCallInst(F,Inst);	
+  }
+  
+  update_max_critical_info(F);
+  print_max_critical_info(maxParallelFactor);  
+
+  //copy maxParallelFactor into funcMaxParallelFactor
+  copy_max_parallel_factor(F);
+  
+  map<string, TSInfo>::iterator fparIter = funcParallelFactor.find(F->getName().str());
+  (*fparIter).second.timesteps = maxParallelFactor.timesteps;
+
+  reset_current_ts_info(F);
+  
+}
+
+
+void CriticalResourceCount::init_gates_as_functions(){
+  for(int  i =0; i< NUM_QGATES ; i++){
+    string gName = gate_name[i];
+    string fName = "llvm.";
+    fName.append(gName);
+
+    TSInfo tmp_info;
+    MaxTSInfo tmp_max_info;
+
+    tmp_info.timesteps = 1;
+    tmp_max_info.timesteps = 1;
+
+    TSParGateInfo tmp_gate_info;
+    for(int  k=0; k< NUM_QGATES ; k++){
+      tmp_gate_info.parallel_gates[k] = 0;
+      tmp_max_info.parallel_gates[k] = 0;
+    }
+    tmp_gate_info.parallel_gates[i] = 1;
+    tmp_gate_info.parallel_gates[_All] = 1;
+
+    tmp_max_info.parallel_gates[i] = 1;
+    tmp_max_info.parallel_gates[_All] = 1;
+    
+    tmp_info.gates.push_back(tmp_gate_info);
+
+    funcParallelFactor[fName] = tmp_info;
+    funcMaxParallelFactor[fName] = tmp_max_info;
+    
+  }
+}
+
+
+bool CriticalResourceCount::runOnModule (Module &M) {
+  init_gate_names();
+  init_gates_as_functions();
+  
+  // iterate over all functions, and over all instructions in those functions
+  CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+  
+  //Post-order
+  for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode), E = scc_end(rootNode); sccIb != E; ++sccIb) {
+    const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+    for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(), E = nextSCC.end(); nsccI != E; ++nsccI) {
+      Function *F = (*nsccI)->getFunction();	  
+            
+      if(F && !F->isDeclaration()){
+      errs() << "\nFunction: " << F->getName() << "\n";      
+
+      getFunctionArguments(F);
+      
+      // count the critical resources for this function
+      CountCriticalFunctionResources(F);
+
+    }
+      else{
+	    if(debugCritDataPath)
+	      errs() << "WARNING: Ignoring external node or dummy function.\n";
+	  }
+    }
+  }  
+  return false;
+} // End runOnModule
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/DynCriticalPath.cpp llvm/lib/Transforms/Scaffold/DynCriticalPath.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/DynCriticalPath.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/DynCriticalPath.cpp	2017-10-12 11:09:31.090119578 +0800
@@ -0,0 +1,276 @@
+//===- DynCritPath.cpp - Instrument binary to generate flat qasm at runtime -------------------===//
+//
+//                     The LLVM Scaffold Compiler Infrastructure
+//
+// This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#include "llvm/Pass.h"
+#include "llvm/Module.h"
+#include "llvm/Function.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Constants.h"
+#include "llvm/Intrinsics.h"
+#include "llvm/Support/InstVisitor.h" 
+#include "llvm/Support/InstIterator.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Instructions.h"
+#include <map>
+
+using namespace llvm;
+using namespace std;
+
+
+#define _CNOT 0
+#define _Fredkin 1
+#define _H 2
+#define _MeasX 3
+#define _MeasZ 4
+#define _PrepX 5
+#define _PrepZ 6
+#define _S 7
+#define _T 8
+#define _Sdag 9
+#define _Tdag 10
+#define _Toffoli 11
+#define _X 12
+#define _Y 13
+#define _Z 14
+#define _Rz 15
+
+
+bool debugDynCritPath = false;
+
+namespace {
+
+  struct DynCritPath : public ModulePass, public InstVisitor<DynCritPath> {
+    friend class InstVisitor<DynCritPath>;
+
+    static char ID;  // Pass identification, replacement for typeid
+
+    //external instrumentation functions
+    Function* dcpGate; 
+    Function* dcpGate2;
+    Function* dcpGate3;
+    Function* dcpQbitInit;
+    Function* dcpAncReset;
+    Function* dcpSumm;
+    Function* dcpInitAlgo;
+
+    map<AllocaInst*, int> mapAllocaInst;
+    //bool isMainFunction;
+
+    vector<Instruction*> vInstRemove;
+
+    DynCritPath() : ModulePass(ID) {  }
+
+    void instrumentInst(CallInst* CI, int id){
+
+	SmallVector<Value*, 16> call_args;
+	Value* intArg = ConstantInt::get(Type::getInt32Ty(CI->getContext()),id);	
+	call_args.push_back(intArg);
+
+	Value* qbitArg = CI->getArgOperand(0);
+	call_args.push_back(qbitArg);
+
+	if(id==0){ //CNOT
+	  Value* qbitArg2 = CI->getArgOperand(1);
+	  call_args.push_back(qbitArg2);
+	  CallInst::Create(dcpGate2,call_args,"",(Instruction*)CI);
+	}
+	else if(id==1 || id==11){ //Fredkin or Toffoli
+	  Value* qbitArg2 = CI->getArgOperand(1);
+	  call_args.push_back(qbitArg2);
+	  Value* qbitArg3 = CI->getArgOperand(2);
+	  call_args.push_back(qbitArg3);
+	  CallInst::Create(dcpGate3,call_args,"",(Instruction*)CI);
+	}
+	else
+	  CallInst::Create(dcpGate,call_args,"",(Instruction*)CI);	
+
+	if(id!=3 && id!=4)
+	  vInstRemove.push_back((Instruction*)CI);
+    }
+
+
+    bool analyzeAllocInst(Instruction* I) {
+      if(AllocaInst *AI = dyn_cast<AllocaInst>(I)){
+
+	//errs() << "AllocInst = " << *AI << "\n";
+	
+	Type *allocatedType = AI->getAllocatedType();
+	
+	if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+	  
+	  Type *elementType = arrayType->getElementType();
+	  uint64_t arraySize = arrayType->getNumElements();
+	  if (elementType->isIntegerTy(16)){
+	    if(debugDynCritPath)
+	      errs() << "New QBit Allocation Found: " << AI->getName() <<"\n";
+	    
+	    mapAllocaInst[AI] = arraySize;
+	  }	  
+	}
+	return true;
+      }
+      else return false;
+      
+    } // analyzeAllocInst
+      
+
+    void initializeQbits(Instruction* CI){
+
+      for(map<AllocaInst*, int>::iterator mit = mapAllocaInst.begin(); mit!=mapAllocaInst.end(); ++mit){
+	int arrSize = (*mit).second;
+
+	//generate getelementptr inst
+	SmallVector<Value*,16> idxVect;
+	idxVect.push_back(ConstantInt::get(Type::getInt32Ty(CI->getContext()),0));
+	idxVect.push_back(ConstantInt::get(Type::getInt32Ty(CI->getContext()),0));
+	GetElementPtrInst *arrPtr = GetElementPtrInst::Create((Value*)(*mit).first, idxVect, "", (Instruction*) CI);
+
+	//generate call inst to external store function
+	SmallVector<Value*,16> call_args;
+	call_args.push_back(arrPtr);
+	Value* intArg = ConstantInt::get(Type::getInt32Ty(CI->getContext()),arrSize);	
+	call_args.push_back(intArg);
+	CallInst::Create(dcpQbitInit,call_args,"",(Instruction*)CI);
+      }
+      //mapAllocaInst.clear();
+    }
+
+    void resetAncillaData(Function* F){
+      BasicBlock* myBB = &(F->back());
+      TerminatorInst *BBTerm = myBB->getTerminator();
+
+      for(map<AllocaInst*, int>::iterator mit = mapAllocaInst.begin(); mit!=mapAllocaInst.end(); ++mit){
+	int arrSize = (*mit).second;
+
+	//generate getelementptr inst
+	SmallVector<Value*,16> idxVect;
+	idxVect.push_back(ConstantInt::get(Type::getInt32Ty(BBTerm->getContext()),0));
+	idxVect.push_back(ConstantInt::get(Type::getInt32Ty(BBTerm->getContext()),0));
+	GetElementPtrInst *arrPtr = GetElementPtrInst::Create((Value*)(*mit).first, idxVect, "", (Instruction*)BBTerm);
+
+	//generate call inst to external store function
+	SmallVector<Value*,16> call_args;
+	call_args.push_back(arrPtr);
+	Value* intArg = ConstantInt::get(Type::getInt32Ty(BBTerm->getContext()),arrSize);	
+	call_args.push_back(intArg);
+	CallInst::Create(dcpAncReset,call_args,"",(Instruction*)BBTerm);
+      }
+      mapAllocaInst.clear();
+
+    }
+
+    void visitCallInst(CallInst &I) {
+      CallInst *CI = dyn_cast<CallInst>(&I);
+
+      //errs() << "CallInst = " << *CI << "\n";
+
+      Function* CF = CI->getCalledFunction();
+
+      int gateIndex = -1;
+      bool isIntrinsicQuantum = true;
+
+      if(CF->isIntrinsic()){
+	  if(CF->getIntrinsicID() == Intrinsic::CNOT) gateIndex = _CNOT;
+	  else if(CF->getIntrinsicID() == Intrinsic::Fredkin) gateIndex = _Fredkin;
+	  else if(CF->getIntrinsicID() == Intrinsic::H) gateIndex = _H;
+	  else if(CF->getIntrinsicID() == Intrinsic::MeasX) { gateIndex = _MeasX; }
+	  else if(CF->getIntrinsicID() == Intrinsic::MeasZ) { gateIndex = _MeasZ; }
+	  else if(CF->getIntrinsicID() == Intrinsic::PrepX) gateIndex = _PrepX;
+	  else if(CF->getIntrinsicID() == Intrinsic::PrepZ) gateIndex = _PrepZ;
+	  else if(CF->getIntrinsicID() == Intrinsic::Rz) gateIndex = _Rz;
+	  else if(CF->getIntrinsicID() == Intrinsic::S) gateIndex = _S;
+	  else if(CF->getIntrinsicID() == Intrinsic::T) gateIndex = _T;
+	  else if(CF->getIntrinsicID() == Intrinsic::Sdag) gateIndex = _Sdag;
+	  else if(CF->getIntrinsicID() == Intrinsic::Tdag) gateIndex = _Tdag;
+	  else if(CF->getIntrinsicID() == Intrinsic::Toffoli) gateIndex = _Toffoli;
+	  else if(CF->getIntrinsicID() == Intrinsic::X) gateIndex = _X;
+	  else if(CF->getIntrinsicID() == Intrinsic::Y) gateIndex = _Y;
+	  else if(CF->getIntrinsicID() == Intrinsic::Z) gateIndex = _Z;
+	  else { isIntrinsicQuantum = false; }
+      }
+      else{
+	isIntrinsicQuantum = false;
+      }
+            
+      if(isIntrinsicQuantum){
+	instrumentInst(CI, gateIndex);
+      }
+    }
+        
+    bool runOnModule(Module &M){
+
+      dcpGate = cast<Function>(M.getOrInsertFunction("dcp_qgate", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), Type::getInt16Ty(M.getContext()), (Type*)0));
+      
+      dcpGate2 = cast<Function>(M.getOrInsertFunction("dcp_qgate2", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), Type::getInt16Ty(M.getContext()), Type::getInt16Ty(M.getContext()), (Type*)0));
+
+      dcpGate3 = cast<Function>(M.getOrInsertFunction("dcp_qgate3", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), Type::getInt16Ty(M.getContext()), Type::getInt16Ty(M.getContext()), Type::getInt16Ty(M.getContext()), (Type*)0));
+
+      dcpQbitInit = cast<Function>(M.getOrInsertFunction("dcp_qbit_init", Type::getVoidTy(M.getContext()), Type::getInt16Ty(M.getContext())->getPointerTo(), Type::getInt32Ty(M.getContext()), (Type*)0));
+
+      dcpAncReset = cast<Function>(M.getOrInsertFunction("dcp_anc_reset", Type::getVoidTy(M.getContext()), Type::getInt16Ty(M.getContext())->getPointerTo(), Type::getInt32Ty(M.getContext()), (Type*)0));
+      
+      dcpSumm = cast<Function>(M.getOrInsertFunction("dcp_summary", Type::getVoidTy(M.getContext()), (Type*)0));
+
+      dcpInitAlgo = cast<Function>(M.getOrInsertFunction("dcp_init_algo", Type::getVoidTy(M.getContext()), (Type*)0));
+        
+      for(Module::iterator F = M.begin(); F!=M.end(); ++F){
+	if(F && !F->isDeclaration()){
+	  //errs() << "Func : " << F->getName() << "\n";	  	  
+
+	  //analyze Alloc Insts first
+	  for(inst_iterator instIb = inst_begin(F); instIb!=inst_end(F); ++instIb){
+	    Instruction* pInst = &*instIb;
+	    bool isAlloc = analyzeAllocInst(pInst);
+	    if(!isAlloc){
+
+	      if(F->getName() == "main")
+	      {
+		  //add call to init_algo
+	        CallInst::Create(dcpInitAlgo,"",pInst);
+	      }
+
+	      //add store functions for alloc insts
+	      initializeQbits(pInst); 
+	      break;
+	    }
+	  }
+
+	  //analyze Call insts now
+	  visit(F);
+	  
+	  //reset data for ancilla qubits to save qubits
+	  resetAncillaData(F);
+
+	  if(F->getName() == "main"){
+	    BasicBlock* myBB = &(F->back());
+	    TerminatorInst *BBTerm = myBB->getTerminator();
+	    
+	    CallInst::Create(dcpSumm,"",(Instruction*)BBTerm);
+	  }   	
+	}      
+      }
+      //errs() << "Removing instructions:\n";
+      for(vector<Instruction*>::iterator iterInst = vInstRemove.begin(); iterInst != vInstRemove.end(); ++iterInst){
+	//errs() << *(*iterInst) << "\n";
+	(*iterInst)->eraseFromParent();
+      }     
+
+      return true;      
+    }
+    
+    void print(raw_ostream &O, const Module* = 0) const { 
+      errs() << "Instrumented program with blocks for circuit split analysis \n";
+    }  
+  };
+}
+
+char DynCritPath::ID = 0;
+static RegisterPass<DynCritPath>
+X("dyn-critical-path", "Instrument binary for dynamic estimation of critical path");
+  
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/DynGenQASMLoops.cpp llvm/lib/Transforms/Scaffold/DynGenQASMLoops.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/DynGenQASMLoops.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/DynGenQASMLoops.cpp	2017-10-12 11:09:31.090119578 +0800
@@ -0,0 +1,1475 @@
+//===- DynGenQASMLoops.cpp - Generate qasm output with loops -------------------===//
+//
+//                     The LLVM Scaffold Compiler Infrastructure
+//
+// This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#include <sstream>
+#include <iomanip>
+#include "llvm/Argument.h"
+#include "llvm/Pass.h"
+#include "llvm/Module.h"
+#include "llvm/Function.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/SCCIterator.h"
+#include "llvm/ADT/ilist.h"
+#include "llvm/Constants.h"
+#include "llvm/Analysis/DebugInfo.h"
+#include "llvm/IntrinsicInst.h"
+
+using namespace llvm;
+using namespace std;
+
+#define MAX_BT_COUNT 15 //max backtrace allowed - to avoid infinite recursive loops
+#define MAX_QBIT_ARR_DIM 5 //max dimensions allowed for qbit arrays
+#define MAX_FUNCTION_NAME 32
+
+#define _CNOT 0
+#define _Fredkin 1
+#define _H 2
+#define _MeasX 3
+#define _MeasZ 4
+#define _PrepX 5
+#define _PrepZ 6
+#define _S 7
+#define _T 8
+#define _Sdag 9
+#define _Tdag 10
+#define _Toffoli 11
+#define _X 12
+#define _Y 13
+#define _Z 14
+#define _Rz 15
+#define _Ry 17
+#define _Rx 18
+
+
+bool debugDynGenQASMLoops = false;
+
+namespace {
+
+  struct qGateArg{ //arguments to qgate calls
+    Value* argPtr;
+    int argNum;
+    bool isQbit;
+    bool isCbit;
+    bool isUndef;
+    bool isPtr;
+    bool isDouble;
+    int numDim; //number of dimensions of qbit array  
+    int dimSize[MAX_QBIT_ARR_DIM]; //sizes of dimensions of array for qbit declarations OR indices of specific qbit for gate arguments
+    int valOrIndex; //Value if not Qbit, Index if Qbit & not a Ptr
+    double val;
+    //Note: valOrIndex is of type integer. Assumes that quantities will be int in the program.
+    qGateArg(): argPtr(NULL), argNum(-1), isQbit(false), isCbit(false), isUndef(false), isPtr(false), isDouble(false), numDim(0), valOrIndex(-1), val(0.0){ }
+  };
+  
+  struct FnCall{ //datapath sequence
+    Function* func;
+    Value* instPtr;
+    std::vector<qGateArg> qArgs;
+  };  
+  
+  struct DynGenQASMLoops : public ModulePass {
+    static char ID;  // Pass identification, replacement for typeid
+    std::vector<Value*> vectQbit;
+
+    std::vector<qGateArg> tmpDepQbit;
+    std::vector<qGateArg> allDepQbit;
+
+    std::map<Function*, vector<qGateArg> > qbitsInFunc; //qbits in function
+    std::map<Function*, vector<qGateArg> > qbitsInitInFunc; //new qbits declared in function
+    std::map<Function*, vector<qGateArg> > funcArgList; //function arguments
+
+    std::map<Function*, std::vector<FnCall> > mapFunction; //trace sequence of qgate calls
+    std::map<Value*, string> mapInstRtn;    //traces return cbits for Meas Inst
+
+    vector<Instruction*> vRemoveInst;
+    
+    int btCount; //backtrace count
+    string forallStr;
+
+
+    Instruction* FirstInst;
+
+    Function* qasmAllocQbit; //alloc function
+    Function* qasmAllocCbit; //alloc function
+    Function* qasmAllocQbitExec; //alloc function
+    Function* qasmAllocCbitExec; //alloc function
+    Function* qasmHeader; //func decl and opening brace
+    Function* qasmHeaderQbit; //quantum call arg
+    Function* qasmHeaderQbitPtr; //quantum call arg
+    Function* qasmHeaderCbitPtr; //quantum call arg
+    Function* qasmHeaderEnd; //quantum call arg
+    Function* qasmHeaderIntArg;
+    Function* qasmHeaderDoubleArg;
+    Function* qasmFooter; //closing brace
+    Function* qasmQCall; //quantum call
+    Function* qasmQCallArgQbit; //quantum call arg
+    Function* qasmQCallArgQbitPtr; //quantum call arg
+    Function* qasmQCallEnd; //quantum call arg
+    Function* qasmGate;
+    Function* qasmGate2;
+    Function* qasmGate3;
+    Function* qasmRot;
+    Function* qasmCallInstIntArg;
+    Function* qasmCallInstDoubleArg;
+
+    DynGenQASMLoops() : ModulePass(ID) {  }
+
+    bool getQbitArrDim(Type* instType, qGateArg* qa);
+    bool backtraceOperand(Value* opd, int opOrIndex);
+    void analyzeAllocInst(Function* F,Instruction* pinst, AllocaInst* strAlloc);
+
+    void analyzeAllocInstExec(Function* F,Instruction* pinst,AllocaInst* strAlloc);
+
+    void analyzeCallInst(Function* F,Instruction* pinst,AllocaInst* strAlloc);
+    void analyzeInst(Function* F,Instruction* pinst,AllocaInst* strAlloc);
+
+
+    void insertCallToAllocQbit(AllocaInst* AI, int varSize, AllocaInst* strAlloc);
+    void insertCallToAllocCbit(AllocaInst* AI, int varSize, AllocaInst* strAlloc);
+
+    void insertCallToAllocQbitExec(AllocaInst* AI, int varSize, AllocaInst* strAlloc);
+    void insertCallToAllocCbitExec(AllocaInst* AI, int varSize, AllocaInst* strAlloc);
+
+    void insertCallToHeader(Function* F, Instruction* I, AllocaInst* strAlloc);
+    void instrumentIntrinsicInst(CallInst* CI, int id, map<unsigned, pair<string,bool> > nameOfQbit, AllocaInst* strAlloc);
+    void instrumentNonIntrinsicInst(CallInst* CI, map<unsigned, pair<string,bool> > nameOfQbit, AllocaInst* strAlloc);
+
+    void analyzeStoreCbitInst(Function* F, Instruction* pInst);
+    void cleanup_store_cbits(Function* F);
+    void removeIntrinsicQtmExec(Function* F,Instruction* I);
+
+    // run - Print out SCCs in the call graph for the specified module.
+    bool runOnModule(Module &M);
+
+    void printFuncHeader(Function* F);
+
+    string printVarName(StringRef s)
+    {
+      std::string sName = s.str();
+
+      unsigned pos = sName.rfind("..");
+
+      if(pos == sName.length()-2){
+	std::string s1 = sName.substr(0,pos);
+	return s1;
+      }
+      else{
+	unsigned pos1 = sName.rfind(".");
+	
+	if(pos1 == sName.length()-1){
+	  std::string s1 = sName.substr(0,pos1);
+	  return s1;
+	}
+	else{
+	  pos = sName.find(".addr");
+	  std::string s1 = sName.substr(0,pos);     
+	  return s1;
+	}
+      }
+    }
+    
+
+    void print_qgateArg(qGateArg qg)
+    {
+      errs()<< "Printing QGate Argument:\n";
+      if(qg.argPtr) errs() << "  Name: "<<qg.argPtr->getName()<<"\n";
+      errs() << "  Arg Num: "<<qg.argNum<<"\n"
+	     << "  isUndef: "<<qg.isUndef
+	     << "  isQbit: "<<qg.isQbit
+	     << "  isCbit: "<<qg.isCbit
+	     << "  isPtr: "<<qg.isPtr << "\n"
+	     << "  Value or Index: "<<qg.valOrIndex<<"\n"
+	     << "  Num of Dim: "<<qg.numDim<<"\n";
+      for(int i = 0; i<qg.numDim; i++)
+	errs() << "     dimSize ["<<i<<"] = "<<qg.dimSize[i] << "\n";
+    }
+
+    void genQASM(Function* F);
+    void getFunctionArguments(Function* F);
+    
+    void print(raw_ostream &O, const Module* = 0) const { 
+      errs() << "Qbits found: ";
+      for(unsigned int vb=0; vb<vectQbit.size(); vb++){
+	errs() << vectQbit[vb]->getName() <<" ";
+      }
+      errs()<<"\n";      
+    }
+  
+
+    // getAnalysisUsage - This pass requires the CallGraph.
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();
+      AU.addRequired<CallGraph>();
+    }
+  };
+}
+
+char DynGenQASMLoops::ID = 0;
+static RegisterPass<DynGenQASMLoops>
+X("dyn-gen-qasm-with-loops", "Generate QASM output code with repeat statements");
+
+
+void DynGenQASMLoops::insertCallToHeader(Function* F, Instruction* I,  AllocaInst* strAlloc){
+
+  //errs() << "Insert Call to Header \n";
+  string fnName = F->getName().str();
+
+  //arguments are varType, size, name
+  SmallVector<Value*,16> call_args;
+
+  //insert argument1: fnName
+  //Constant *StrConstant = ConstantDataArray::getString(I->getContext(), fnName);
+  //ArrayType* strTy = cast<ArrayType>(StrConstant->getType());
+  //AllocaInst* strAlloc = new AllocaInst(strTy,"",FirstInst);
+  //StoreInst* strInit = new StoreInst(StrConstant,strAlloc,"",FirstInst);
+
+  std::stringstream ss;
+  ss << std::left << std::setw (MAX_FUNCTION_NAME-1) << std::setfill('.') << fnName;
+  Constant *StrConstant = ConstantDataArray::getString(I->getContext(), ss.str());                   
+  new StoreInst(StrConstant,strAlloc,"",FirstInst); 
+  Value* Idx[2];
+  Idx[0] = Constant::getNullValue(Type::getInt32Ty(I->getContext()));
+  Idx[1] = ConstantInt::get(Type::getInt32Ty(I->getContext()),0);
+  GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", FirstInst);
+
+  call_args.push_back(strPtr);
+
+  CallInst::Create(qasmHeader,call_args,"",FirstInst);
+  /*----
+  std::map<unsigned, pair<string,int> > nameOfQbit; // string:isPtr
+  //pair<string, int> encoding:
+  //00 => qbit ptr
+  //01 => qbit
+  //10 => cbit ptr
+  //11 => cbit
+
+  unsigned iop =0;
+
+  //iterate over int and double args
+ //iterate over int and double args and send
+  //errs() << "Insert int/double args \n";
+  //for(unsigned iop=0;iop < CI->getNumArgOperands(); iop++) {
+  for(Function::arg_iterator ait=F->arg_begin();ait!=F->arg_end();++ait) {
+    //Value* arg = CI->getArgOperand(iop);
+    Value* arg = (Value*)(ait);
+    Type* argType = ait->getType();
+    if(argType->isIntegerTy(32)){
+      //errs() << "Inserting Int \n";
+      CallInst::Create(qasmHeaderIntArg, arg, "", FirstInst);
+      //errs() << "Done inserting Int Arg \n";
+    }
+    else if(argType->isDoubleTy()){
+      CallInst::Create(qasmHeaderDoubleArg, arg, "", FirstInst);
+    }
+    else{	          	
+      //errs() << "Inserting Non-Int \n";
+	  if(argType->isPointerTy()){	 
+	    Type *argElemType = argType->getPointerElementType();
+	    if(argElemType->isIntegerTy(16))	     
+	      nameOfQbit[iop++] = make_pair(ait->getName().str(),0);
+
+	    if(argElemType->isIntegerTy(1))
+	      //assert(false && "Should not find cbit as function argument");
+	      nameOfQbit[iop++] = make_pair(ait->getName().str(),2);
+	  }
+	  else if(argType->isIntegerTy(16)){
+	    //errs() << "\t Arg is qbit \n";        
+            nameOfQbit[iop++] = make_pair(ait->getName().str(),1);
+	    //errs() << "\t Arg Name = " << arg->getName() << "\n";
+	  }	  	
+	  else if(argType->isIntegerTy(1)){
+            //assert(false && "Should not find cbit as function argument");
+            nameOfQbit[iop++] = make_pair(ait->getName().str(),3);
+	  }     	            
+    }
+  }
+
+  //send call to print opening brace for function
+  Value* endVal1 = ConstantInt::get(Type::getInt32Ty(I->getContext()),0);
+  CallInst::Create(qasmHeaderEnd, endVal1, "", FirstInst);      
+  
+  //errs() << "Insert qbit args \n";
+
+  //iterate over map and send one argument at a time based on whether ptr or not
+  for (std::map<unsigned, pair<string,int> >::iterator i = nameOfQbit.begin(); i!=nameOfQbit.end(); ++i){
+    
+    string qname = i->second.first;
+    
+    std::stringstream ss;
+    ss << std::left << std::setw (MAX_FUNCTION_NAME-1) << std::setfill('.') << qname;
+    Constant *StrConstant = ConstantDataArray::getString(I->getContext(), ss.str());                  
+    new StoreInst(StrConstant,strAlloc,"",FirstInst);     
+    Value* Idx[2];
+    Idx[0] = Constant::getNullValue(Type::getInt32Ty(I->getContext()));
+    Idx[1] = ConstantInt::get(Type::getInt32Ty(I->getContext()),0);
+  
+    GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", FirstInst);
+    
+    if(i->second.second == 0){ //is ptr to qbit            
+      CallInst::Create(qasmHeaderQbitPtr,strPtr, "", FirstInst);      
+    } //is qbit ptr
+    else if(i->second.second == 2){ //is ptr to cbit            
+      CallInst::Create(qasmHeaderCbitPtr,strPtr, "", FirstInst);      
+    } //is qbit ptr
+    else if(i->second.second == 1){ //is qbit
+      //SmallVector<Value*,16> call_args;
+      //call_args.push_back(strPtr);
+      
+      //Value* qbitArg = CI->getOperand(i->first);
+      //call_args.push_back(qbitArg);
+      CallInst::Create(qasmHeaderQbit,strPtr, "", FirstInst);      
+    }
+
+    else if(i->second.second == 3){ //is cbit
+      //SmallVector<Value*,16> call_args;
+      //call_args.push_back(strPtr);
+      
+      //Value* qbitArg = CI->getOperand(i->first);
+      //call_args.push_back(qbitArg);
+      //CallInst::Create(qasmHeaderQbit,call_args, "", CI);
+    }
+
+  } // end of map iterator
+  ---*/
+ // send call_end
+  Value* endVal2 = ConstantInt::get(Type::getInt32Ty(I->getContext()),1);
+  CallInst::Create(qasmHeaderEnd, endVal2, "", FirstInst);      
+
+}
+
+bool DynGenQASMLoops::backtraceOperand(Value* opd, int opOrIndex)
+{
+  bool foundOne = false;
+      //search for opd in qbit/cbit vector
+      std::vector<Value*>::iterator vIter=std::find(vectQbit.begin(),vectQbit.end(),opd);
+      if(vIter != vectQbit.end()){
+	if(debugDynGenQASMLoops)
+	  errs()<<"Found qubit associated: "<< opd->getName() << "\n";
+	
+	tmpDepQbit[0].argPtr = opd;
+	
+	return true;
+      }
+      
+      if(btCount>MAX_BT_COUNT)
+	return false;
+        
+      if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(opd))
+	{
+	  //if(debugDynGenQASMLoops)
+	  //errs() << "Get Elem Ptr Inst Found: " << *GEPI <<"\n";
+	  foundOne = backtraceOperand(GEPI->getPointerOperand(),0);
+	  
+	}
+      else if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	//errs() << "In backtrace. Inst = " << *pInst << "\n";
+	unsigned numOps = pInst->getNumOperands();
+	//bool foundOne = false;
+	for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	  btCount++;
+	  foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),0);
+	  //errs() << "Found one = " <<foundOne << "\n";
+	  btCount--;
+	}
+	//errs() << "Going back\n";
+	return foundOne;
+      }
+      else{
+	//if(debugDynGenQASMLoops)
+	//errs() << "Ending Recursion\n";
+	return false;
+      }        
+      return foundOne;
+}
+
+void DynGenQASMLoops::insertCallToAllocQbit(AllocaInst* AI, int varSize, AllocaInst* strAlloc){
+ 
+  assert(FirstInst != NULL && "NULL FirstInst");
+
+  //arguments are qbit array, size, name
+  SmallVector<Value*,16> call_args;
+
+  //insert argument1: qbit array
+  //generate getelementptr inst
+  SmallVector<Value*,16> idxVect;
+  idxVect.push_back(ConstantInt::get(Type::getInt32Ty(AI->getContext()),0));
+  idxVect.push_back(ConstantInt::get(Type::getInt32Ty(AI->getContext()),0));
+  GetElementPtrInst *arrPtr = GetElementPtrInst::Create((Value*)AI, idxVect, "", FirstInst);
+  
+  call_args.push_back(arrPtr);
+
+  //insert argument2: varSize
+  Value* arg2 = ConstantInt::get(Type::getInt32Ty(AI->getContext()),varSize);
+  call_args.push_back(arg2);
+
+  //insert argument3: varName
+  //Constant *StrConstant = ConstantDataArray::getString(AI->getContext(), AI->getName().str());
+  //ArrayType* strTy = cast<ArrayType>(StrConstant->getType());
+  //AllocaInst* strAlloc = new AllocaInst(strTy,"",FirstInst);
+  //StoreInst* strInit = new StoreInst(StrConstant,strAlloc,"",FirstInst);
+
+  std::stringstream ss;
+  ss << std::left << std::setw (MAX_FUNCTION_NAME-1) << std::setfill('.') << AI->getName().str();
+  Constant *StrConstant = ConstantDataArray::getString(AI->getContext(), ss.str());                  
+  new StoreInst(StrConstant,strAlloc,"",FirstInst); 
+  Value* Idx[2];
+  Idx[0] = Constant::getNullValue(Type::getInt32Ty(AI->getContext()));
+  Idx[1] = ConstantInt::get(Type::getInt32Ty(AI->getContext()),0);
+  
+  GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", FirstInst);
+
+  call_args.push_back(strPtr);
+
+  CallInst::Create(qasmAllocQbit,call_args,"",FirstInst);
+}
+
+void DynGenQASMLoops::insertCallToAllocCbit(AllocaInst* AI, int varSize,AllocaInst* strAlloc){
+ 
+  assert(FirstInst != NULL && "NULL FirstInst");
+
+  //arguments are qbit array, size, name
+  SmallVector<Value*,16> call_args;
+
+  //insert argument1: varSize
+  Value* arg2 = ConstantInt::get(Type::getInt32Ty(AI->getContext()),varSize);
+  call_args.push_back(arg2);
+
+  //insert argument2: varName
+  //Constant *StrConstant = ConstantDataArray::getString(AI->getContext(), AI->getName().str());
+  //ArrayType* strTy = cast<ArrayType>(StrConstant->getType());
+  //AllocaInst* strAlloc = new AllocaInst(strTy,"",FirstInst);
+  //StoreInst* strInit = new StoreInst(StrConstant,strAlloc,"",FirstInst);
+
+  std::stringstream ss;
+  ss << std::left << std::setw (MAX_FUNCTION_NAME-1) << std::setfill('.') << AI->getName().str();
+  Constant *StrConstant = ConstantDataArray::getString(AI->getContext(), ss.str());                  
+  new StoreInst(StrConstant,strAlloc,"",FirstInst);  
+  Value* Idx[2];
+  Idx[0] = Constant::getNullValue(Type::getInt32Ty(AI->getContext()));
+  Idx[1] = ConstantInt::get(Type::getInt32Ty(AI->getContext()),0);
+  
+  GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", FirstInst);
+
+  call_args.push_back(strPtr);
+
+  CallInst::Create(qasmAllocCbit,call_args,"",FirstInst);
+} //end insertCallToAllocCbit
+
+
+void DynGenQASMLoops::insertCallToAllocQbitExec(AllocaInst* AI, int varSize,AllocaInst* strAlloc){
+ 
+  assert(FirstInst != NULL && "NULL FirstInst");
+
+  //arguments are qbit array, size, name
+  SmallVector<Value*,16> call_args;
+
+//insert argument1: qbit array
+//generate getelementptr inst
+    SmallVector<Value*,16> idxVect;
+	idxVect.push_back(ConstantInt::get(Type::getInt32Ty(AI->getContext()),0));
+	idxVect.push_back(ConstantInt::get(Type::getInt32Ty(AI->getContext()),0));
+	GetElementPtrInst *arrPtr = GetElementPtrInst::Create((Value*)AI, idxVect, "", FirstInst);
+
+  call_args.push_back(arrPtr);
+
+  //insert argument2: varSize
+  Value* arg2 = ConstantInt::get(Type::getInt32Ty(AI->getContext()),varSize);
+  call_args.push_back(arg2);
+
+  //insert argument3: varName
+  //Constant *StrConstant = ConstantDataArray::getString(AI->getContext(), AI->getName().str());
+  //ArrayType* strTy = cast<ArrayType>(StrConstant->getType());
+  //AllocaInst* strAlloc = new AllocaInst(strTy,"",FirstInst);
+  //StoreInst* strInit = new StoreInst(StrConstant,strAlloc,"",FirstInst);
+
+  std::stringstream ss;
+  ss << std::left << std::setw (MAX_FUNCTION_NAME-1) << std::setfill('.') << AI->getName().str();
+  Constant *StrConstant = ConstantDataArray::getString(AI->getContext(), ss.str());                  
+  new StoreInst(StrConstant,strAlloc,"",FirstInst); 
+  Value* Idx[2];
+  Idx[0] = Constant::getNullValue(Type::getInt32Ty(AI->getContext()));
+  Idx[1] = ConstantInt::get(Type::getInt32Ty(AI->getContext()),0);
+  
+  GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", FirstInst);
+
+  call_args.push_back(strPtr);
+
+  CallInst::Create(qasmAllocQbitExec,call_args,"",FirstInst);
+}
+
+void DynGenQASMLoops::insertCallToAllocCbitExec(AllocaInst* AI, int varSize,AllocaInst* strAlloc){
+ 
+  assert(FirstInst != NULL && "NULL FirstInst");
+
+  //arguments are qbit array, size, name
+  SmallVector<Value*,16> call_args;
+
+  //insert argument1: varSize
+  Value* arg2 = ConstantInt::get(Type::getInt32Ty(AI->getContext()),varSize);
+  call_args.push_back(arg2);
+
+  //insert argument2: varName
+  //Constant *StrConstant = ConstantDataArray::getString(AI->getContext(), AI->getName().str());
+  //ArrayType* strTy = cast<ArrayType>(StrConstant->getType());
+  //AllocaInst* strAlloc = new AllocaInst(strTy,"",FirstInst);
+  //StoreInst* strInit = new StoreInst(StrConstant,strAlloc,"",FirstInst);
+  std::stringstream ss;
+  ss << std::left << std::setw (MAX_FUNCTION_NAME-1) << std::setfill('.') << AI->getName().str();
+  Constant *StrConstant = ConstantDataArray::getString(AI->getContext(), ss.str());                  
+  new StoreInst(StrConstant,strAlloc,"",FirstInst); 
+  Value* Idx[2];
+  Idx[0] = Constant::getNullValue(Type::getInt32Ty(AI->getContext()));
+  Idx[1] = ConstantInt::get(Type::getInt32Ty(AI->getContext()),0);
+  
+  GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", FirstInst);
+
+  call_args.push_back(strPtr);
+
+  CallInst::Create(qasmAllocCbitExec,call_args,"",FirstInst);
+} //end insertCallToAllocCbitExec
+
+
+
+void DynGenQASMLoops::instrumentIntrinsicInst(CallInst* CI, int id, map<unsigned, pair<string,bool> > nameOfQbit, AllocaInst* strAlloc ){
+  
+  SmallVector<Value*,16> call_args;
+
+  Value* tmpStrArg;
+
+  //insert first argument => gateID
+  Value* intArg = ConstantInt::get(Type::getInt32Ty(CI->getContext()),id);	
+  call_args.push_back(intArg);
+  
+  //insert string args => qbit names
+  for (std::map<unsigned, pair<string,bool> >::iterator iter = nameOfQbit.begin(); iter!=nameOfQbit.end(); ++iter){
+    
+    string qname = iter->second.first;
+    
+    //Constant *StrConstant = ConstantDataArray::getString(CI->getContext(), qname);
+    //ArrayType* strTy = cast<ArrayType>(StrConstant->getType());
+    //AllocaInst* strAlloc = new AllocaInst(strTy,"",CI);
+    //StoreInst* strInit = new StoreInst(StrConstant,strAlloc,"",CI);
+    
+  std::stringstream ss;
+  ss << std::left << std::setw (MAX_FUNCTION_NAME-1) << std::setfill('.') << qname;
+  Constant *StrConstant = ConstantDataArray::getString(CI->getContext(), ss.str());                  
+  new StoreInst(StrConstant,strAlloc,"",CI); 
+    Value* Idx[2];
+    Idx[0] = Constant::getNullValue(Type::getInt32Ty(CI->getContext()));
+    Idx[1] = ConstantInt::get(Type::getInt32Ty(CI->getContext()),0);
+    
+    GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", CI);
+
+    call_args.push_back(strPtr);              
+
+    tmpStrArg = strPtr; //to remember last str arg for Prep Insts
+
+  }
+
+
+  switch(id){
+  case _H:
+  case _S:
+  case _T:
+  case _Sdag:
+  case _Tdag:
+  case _X:
+  case _Y:
+  case _Z:
+    {      
+      Value* qbitArg = CI->getArgOperand(0);
+      call_args.push_back(qbitArg);
+
+      CallInst::Create(qasmGate,call_args,"",CI);
+      break;
+    }
+
+  case _Rx:
+  case _Ry:
+  case _Rz:
+    {          
+      Value* qbitArg = CI->getArgOperand(0);
+      call_args.push_back(qbitArg);
+      
+      Value* qbitArg1 = CI->getArgOperand(1); //double or const double
+      call_args.push_back(qbitArg1);      
+
+      CallInst::Create(qasmRot,call_args,"",CI);            
+      break;    
+    }
+
+  case _CNOT:
+    {
+      
+      Value* qbitArg = CI->getArgOperand(0);
+      call_args.push_back(qbitArg);
+      
+      Value* qbitArg1 = CI->getArgOperand(1);
+      call_args.push_back(qbitArg1);      
+      
+      CallInst::Create(qasmGate2,call_args,"",CI); 
+      
+      break;
+    }
+  case _PrepX:
+  case _PrepZ:
+    {
+      //insert dummy string argument
+      call_args.push_back(tmpStrArg);
+
+      Value* qbitArg = CI->getArgOperand(0);
+      call_args.push_back(qbitArg);
+      
+      ConstantInt *Cint = dyn_cast<ConstantInt>(CI->getArgOperand(1));
+      Value* prepVal;
+      if(Cint->getZExtValue()==0)
+	prepVal= ConstantInt::get(Type::getInt16Ty(CI->getContext()),0);	
+      else
+	prepVal = ConstantInt::get(Type::getInt16Ty(CI->getContext()),1);		  
+      call_args.push_back(prepVal);
+      CallInst::Create(qasmGate2,call_args,"",(Instruction*)CI);
+      break;
+    }
+  case _MeasX:
+  case _MeasZ:
+    {
+
+      //errs() << "Meas found: " << *CI <<"\n"; 
+      //add cbit string
+      map<Value*, string>::iterator mit = mapInstRtn.find((Value*)CI);
+      assert(mit!=mapInstRtn.end() && "Cbit Name Not Found in Map");
+
+      //Constant *StrConstant = ConstantDataArray::getString(CI->getContext(), (*mit).second);
+      //ArrayType* strTy = cast<ArrayType>(StrConstant->getType());
+      //AllocaInst* strAlloc = new AllocaInst(strTy,"",CI);
+      //StoreInst* strInit = new StoreInst(StrConstant,strAlloc,"",CI);
+
+      std::stringstream ss;
+      ss << std::left << std::setw (MAX_FUNCTION_NAME-1) << std::setfill('.') << (*mit).second;
+      Constant *StrConstant = ConstantDataArray::getString(CI->getContext(), ss.str());                  
+      new StoreInst(StrConstant,strAlloc,"",CI);       
+      Value* Idx[2];
+      Idx[0] = Constant::getNullValue(Type::getInt32Ty(CI->getContext()));
+      Idx[1] = ConstantInt::get(Type::getInt32Ty(CI->getContext()),0);
+      
+      GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", CI);
+      
+      call_args.push_back(strPtr);              
+      
+
+      Value* qbitArg = CI->getArgOperand(0);
+      call_args.push_back(qbitArg);
+      call_args.push_back(qbitArg);
+      CallInst::Create(qasmGate2,call_args,"",(Instruction*)CI);   
+      break;
+    }
+    
+  case _Fredkin:
+  case _Toffoli:
+    {        
+      Value* qbitArg = CI->getArgOperand(0);
+      call_args.push_back(qbitArg);
+      
+      Value* qbitArg1 = CI->getArgOperand(1);
+      call_args.push_back(qbitArg1);      
+      
+      Value* qbitArg2 = CI->getArgOperand(2);
+      call_args.push_back(qbitArg2);  
+      
+      CallInst::Create(qasmGate3,call_args,"",CI); 
+      
+      break;
+    }
+  }
+} //end instrumentIntrinsicInst
+
+
+
+void DynGenQASMLoops::instrumentNonIntrinsicInst(CallInst* CI, map<unsigned, pair<string,bool> > nameOfQbit, AllocaInst* strAlloc){
+  //errs() << "In InstrumentNonIntrinsicInst \n";
+  
+    //print_call_start
+    
+    //insert argument: called func name
+
+  //errs() << "Insert CF name \n";
+  //Constant *StrConstant = ConstantDataArray::getString(CI->getContext(), CI->getCalledFunction()->getName().str());
+  //ArrayType* strTy = cast<ArrayType>(StrConstant->getType());
+  //AllocaInst* strAlloc = new AllocaInst(strTy,"",CI);
+  //StoreInst* strInit = new StoreInst(StrConstant,strAlloc,"",CI);
+  std::stringstream ss;
+  ss << std::left << std::setw (MAX_FUNCTION_NAME-1) << std::setfill('.') << CI->getCalledFunction()->getName().str();
+  Constant *StrConstant = ConstantDataArray::getString(CI->getContext(), ss.str());                  
+  new StoreInst(StrConstant,strAlloc,"",CI); 
+
+  Value* Idx[2];
+  Idx[0] = Constant::getNullValue(Type::getInt32Ty(CI->getContext()));
+  Idx[1] = ConstantInt::get(Type::getInt32Ty(CI->getContext()),0);
+  
+  GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", CI);
+
+  //call_args.push_back(strPtr);
+    
+  CallInst::Create(qasmQCall,strPtr, "", CI);
+  
+  //iterate over int and double args and send
+  //errs() << "Insert int/double args \n";
+  for(unsigned iop=0;iop < CI->getNumArgOperands(); iop++) {
+    Value* arg = CI->getArgOperand(iop);
+    Type* argType = arg->getType();
+    if(argType->isIntegerTy(32))
+      CallInst::Create(qasmCallInstIntArg, arg, "", CI);
+    else if(argType->isDoubleTy())
+      CallInst::Create(qasmCallInstDoubleArg, arg, "", CI);
+  }
+
+  //send call to print opening brace for function
+  Value* endVal1 = ConstantInt::get(Type::getInt32Ty(CI->getContext()),0);
+  CallInst::Create(qasmQCallEnd, endVal1, "", CI);      
+ /*--- 
+  //errs() << "Insert qbit args \n";
+
+  //iterate over map and send one argument at a time based on whether ptr or not
+  for (std::map<unsigned, pair<string,bool> >::iterator i = nameOfQbit.begin(); i!=nameOfQbit.end(); ++i){
+    
+    string qname = i->second.first;
+    
+    //Constant *StrConstant = ConstantDataArray::getString(CI->getContext(), qname);
+    //ArrayType* strTy = cast<ArrayType>(StrConstant->getType());
+    //AllocaInst* strAlloc = new AllocaInst(strTy,"",CI);
+    //StoreInst* strInit = new StoreInst(StrConstant,strAlloc,"",CI);
+
+    std::stringstream ss;
+    ss << std::left << std::setw (MAX_FUNCTION_NAME-1) << std::setfill('.') << qname;
+    Constant *StrConstant = ConstantDataArray::getString(CI->getContext(), ss.str());                  
+    new StoreInst(StrConstant,strAlloc,"",CI); 
+    Value* Idx[2];
+    Idx[0] = Constant::getNullValue(Type::getInt32Ty(CI->getContext()));
+    Idx[1] = ConstantInt::get(Type::getInt32Ty(CI->getContext()),0);
+  
+    GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", CI);
+    
+    if(i->second.second == true){ //is ptr to qbit            
+      CallInst::Create(qasmQCallArgQbitPtr,strPtr, "", CI);      
+    } //is qbit ptr
+    else{ //is qbit
+      SmallVector<Value*,16> call_args;
+      call_args.push_back(strPtr);
+      
+      Value* qbitArg = CI->getOperand(i->first);
+      call_args.push_back(qbitArg);
+      CallInst::Create(qasmQCallArgQbit,call_args, "", CI);
+      
+    }
+  } // end of map iterator
+  ----*/
+  
+    // send call_end
+
+  Value* endVal2 = ConstantInt::get(Type::getInt32Ty(CI->getContext()),1);
+  CallInst::Create(qasmQCallEnd, endVal2, "", CI);      
+}
+
+void DynGenQASMLoops::analyzeAllocInst(Function* F, Instruction* pInst, AllocaInst* strAlloc){
+  if (AllocaInst *AI = dyn_cast<AllocaInst>(pInst)) {
+    Type *allocatedType = AI->getAllocatedType();
+    
+    if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+      qGateArg tmpQArg;
+
+      Type *elementType = arrayType->getElementType();
+      uint64_t arraySize = arrayType->getNumElements();
+      if (elementType->isIntegerTy(16)){
+	if(debugDynGenQASMLoops)
+	  errs() << "New QBit Allocation Found: " << AI->getName() <<"\n";
+	insertCallToAllocQbit(AI,arraySize,strAlloc);   
+	vectQbit.push_back(AI);
+	tmpQArg.isQbit = true;
+	tmpQArg.argPtr = AI;
+	tmpQArg.numDim = 1;
+	tmpQArg.dimSize[0] = arraySize;
+	tmpQArg.valOrIndex = arraySize;
+	(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	(qbitsInitInFunc.find(F))->second.push_back(tmpQArg);	
+      }
+      
+      else if (elementType->isIntegerTy(1)){
+	if(debugDynGenQASMLoops)
+	  errs() << "New CBit Allocation Found: " << AI->getName() <<"\n";
+
+	insertCallToAllocCbit(AI,arraySize, strAlloc);
+
+	vectQbit.push_back(AI); //Cbit added here
+	tmpQArg.isCbit = true;
+	tmpQArg.argPtr = AI;
+	tmpQArg.numDim = 1;
+	tmpQArg.dimSize[0] = arraySize;
+	tmpQArg.valOrIndex = arraySize;
+	(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	(qbitsInitInFunc.find(F))->second.push_back(tmpQArg);	
+      }
+
+      else if(elementType->isArrayTy()){
+	  errs() << "Multidimensional array\n";
+        assert(false && "Multidimensional array");
+/*
+	  tmpQArg.dimSize[0] = arraySize;
+	  tmpQArg.numDim++;
+	  tmpQArg.valOrIndex = arraySize;
+
+	  //recurse on multi-dimensional array
+	  bool isQAlloc = getQbitArrDim(elementType,&tmpQArg);
+
+	  if(isQAlloc){
+	    vectQbit.push_back(AI);
+	    tmpQArg.argPtr = AI;
+	    (qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	    (qbitsInitInFunc.find(F))->second.push_back(tmpQArg);
+
+	    if(debugDynGenQASMLoops)
+	      print_qgateArg(tmpQArg);
+	  }
+          */	  
+      }
+
+    }
+    else if(allocatedType->isPointerTy()){
+      
+      /*Note: this is necessary if -mem2reg is not run on LLVM IR before.
+	Eg without -mem2reg
+	module(i8* %q){
+	%q.addr = alloca i8*, align 8
+	...
+	}
+	qbit q.addr must be mapped to argument q. Hence the following code.
+	If it is known that -O1 will be run, then this can be removed.
+      */
+      
+      Type *elementType = allocatedType->getPointerElementType();
+      if(debugDynGenQASMLoops)
+	errs() << "\tIs a Pointer of Type: " << *elementType << "\n";
+      
+      if (elementType->isIntegerTy(16)){
+	vectQbit.push_back(AI);
+	
+	qGateArg tmpQArg;
+	tmpQArg.isPtr = true;
+	tmpQArg.isQbit = true;
+	tmpQArg.argPtr = AI;
+	
+	(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	
+	std::string argName = AI->getName();
+	unsigned pos = argName.find(".addr");
+	std::string argName2 = argName.substr(0,pos);
+
+	//find argName2 in funcArgList - avoid printing out qbit declaration twice
+	std::map<Function*, vector<qGateArg> >::iterator mIter = funcArgList.find(F);
+	if(mIter != funcArgList.end()){
+	  bool foundit = false;
+	  for(vector<qGateArg>::iterator vParamIter = (*mIter).second.begin();(vParamIter!=(*mIter).second.end() && !foundit);++vParamIter){
+	    if((*vParamIter).argPtr->getName() == argName2){ 
+	      foundit = true;
+	    }
+	  }
+	  if(!foundit) //do not add duplicate declaration
+	    (qbitsInitInFunc.find(F))->second.push_back(tmpQArg);
+	}
+      }
+    }
+    return;
+  }
+
+}
+
+
+void DynGenQASMLoops::analyzeAllocInstExec(Function* F, Instruction* pInst, AllocaInst* strAlloc){
+  if (AllocaInst *AI = dyn_cast<AllocaInst>(pInst)) {
+    Type *allocatedType = AI->getAllocatedType();
+    
+    if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+
+      Type *elementType = arrayType->getElementType();
+      uint64_t arraySize = arrayType->getNumElements();
+      if (elementType->isIntegerTy(16)){
+	if(debugDynGenQASMLoops)
+	  errs() << "New QBit Allocation Found: " << AI->getName() <<"\n";
+	insertCallToAllocQbitExec(AI,arraySize, strAlloc);   
+      }      
+      else if (elementType->isIntegerTy(1)){
+	if(debugDynGenQASMLoops)
+	  errs() << "New CBit Allocation Found: " << AI->getName() <<"\n";
+	insertCallToAllocCbitExec(AI,arraySize, strAlloc);
+      }
+    }
+  }
+} //end analyzeAllocExec functions
+
+
+
+void DynGenQASMLoops::analyzeCallInst(Function* F, Instruction* pInst, AllocaInst* strAlloc){
+  if(CallInst *CI = dyn_cast<CallInst>(pInst))
+    {
+      if(debugDynGenQASMLoops)
+      //if(F->getName() == "main_qtm")
+	errs() << "Call inst: " << CI->getCalledFunction()->getName() << "\n";
+      
+      Function* CF = CI->getCalledFunction();
+
+      if(CF->getName().find("qasm_print_")!=string::npos) return;
+      
+      if(CF->getName() == "store_cbit"){	//trace return values
+	return;
+      }
+
+      /*
+      if(((CF->getName()).find("qasm_print_RepLoopStart")!=string::npos) || ((CF->getName()).find("qasm_print_RepLoopEnd")!=string::npos)){
+	vRemoveInst.push_back(CI);       
+	return; //spatil: should this be here?
+	}
+      */
+
+      std::map<unsigned, int> valueOfInt; // map argument index to const int value
+      std::map<unsigned, double> valueOfDouble; // map argument index to const double value  
+      std::map<unsigned, pair<string,bool> > nameOfQbit; // string:isPtr
+      
+      // scan for constant int or double arguments and save them
+      for(unsigned iop=0;iop < CI->getNumArgOperands(); iop++) {
+	if(ConstantInt *CInt = dyn_cast<ConstantInt>(CI->getArgOperand(iop)))
+	  valueOfInt[iop] = CInt->getZExtValue();
+	else if(ConstantFP *CDouble = dyn_cast<ConstantFP>(CI->getArgOperand(iop)))
+	  valueOfDouble[iop] = CDouble->getValueAPF().convertToDouble();    
+	else{
+	  
+	  tmpDepQbit.clear();
+	  btCount = 0;
+	  qGateArg tmpQGateArg1;
+	  tmpDepQbit.push_back(tmpQGateArg1);
+          
+	  Type* argType = CI->getArgOperand(iop)->getType();
+	  if(argType->isPointerTy()){
+	    //tmpQGateArg.isPtr = true;
+	    Type *argElemType = argType->getPointerElementType();
+	    if(argElemType->isIntegerTy(16)){
+	      backtraceOperand(CI->getArgOperand(iop),0);
+	      assert(tmpDepQbit[0].argPtr!=NULL && "Expected to find qbit ptr");
+	      nameOfQbit[iop] = make_pair(tmpDepQbit[0].argPtr->getName().str(),true);
+	    //tmpQGateArg.isQbit = true;
+	    }
+	    else if(argElemType->isIntegerTy(1)){
+	      backtraceOperand(CI->getArgOperand(iop),0);
+	      assert(tmpDepQbit[0].argPtr!=NULL && "Expected to find cbit ptr as function argument");
+            nameOfQbit[iop] = make_pair(tmpDepQbit[0].argPtr->getName().str(),true);
+	    //tmpQGateArg.isCbit = true;
+	    }
+	  }
+	  else if(argType->isIntegerTy(16)){
+	    //errs() << "\t Arg is qbit \n";
+	    
+            backtraceOperand(CI->getArgOperand(iop),0);
+	    
+            assert(tmpDepQbit[0].argPtr!=NULL && "Expected to find qbit");
+            nameOfQbit[iop] = make_pair(tmpDepQbit[0].argPtr->getName().str(),false);
+	    //errs() << "\t Arg Name = " << tmpDepQbit[0].argPtr->getName() << "\n";
+	    //tmpQGateArg.isQbit = true;
+	    //tmpQGateArg.valOrIndex = 0;	 
+	  }	  	
+	  else if(argType->isIntegerTy(1)){
+            assert(false && "Should not find cbit as function argument");
+	    //tmpQGateArg.isCbit = true;
+	    //tmpQGateArg.valOrIndex = 0;	 
+	  }     
+	  
+          
+	}
+      }
+            
+      //check if Intrinsic Function
+      
+      int gateIndex = -1;
+      bool isIntrinsicQuantum = true;
+      
+      if(CF->isIntrinsic()){
+	if(CF->getIntrinsicID() == Intrinsic::CNOT) gateIndex = _CNOT;
+	else if(CF->getIntrinsicID() == Intrinsic::Fredkin) gateIndex = _Fredkin;
+	else if(CF->getIntrinsicID() == Intrinsic::H) gateIndex = _H;
+	else if(CF->getIntrinsicID() == Intrinsic::MeasX) { gateIndex = _MeasX; }
+	else if(CF->getIntrinsicID() == Intrinsic::MeasZ) { gateIndex = _MeasZ; }
+	else if(CF->getIntrinsicID() == Intrinsic::PrepX) gateIndex = _PrepX;
+	else if(CF->getIntrinsicID() == Intrinsic::PrepZ) gateIndex = _PrepZ;
+	else if(CF->getIntrinsicID() == Intrinsic::Rz) gateIndex = _Rz;
+	else if(CF->getIntrinsicID() == Intrinsic::S) gateIndex = _S;
+	else if(CF->getIntrinsicID() == Intrinsic::T) gateIndex = _T;
+	else if(CF->getIntrinsicID() == Intrinsic::Sdag) gateIndex = _Sdag;
+	else if(CF->getIntrinsicID() == Intrinsic::Tdag) gateIndex = _Tdag;
+	else if(CF->getIntrinsicID() == Intrinsic::Toffoli) gateIndex = _Toffoli;
+	else if(CF->getIntrinsicID() == Intrinsic::X) gateIndex = _X;
+	else if(CF->getIntrinsicID() == Intrinsic::Y) gateIndex = _Y;
+	else if(CF->getIntrinsicID() == Intrinsic::Z) gateIndex = _Z;
+	else { isIntrinsicQuantum = false; }
+      }
+      else{
+	isIntrinsicQuantum = false;
+      }
+      
+      if(isIntrinsicQuantum){ 
+	//errs() << "Is Intrinsic. GateID = " << gateIndex << "\n";
+	instrumentIntrinsicInst(CI, gateIndex, nameOfQbit, strAlloc);
+	return;
+      }
+
+      if(CF->isDeclaration()) return;
+
+      //NonIntrinsicCall Found
+          
+      instrumentNonIntrinsicInst(CI, nameOfQbit, strAlloc);
+      vRemoveInst.push_back(CI);
+
+    } //if CallInst
+}
+
+
+void DynGenQASMLoops::cleanup_store_cbits(Function* F){
+  //iterate over instructions
+   for(inst_iterator instIb = inst_begin(F),instIe=inst_end(F); instIb!=instIe;++instIb){
+     Instruction* pInst = &*instIb;
+     //if store_cbit found, mark for removal 
+     if(CallInst *CI = dyn_cast<CallInst>(pInst))
+       {      
+	 if(CI->getCalledFunction()->getName() == "store_cbit"){
+	   vRemoveInst.push_back(CI); 
+	 }
+
+	 else if(((CI->getCalledFunction()->getName()).find("qasm_print_RepLoopStart")!=string::npos) || ((CI->getCalledFunction()->getName()).find("qasm_print_RepLoopEnd")!=string::npos)){
+	   vRemoveInst.push_back(CI);       
+	 }
+
+       }    
+   }
+}
+
+void DynGenQASMLoops::analyzeStoreCbitInst(Function* F, Instruction* pInst){
+
+  if(CallInst *CI = dyn_cast<CallInst>(pInst))
+    {
+      
+      Function* CF = CI->getCalledFunction();
+      
+      if(CF->getName() == "store_cbit"){	//trace return values
+
+	if(debugDynGenQASMLoops)      
+	  errs() << "Call inst: " << CF->getName() << "\n";
+
+	Value* rtnVal = CI->getArgOperand(0); //cbit
+	//tmpDepQbit.clear();
+
+	qGateArg tmpQGateArg2;
+	tmpQGateArg2.isCbit = true;
+	tmpQGateArg2.isPtr = true;
+	tmpDepQbit.push_back(tmpQGateArg2);	
+	backtraceOperand(CI->getArgOperand(1),0); //pointer Operand
+
+	//insert info in map here
+	mapInstRtn[rtnVal] = tmpDepQbit[0].argPtr->getName().str();
+
+	tmpDepQbit.clear();
+	vRemoveInst.push_back(CI);       
+	return;
+      }
+
+    }
+
+}
+
+void DynGenQASMLoops::analyzeInst(Function* F, Instruction* pInst, AllocaInst* strAlloc){
+  if(debugDynGenQASMLoops)
+    errs() << "--Processing Inst: "<<*pInst << '\n';
+
+  //analyzeAllocInst(F,pInst);
+
+  analyzeCallInst(F,pInst, strAlloc);
+    
+  if(debugDynGenQASMLoops)
+    {
+      errs() << "Opcode: "<<pInst->getOpcodeName() << "\n";
+      
+      unsigned numOps = pInst->getNumOperands();
+      errs() << "Num Operands: " << numOps << ": ";
+      
+      for(unsigned iop=0;iop<numOps;iop++){
+	errs() << pInst->getOperand(iop)->getName() << "; ";
+      }
+      errs() << "\n";		
+      return;
+    }
+    
+  return;
+}
+
+void DynGenQASMLoops::printFuncHeader(Function* F)
+{
+
+  map<Function*, vector<qGateArg> >::iterator mpItr;
+  map<Function*, vector<qGateArg> >::iterator mpItr2;
+  map<Function*, vector<qGateArg> >::iterator mvpItr;
+
+  mpItr = qbitsInFunc.find(F);
+
+  //print name of function
+  errs()<<"\nmodule "<<F->getName();
+  
+  //print arguments of function
+  mpItr2=funcArgList.find(F);    
+  errs()<<" ( ";    
+  unsigned tmp_num_elem = (*mpItr2).second.size();
+  
+  if(tmp_num_elem > 0){
+    for(unsigned tmp_i=0;tmp_i<tmp_num_elem - 1;tmp_i++){
+      
+      qGateArg tmpQA = (*mpItr2).second[tmp_i];
+      
+      if(debugDynGenQASMLoops)
+	print_qgateArg(tmpQA);
+      
+      if(tmpQA.isQbit)
+	errs()<<"qbit";
+      else if(tmpQA.isCbit)
+	errs()<<"cbit";
+      else{
+	Type* argTy = tmpQA.argPtr->getType();
+	if(argTy->isDoubleTy()) errs() << "double";
+	else if(argTy->isFloatTy()) errs() << "float";
+	else
+	  errs()<<"UNRECOGNIZED "<<argTy<<" ";
+      }
+      
+      if(tmpQA.isPtr)
+	errs()<<"*";	  
+      
+      errs()<<" "<<printVarName(tmpQA.argPtr->getName())<<" , ";
+    }
+    
+    if(debugDynGenQASMLoops)
+      print_qgateArg((*mpItr2).second[tmp_num_elem-1]);
+    
+    
+    if(((*mpItr2).second[tmp_num_elem-1]).isQbit)
+      errs()<<"qbit";
+    else if(((*mpItr2).second[tmp_num_elem-1]).isCbit)
+      errs()<<"cbit";
+    else{
+      Type* argTy = ((*mpItr2).second[tmp_num_elem-1]).argPtr->getType();
+      if(argTy->isDoubleTy()) errs() << "double";
+      else if(argTy->isFloatTy()) errs() << "float";
+      else
+	errs()<<"UNRECOGNIZED "<<argTy<<" ";
+    }
+    
+    if(((*mpItr2).second[tmp_num_elem-1]).isPtr)
+      errs()<<"*";
+    
+    errs() <<" "<<printVarName(((*mpItr2).second[tmp_num_elem-1]).argPtr->getName());
+  }
+  
+  errs()<<" ) {\n ";   
+  
+  //print qbits declared in function
+  mvpItr=qbitsInitInFunc.find(F);	    
+  for(vector<qGateArg>::iterator vvit=(*mvpItr).second.begin(),vvitE=(*mvpItr).second.end();vvit!=vvitE;++vvit)
+    {	
+      if((*vvit).isQbit)
+	errs()<<"\tqbit "<<printVarName((*vvit).argPtr->getName());
+      if((*vvit).isCbit)
+	errs()<<"\tcbit "<<printVarName((*vvit).argPtr->getName());
+
+      //if only single-dimensional qbit arrays expected
+      //errs()<<"["<<(*vvit).valOrIndex<<"];\n ";
+
+      //if n-dimensional qbit arrays expected 
+      for(int ndim = 0; ndim < (*vvit).numDim; ndim++)
+	errs()<<"["<<(*vvit).dimSize[ndim]<<"]";
+      errs() << ";\n";
+    }
+  
+}
+
+void DynGenQASMLoops::getFunctionArguments(Function* F)
+{
+  //std::vector<unsigned> qGateArgs;  
+
+  for(Function::arg_iterator ait=F->arg_begin();ait!=F->arg_end();++ait)
+    {    
+      std::string argName = (ait->getName()).str();
+      Type* argType = ait->getType();
+      unsigned int argNum=ait->getArgNo();         
+
+      qGateArg tmpQArg;
+      tmpQArg.argPtr = ait;
+      tmpQArg.argNum = argNum;
+
+      if(argType->isPointerTy()){
+	if(debugDynGenQASMLoops)
+	  errs()<<"Argument Type: " << *argType <<"\n";
+
+	tmpQArg.isPtr = true;
+
+	Type *elementType = argType->getPointerElementType();
+	if (elementType->isIntegerTy(16)){
+	  tmpQArg.isQbit = true;
+	  vectQbit.push_back(ait);
+	  (qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	  (funcArgList.find(F))->second.push_back(tmpQArg);
+	}
+	else if (elementType->isIntegerTy(1)){
+	  tmpQArg.isCbit = true;
+	  vectQbit.push_back(ait);
+	  (qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	  (funcArgList.find(F))->second.push_back(tmpQArg);
+	}
+      }
+      else if (argType->isIntegerTy(16)){
+	tmpQArg.isQbit = true;
+	vectQbit.push_back(ait);
+	(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	(funcArgList.find(F))->second.push_back(tmpQArg);
+      }
+      else if (argType->isIntegerTy(1)){
+	tmpQArg.isCbit = true;
+	vectQbit.push_back(ait);
+	(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	(funcArgList.find(F))->second.push_back(tmpQArg);
+      }
+      else if(argType->isDoubleTy())     
+	(funcArgList.find(F))->second.push_back(tmpQArg);
+
+      if(debugDynGenQASMLoops)
+	print_qgateArg(tmpQArg);
+    }
+}
+
+void DynGenQASMLoops::removeIntrinsicQtmExec(Function* F,Instruction* I){
+  if(CallInst *CI = dyn_cast<CallInst>(I)){
+    Function* CF = CI->getCalledFunction();
+
+  if(CF->isIntrinsic()){
+    if((CF->getIntrinsicID() == Intrinsic::CNOT)
+       || (CF->getIntrinsicID() == Intrinsic::Fredkin)
+       || (CF->getIntrinsicID() == Intrinsic::H)
+       //|| (CF->getIntrinsicID() == Intrinsic::MeasX)
+       //|| (CF->getIntrinsicID() == Intrinsic::MeasZ)
+       || (CF->getIntrinsicID() == Intrinsic::PrepX)
+       || (CF->getIntrinsicID() == Intrinsic::PrepZ)
+       || (CF->getIntrinsicID() == Intrinsic::Rz)
+       || (CF->getIntrinsicID() == Intrinsic::S)
+       || (CF->getIntrinsicID() == Intrinsic::T)
+       || (CF->getIntrinsicID() == Intrinsic::Sdag)
+       || (CF->getIntrinsicID() == Intrinsic::Tdag)
+       || (CF->getIntrinsicID() == Intrinsic::Toffoli)
+       || (CF->getIntrinsicID() == Intrinsic::X)
+       || (CF->getIntrinsicID() == Intrinsic::Y)
+       || (CF->getIntrinsicID() == Intrinsic::Z)){
+      vRemoveInst.push_back(CI);
+    }
+  }
+  }
+}
+
+
+// run - Find datapaths for qubits
+bool DynGenQASMLoops::runOnModule(Module &M) {
+
+  qasmAllocQbit = cast<Function>(M.getOrInsertFunction("qasm_print_qbit_alloc", Type::getVoidTy(M.getContext()), Type::getInt16Ty(M.getContext())->getPointerTo(), Type::getInt32Ty(M.getContext()), Type::getInt8Ty(M.getContext())->getPointerTo(), (Type*)0));
+
+  qasmAllocCbit = cast<Function>(M.getOrInsertFunction("qasm_print_cbit_alloc", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), Type::getInt8Ty(M.getContext())->getPointerTo(), (Type*)0));
+
+  qasmAllocQbitExec = cast<Function>(M.getOrInsertFunction("qasm_print_qbit_alloc_exec", Type::getVoidTy(M.getContext()), Type::getInt16Ty(M.getContext())->getPointerTo(), Type::getInt32Ty(M.getContext()), Type::getInt8Ty(M.getContext())->getPointerTo(), (Type*)0));
+
+  qasmAllocCbitExec = cast<Function>(M.getOrInsertFunction("qasm_print_cbit_alloc_exec", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), Type::getInt8Ty(M.getContext())->getPointerTo(), (Type*)0));
+  
+  qasmHeader = cast<Function>(M.getOrInsertFunction("qasm_print_header", Type::getVoidTy(M.getContext()),  Type::getInt8Ty(M.getContext())->getPointerTo(), (Type*)0));       
+
+  qasmHeaderQbit = cast<Function>(M.getOrInsertFunction("qasm_print_header_qbit_arg", Type::getVoidTy(M.getContext()), Type::getInt8Ty(M.getContext())->getPointerTo(), (Type*)0));
+
+    qasmHeaderQbitPtr = cast<Function>(M.getOrInsertFunction("qasm_print_header_qbitptr_arg", Type::getVoidTy(M.getContext()), Type::getInt8Ty(M.getContext())->getPointerTo(),(Type*)0));
+
+    qasmHeaderCbitPtr = cast<Function>(M.getOrInsertFunction("qasm_print_header_cbitptr_arg", Type::getVoidTy(M.getContext()), Type::getInt8Ty(M.getContext())->getPointerTo(),(Type*)0));
+
+    qasmHeaderEnd = cast<Function>(M.getOrInsertFunction("qasm_print_header_end", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), (Type*)0));
+
+      qasmHeaderIntArg = cast<Function>(M.getOrInsertFunction("qasm_print_header_int_arg", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()),(Type*)0));
+
+      qasmHeaderDoubleArg = cast<Function>(M.getOrInsertFunction("qasm_print_header_double_arg", Type::getVoidTy(M.getContext()), Type::getDoubleTy(M.getContext()),(Type*)0));
+
+  qasmQCall = cast<Function>(M.getOrInsertFunction("qasm_print_call_start", Type::getVoidTy(M.getContext()),  Type::getInt8Ty(M.getContext())->getPointerTo(), (Type*)0));       
+ 
+       qasmQCallArgQbit = cast<Function>(M.getOrInsertFunction("qasm_print_call_qbit_arg", Type::getVoidTy(M.getContext()), Type::getInt8Ty(M.getContext())->getPointerTo(), Type::getInt16Ty(M.getContext()), (Type*)0));
+
+    qasmQCallArgQbitPtr = cast<Function>(M.getOrInsertFunction("qasm_print_call_qbitptr_arg", Type::getVoidTy(M.getContext()), Type::getInt8Ty(M.getContext())->getPointerTo(),(Type*)0));
+
+    qasmQCallEnd = cast<Function>(M.getOrInsertFunction("qasm_print_call_end", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), (Type*)0));
+
+    qasmGate = cast<Function>(M.getOrInsertFunction("qasm_print_qgate", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), Type::getInt8Ty(M.getContext())->getPointerTo(),  Type::getInt16Ty(M.getContext()), (Type*)0));
+      
+      qasmGate2 = cast<Function>(M.getOrInsertFunction("qasm_print_qgate2", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), Type::getInt8Ty(M.getContext())->getPointerTo(), Type::getInt8Ty(M.getContext())->getPointerTo(), Type::getInt16Ty(M.getContext()), Type::getInt16Ty(M.getContext()), (Type*)0));
+
+      qasmGate3 = cast<Function>(M.getOrInsertFunction("qasm_print_qgate3", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), Type::getInt8Ty(M.getContext())->getPointerTo(),Type::getInt8Ty(M.getContext())->getPointerTo(),Type::getInt8Ty(M.getContext())->getPointerTo(),  Type::getInt16Ty(M.getContext()), Type::getInt16Ty(M.getContext()), Type::getInt16Ty(M.getContext()),  (Type*)0));
+
+      qasmRot = cast<Function>(M.getOrInsertFunction("qasm_print_rot", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()),  Type::getInt8Ty(M.getContext())->getPointerTo(), Type::getInt16Ty(M.getContext()), Type::getDoubleTy(M.getContext()),(Type*)0));
+      
+      qasmCallInstIntArg = cast<Function>(M.getOrInsertFunction("qasm_print_call_int_arg", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()),(Type*)0));
+
+      qasmCallInstDoubleArg = cast<Function>(M.getOrInsertFunction("qasm_print_call_double_arg", Type::getVoidTy(M.getContext()), Type::getDoubleTy(M.getContext()),(Type*)0));
+
+
+  FirstInst = NULL; //reset firstInst
+  
+  CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+  unsigned sccNum = 0;
+  forallStr = "";
+
+  errs() << "-------QASM Generation Pass:\n";
+
+  for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode),
+         E = scc_end(rootNode); sccIb != E; ++sccIb)
+    {
+      const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+
+      if(debugDynGenQASMLoops)
+	errs() << "\nSCC #" << ++sccNum << " : ";      
+
+      for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(),
+	     E = nextSCC.end(); nsccI != E; ++nsccI)
+	{
+	  Function *F=(*nsccI)->getFunction();	  
+	  
+	  bool isQtmImage = false;
+	  if(F && F->getName().find("_qtm")!=string::npos) isQtmImage = true;
+
+	  if(F && !F->isDeclaration() && isQtmImage){
+	    if(debugDynGenQASMLoops)
+	      errs() << "=====Processing Function:" << F->getName() <<" \n ";
+
+	    //initialize map structures for this function
+	    vector<qGateArg> myQIFVec, myQIFVec1, myQIFVec2;
+	    qbitsInFunc[F] = myQIFVec;
+	    qbitsInitInFunc[F] = myQIFVec1;
+	    funcArgList[F] = myQIFVec2;
+
+	    std::vector<FnCall> myFuncMapVec;
+	    mapFunction[F] = myFuncMapVec;
+
+	    getFunctionArguments(F);
+
+	    //get first instruction after alloc 
+	    inst_iterator firstInstIter = inst_begin(F);
+	    while(isa<AllocaInst>(*firstInstIter)) ++firstInstIter;
+	    FirstInst = &(*firstInstIter);
+	    
+	    //insert alloca insts here
+	    ArrayType *strTy = ArrayType::get(Type::getInt8Ty(FirstInst->getContext()), MAX_FUNCTION_NAME);
+	    AllocaInst *strAlloc = new AllocaInst(strTy,"",FirstInst);
+	    
+	    //insert call to print qasm header
+	    //insertCallToHeader(F->getName().str(),FirstInst);	    
+	    insertCallToHeader(F,FirstInst, strAlloc);	    
+
+	    
+	    //visit Alloc Insts in func and find if function is quantum or classical function
+	    for(inst_iterator instIb = inst_begin(F),instIe=inst_end(F); instIb!=instIe;++instIb){
+
+	      Instruction *pInst = &*instIb; // Grab pointer to instruction reference	      
+
+	      if(debugDynGenQASMLoops)
+		errs() << "\n Processing Inst: "<<*pInst << "\n";
+
+	      analyzeAllocInst(F,pInst, strAlloc);
+	      analyzeStoreCbitInst(F,pInst);
+	    }
+
+	    map<Function*, vector<qGateArg> >::iterator mpItr = qbitsInFunc.find(F);
+	    if((*mpItr).second.size()>0){ //Is Quantum Function
+	      //printFuncHeader(F);
+	    
+	      for(inst_iterator instIb = inst_begin(F),instIe=inst_end(F); instIb!=instIe;++instIb){
+
+		Instruction *pInst = &*instIb; // Grab pointer to instruction reference	      
+		allDepQbit.clear();
+		
+		if(debugDynGenQASMLoops)
+		  errs() << "\n Processing Inst: "<<*pInst << "\n";
+		
+		analyzeInst(F,pInst,strAlloc); //spatil: need a bool return type?
+	      }
+	      
+	      //genQASM(F);
+	      
+	      }
+	    
+	  }
+	  if(F && !F->isDeclaration() && !isQtmImage){
+
+	    //assign qubit allocations
+	    //get first instruction after alloc 
+	    inst_iterator firstInstIter = inst_begin(F);
+	    while(isa<AllocaInst>(*firstInstIter)) ++firstInstIter;
+	    
+	    FirstInst = &(*firstInstIter);
+
+	    //insert alloca insts here
+	    ArrayType *strTy = ArrayType::get(Type::getInt8Ty(FirstInst->getContext()), MAX_FUNCTION_NAME);
+	    AllocaInst *strAlloc = new AllocaInst(strTy,"",FirstInst);
+
+	    for(inst_iterator instIb = inst_begin(F),instIe=inst_end(F); instIb!=instIe;++instIb){
+
+	      Instruction *pInst = &*instIb; // Grab pointer to instruction reference	      
+
+	      if(debugDynGenQASMLoops)
+		errs() << "\n Processing Inst: "<<*pInst << "\n";
+
+	      analyzeAllocInstExec(F,pInst, strAlloc);
+
+	      //if inst is intrinsic quantum function, remove it.
+	      removeIntrinsicQtmExec(F,pInst);
+
+	    }
+
+
+	    //remove store-cbits from the function
+	    cleanup_store_cbits(F);
+
+	    //errs() << "Removing instructions:\n";
+	    for(vector<Instruction*>::iterator iterInst = vRemoveInst.begin(); iterInst != vRemoveInst.end(); ++iterInst){
+	      //errs() << *(*iterInst) << "\n";
+	      (*iterInst)->eraseFromParent();
+	    }     
+	    vRemoveInst.clear();
+
+	  }
+	  else{	    
+	    if(debugDynGenQASMLoops)
+	      errs() << "WARNING: Ignoring external node or dummy function.";
+	  }
+	  
+	}
+      if (nextSCC.size() == 1 && sccIb.hasLoop())
+	errs() << " (Has self-loop).";
+    }
+  errs()<<"\n--------End of QASM generation";
+  errs() << "\n";
+
+
+  
+  return false;
+}
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/DynRollupLoops.cpp llvm/lib/Transforms/Scaffold/DynRollupLoops.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/DynRollupLoops.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/DynRollupLoops.cpp	2017-10-12 11:09:31.091119588 +0800
@@ -0,0 +1,1621 @@
+//===----------------------- DynRollupLoops.cpp --------------------------===///
+// This file implements the Scaffold pass of traversing basic blocks, finding
+// purely quantum loops, and transforming them so they get called only once.
+
+
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "DynRollupLoops"
+#include "llvm/Module.h"
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/ScalarEvolution.h"
+#include "llvm/Analysis/ScalarEvolutionExpressions.h"
+#include "llvm/Transforms/Utils/Local.h"
+#include "llvm/Intrinsics.h"
+#include "llvm/LLVMContext.h"
+#include <sstream>
+#include <climits>
+
+using namespace llvm;
+using namespace std;
+
+
+bool debugDynRollupLoops = false;
+
+
+STATISTIC(NumLoopsRolled, "Number of loops rolled up");
+STATISTIC(NumDynLoopsRolled, "Number of dynamic loops rolled up");
+STATISTIC(NumTotalLoops, "Number of total loops");
+
+// An anonymous namespace for the pass. Things declared inside it are
+// only visible to the current file.
+namespace {
+
+  // Derived from FunctionPass to count qbits in functions
+  struct DynRollupLoops : public ModulePass {
+    static char ID; // Pass identification
+
+    //map<BasicBlock*, bool> blockCollapse; //roll this loop
+    vector<BasicBlock*> blockCollapse; //roll this loop
+    map<BasicBlock*, string> blockRepCond; //repeat condition
+    map<BasicBlock*, BasicBlock*> blockBodyInc; //map for.body and for.inc
+    vector<BasicBlock*> blockForAll; //list of forall basicblocks
+    map<BasicBlock*, int> bbTripCount; //non zero trip count of loops
+
+    map<BasicBlock*, Instruction*> bbFirstInst;
+    map<BasicBlock*, BinaryOperator*> bbIncrInst;
+    map<BasicBlock*, ICmpInst*> bbICmpInst;
+    map<BasicBlock*, PHINode*> bbPhiInst;
+    map<BasicBlock*, Value*> bbTripCountVal;
+
+    Function* dummyStartLoop32; //dummyFunc to mark start of loop      
+    Function* dummyStartLoop64; //dummyFunc to mark start of loop      
+    Function* dummyEndLoop; //dummyFunc to mark start of loop
+
+    DynRollupLoops() : ModulePass(ID) {}
+    //AnalysisUsage AU;
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.addRequired<LoopInfo>();
+      AU.addPreserved<LoopInfo>();
+      AU.addRequired<ScalarEvolution>();
+      AU.addPreserved<ScalarEvolution>();            
+    }
+
+
+    /*void print_blockForAll(){
+      errs() << "Printing blockForAll: \n";
+      for(vector<BasicBlock*>::iterator vit = blockForAll.begin(); vit!=blockForAll.end();++vit)
+      errs() << (*vit) << ":" << (*vit)->getName() << " ";
+      errs() << "\n";
+
+      }*/
+
+    bool checkIfQuantumType(Type* t) {
+      bool isQtmTy = true;
+
+      if(t->isIntegerTy(16) || t->isIntegerTy(1))
+        isQtmTy &= true;
+      else if(ArrayType *arrayType = dyn_cast<ArrayType>(t))
+      {
+        Type *elementType = arrayType->getElementType();
+        if(elementType->isIntegerTy(16) || elementType->isIntegerTy(1))
+          isQtmTy &= true;
+        else isQtmTy &= false;
+      }	      
+      else if(t->isPointerTy()){
+        Type* elementType = t->getPointerElementType();
+        if(elementType->isIntegerTy(16) || elementType->isIntegerTy(1))
+          isQtmTy &= true;
+      }
+      else{
+        isQtmTy = false;
+
+      }
+
+      return isQtmTy;
+    }    
+
+    bool checkIfGoesToLatch(BasicBlock* BB, BasicBlock* Latch) {
+      // --At least one successor of BB is latch 
+      bool isGoing = false;
+      for (pred_iterator PI = pred_begin(Latch), E = pred_end(Latch); PI != E; ++PI) {
+        BasicBlock *PredBB = *PI;
+        if (PredBB==BB)
+          isGoing = true;
+      }     
+      return isGoing;
+    }
+
+    bool checkIfQuantum(BasicBlock* BB) {
+
+      //--does not allow non-constant integer/double arguments to calls
+      //--must contain atleast one call instruction
+
+
+      //Does not allow arithmetic/compare instructions
+      //Does not allow function calls to have non-qbit/non-cbit arguments
+      //all gepi instructions muct depend directly on indvar
+
+      bool isQtm = true;
+
+      string indVarStr = "";
+
+      /*if(BB->size() <= 2){ //phi inst and branch inst 
+        errs() << "Num of insts <= 2 \n";
+        return false;
+        }*/
+      if (debugDynRollupLoops)
+        errs() << "BB name: " << BB->getName() << "\n";
+
+      bool hasOtherThanPhiAndBrInst = false;      
+      //bool bodyHasIndVarComputation = false;
+      bool hasCallInst = false; //must have atleast one call inst
+
+      for(BasicBlock::iterator bbi = BB->begin(); bbi != BB->end(); ++bbi)
+      {
+        if(debugDynRollupLoops)
+          errs() << *bbi << "\n";
+        /*
+           if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(&*bbi)){
+           if(debugDynRollupLoops)
+           errs() << "Is a GEPI \n";
+
+           hasOtherThanPhiAndBrInst = true;
+
+        //check type of GEPI inst first
+        Type* gepiType = GEPI->getType();
+
+        if(!checkIfQuantumType(gepiType)){
+        isQtm = false;
+        if(debugDynRollupLoops)
+        errs() << "Unrecognized Type of GEPI Inst. \n";
+        break;
+        }
+
+        //check indices of GEPI inst next: should be constant or indvars
+        if(isQtm && GEPI->hasIndices())
+        {
+        unsigned numOps = GEPI->getNumOperands();
+        for(unsigned opIter=1; opIter < numOps; opIter++)
+        {
+        Value* opInst = GEPI->getOperand(opIter);
+
+        if(opInst->getName().str()==indVarStr){
+        //bodyHasIndVarComputation = true;
+        //errs() << "IndVar is present in block \n";
+        blockForAll.push_back(BB);
+        //print_blockForAll();
+        }      
+
+        if(isa<ConstantInt>(opInst)){
+        isQtm &= true;
+        }
+        //else if(opInst->getName().find("indvars.iv")!=string::npos)
+        else if(opInst->getName().str()==indVarStr)
+        isQtm &= true;
+        else{
+        isQtm = false;
+        if(debugDynRollupLoops)
+        errs() << "GEPI indices do not satisfy qtm block criteria \n";
+        return isQtm;
+        //break;
+        }
+
+        }
+        }
+        }
+
+        else if(isa<LoadInst>(*bbi)){
+        if(debugDynRollupLoops)
+        errs() << "Is a Load \n";
+        }
+
+
+        else if(isa<TruncInst>(*bbi)){
+        if(debugDynRollupLoops)
+        errs() << "Is Trunc \n";
+        }
+
+        else if(isa<PHINode>(*bbi)){
+        if(debugDynRollupLoops)
+        errs() << "Is a PHI Node \n";
+        //errs() << *bbi << "\n";
+        indVarStr = (*bbi).getName();
+        //errs() << "Phi Node Var = " << (*bbi).getName() << "\n";
+        }
+
+        else*/ 
+        if(CallInst *CI = dyn_cast<CallInst>(&*bbi))
+        {
+          hasOtherThanPhiAndBrInst = true;
+          hasCallInst = true;
+          /*
+             if((CI->getCalledFunction()->getName() == "llvm.PrepZ") || (CI->getCalledFunction()->getName() == "llvm.PrepX")){
+             isQtm &= true;
+          //errs() << "Found PrepZ or PrepX\n";		
+          }
+          else{
+           */
+
+          //check if all operands of call inst are i16 or i16*
+          //if not i16 or i16*, they should be constant integers i64 or i32 or floats
+          for(unsigned iop=0;iop<CI->getNumArgOperands();iop++){
+            Type* argType = CI->getArgOperand(iop)->getType();
+
+            //errs() << "Called Func = " << CI->getCalledFunction()->getName() << "\n";
+            //errs() << "Call inst = " << *CI << "\n";
+
+            if(argType->isIntegerTy(32) || argType->isIntegerTy(64)){
+              //must be constant int
+              if(!isa<ConstantInt>(CI->getArgOperand(iop))){
+                if(debugDynRollupLoops)
+                  errs() << "Not a constant int \n";
+                return false;
+              }
+            }
+            else if(argType->isDoubleTy() || argType->isFloatTy()){
+              //must be constant
+              if(!isa<ConstantFP>(CI->getArgOperand(iop))){
+                if(debugDynRollupLoops)
+                  errs() << "Not a constant double/float \n";
+                return false;
+              }
+            }
+            else if(!checkIfQuantumType(argType)){
+              if(debugDynRollupLoops)
+                errs() << "Operand Type of Call inst is non-quantum \n";
+              //isQtm = false;
+              return false; 
+            }
+            //else errs() << "Is qtm \n";
+          }
+          //}
+        }
+
+        /*
+           else if(isa<BranchInst>(*bbi)){
+           if(debugDynRollupLoops)
+           errs() << "Is a Branch Inst \n";
+           }
+
+           else{
+           if(debugDynRollupLoops)
+           errs() << "Unrecognized in quantum module. \n";
+        //isQtm = false;
+        return false;
+        //break;
+        }*/
+      }
+
+      if(hasOtherThanPhiAndBrInst)
+        return isQtm;
+      else{
+        //errs() << "Only contains Phi and Br \n";
+        return false;
+
+      }
+    }
+
+
+
+    void getIncAndCmpConditions(Loop *L, BasicBlock *BB, BasicBlock* Header){
+      if(debugDynRollupLoops)
+        errs() << "Basic Block: " << BB->getName() << "\n";
+
+      //map<BasicBlock*, bool>::iterator mapIter = blockCollapse.find(Header);
+      //vector<BasicBlock*>::iterator mapIter = find(blockCollapse.begin(), blockCollapse.end(), Header);
+      //if(mapIter!=blockCollapse.end())
+      //if((*mapIter).second == true)
+      //{
+
+      if(debugDynRollupLoops)
+        errs() << "Basic Block: " << BB->getName() << "\n";
+
+      stringstream loopRepStr;
+      stringstream incVal;
+      stringstream cmpVal;
+      stringstream initVal;
+
+      stringstream incVal2;
+      stringstream cmpVal2;
+      stringstream initVal2;
+
+
+      int initAt = 0;
+      int incBy = 0;
+      int endAt = 0;
+
+      bool initConst = false;
+      bool endConst = false;
+
+      //PHINode* PN;
+      //unsigned IncomingEdge;
+      //unsigned BackEdge;
+
+
+      Value* inVal;
+      Value* outVal;
+
+      BasicBlock::iterator firstIter = Header->begin();
+      while(isa<PHINode>(&*firstIter)) ++firstIter;
+      Instruction* FirstInst = &*(firstIter);
+
+      if(debugDynRollupLoops)
+        errs() << "First Inst of BB body = " << *FirstInst << "\n";
+
+      //get initVal str
+      for(BasicBlock::iterator hIter = Header->begin(); hIter!=Header->end(); ++hIter)
+      {
+        //find phinode - process only the first phinode found
+        if(PHINode *PN = dyn_cast<PHINode>(&*hIter)){ //assuming we will get one PHI node at the beginning of the block. Will get this if -indvars has been run on the code before.
+          //errs() << "Found PHI Node \n";
+          //errs() << *PN << "\n";
+
+          bbPhiInst[Header] = PN;
+
+          unsigned IncomingEdge = L->contains(PN->getIncomingBlock(0));	       
+          unsigned BackEdge     = IncomingEdge^1;
+          if(ConstantInt *CInt = dyn_cast<ConstantInt>(PN->getIncomingValue(IncomingEdge))){
+            int val = CInt->getZExtValue();
+            if(debugDynRollupLoops)
+              errs() << "Incoming Value = "<< val << "\n";
+            initVal << "i="<<val;
+            initVal2 << val;
+            initAt = val;
+            initConst = true;
+
+          }
+          else{
+            //Incoming Value will be set at runtime
+            inVal = PN->getIncomingValue(IncomingEdge);
+            if(debugDynRollupLoops)
+              errs() << "Found dyn Incoming Value = "<< inVal->getName() << "\n";
+            ++NumDynLoopsRolled;
+
+          }
+
+          if(BinaryOperator *Incr = dyn_cast<BinaryOperator>(PN->getIncomingValue(BackEdge))){
+
+            bbIncrInst[BB] = Incr;
+
+            //Instruction* bInst = &*bbi;
+            unsigned instOp = Incr->getOpcode();
+
+            //for(BasicBlock::iterator bbi = BB->begin(); bbi != BB->end(); ++bbi)
+            //{
+            if(debugDynRollupLoops)
+              errs() << *Incr << "\n";
+
+            //Instruction* bInst = &*bbi;
+            //unsigned instOp = bInst->getOpcode();
+            if(instOp == Instruction::Add || instOp == Instruction::Sub){
+
+              unsigned numOps = Incr->getNumOperands();
+              for(unsigned opIter=0; opIter < numOps; opIter++)
+              {
+                Value* opInst = Incr->getOperand(opIter);
+
+                if(ConstantInt *CI = dyn_cast<ConstantInt>(opInst)){
+                  int val = CI->getZExtValue();
+                  if(debugDynRollupLoops)
+                    errs() << "Arith value = "<< val << "\n";
+
+                  if(instOp == Instruction::Add){
+                    if(val == 1) { incVal << "i++"; incBy = -1; incVal2<<1; }
+                    else if(val == -1) { incVal << "i--"; incBy = 1; incVal2<< -1; }
+                    else if(val>0) {incVal << "i+=" << val; incBy = -1*val; incVal2<<val; }
+                    else if(val<0) {incVal << "i-=" << val; incBy = val; incVal2 << val; }		  
+                  }
+
+                  if(instOp == Instruction::Sub){
+                    if(val == 1) { incVal << "i--"; incBy = 1; incVal2 << -1; }
+                    else if(val == -1) { incVal << "i++"; incBy = -1; incVal2<< 1; }
+                    else if(val>0) { incVal << "i-=" << val; incBy = val; incVal2 << val; }		  
+                    else if(val<0) { incVal << "i+=" << val; incBy = -1*val; incVal2<<val; }		  
+                  }
+
+                  assert((incBy==1 || incBy==-1) && "Loop Step Value NOT EQ 1");
+
+                }
+                //else if(Incr->getName().find("indvars.iv")==string::npos)
+                //errs() << "WARNING: Not an inc instruction. \n";
+              }
+
+            } //end of inst::Add or Inst::Sub		    
+          } //end of Incr
+          break; // process only one Phi Node
+          } //end of PHI Node
+        } //end of BB iterator
+
+        bool addOne = false;
+        bool biggerEnd = false;
+        bool subOne = false;
+
+        for(BasicBlock::iterator bbi = BB->begin(); bbi != BB->end(); ++bbi)
+        {
+          if(debugDynRollupLoops)
+            errs() << "Inst : " << *bbi << "\n";
+
+          Instruction* bInst = &*bbi;
+
+          if(ICmpInst *IC = dyn_cast<ICmpInst>(bInst))
+          {
+            if(debugDynRollupLoops)
+              errs() << "Compare Inst = "<<*IC<<"\n";
+
+            bbICmpInst[BB] = IC;
+
+            int val = INT_MAX;
+
+            unsigned numOps = IC->getNumOperands();
+            //for(unsigned opIter=0; opIter < numOps; opIter++)
+            unsigned opIter = 1;//check only second operand
+            {
+              Value* opInst = IC->getOperand(opIter);
+
+              if(ConstantInt *CI = dyn_cast<ConstantInt>(opInst)){
+                val = CI->getZExtValue();
+                if(debugDynRollupLoops)
+                  errs() << "Arith value = "<< val << "\n";
+
+              }
+
+              else{
+
+                //trace back once to check if result of trunc inst 
+                //if so, use the operand of trunc inst as outVal
+                if(isa<TruncInst>(opInst)){
+                  Instruction* TI = dyn_cast<Instruction>(opInst);
+                  if(debugDynRollupLoops)
+                    errs() << "Is from a trunc inst \n";
+                  opInst = TI->getOperand(0);
+                }
+
+                outVal = opInst;
+                //if(outVal->getName() != "")
+                if(debugDynRollupLoops)		  
+                  errs() << "Dyn Cmp Value = "<< outVal->getName() << " Type = " << outVal->getType()->getTypeID() << "\n";			  
+                ++NumDynLoopsRolled;
+              }
+
+              //else if(opInst->getName().find("indvars.iv")==string::npos)
+              //errs() << "WARNING: Not an inc instruction. \n";
+            }
+
+
+            if(val!= INT_MAX)
+              endConst = true;
+
+            //{
+            unsigned icmp_cond = IC->getUnsignedPredicate();
+            switch(icmp_cond){
+              case CmpInst::ICMP_EQ:
+                if(endConst){
+                  cmpVal << "i=" << val;
+                  cmpVal2 << val;
+                  endAt = val; }
+                break;
+              case CmpInst::ICMP_NE:
+                if(endConst){
+                  cmpVal << "i!=" << val;
+                  cmpVal2 << val+incBy;
+                  endAt = val+incBy; }
+                else { addOne = false; subOne = false; }
+                biggerEnd = true; 
+
+                break;
+              case CmpInst::ICMP_UGT:
+              case CmpInst::ICMP_SGT:
+                if(endConst){
+                  cmpVal << "i>" << val;
+                  cmpVal2 << val+incBy;
+                  endAt = val; //+incBy; 
+                }
+                else { addOne = false; subOne = false; }
+                biggerEnd = false; 
+                //errs() << "greater \n";
+                break;
+              case CmpInst::ICMP_UGE:
+              case CmpInst::ICMP_SGE:
+                if(endConst){
+                  cmpVal << "i>=" << val;
+                  cmpVal2 << val;
+                  endAt = val+incBy; }
+                else { addOne = false; subOne = true; }
+                biggerEnd = false; 
+                //errs() << "greater or equal \n";
+                break;
+              case CmpInst::ICMP_ULT:
+              case CmpInst::ICMP_SLT:
+                if(endConst){
+                  cmpVal << "i<" << val;
+                  cmpVal2 << val+incBy;
+                  endAt = val; //+incBy; }
+            }			 
+            else { addOne =  false; subOne = false; }
+            biggerEnd = true; 
+            //errs() << "less \n";
+            break;
+            case CmpInst::ICMP_ULE:
+            case CmpInst::ICMP_SLE:
+            if(endConst){
+              cmpVal << "i<=" << val;
+              cmpVal2 << val;
+              endAt = val+incBy; }			
+            else { addOne=true; subOne = false; }
+            biggerEnd = true;
+            //errs() << "less equal \n";
+            break;		  
+          } //end of switch
+          //}	       	      
+
+
+
+        } //end of Icmp Inst	
+      } //end of BB iterator       		      
+
+
+      BinaryOperator* Bout = NULL;
+      bool useStoredVal = false;
+      Value* storedVal = NULL;
+      { //hello
+        if(addOne && biggerEnd) //end - start
+        {		
+          if(initConst && !endConst) //initAt = constant, endAt not constant
+          {
+            BinaryOperator* BO = BinaryOperator::Create(Instruction::Add, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+
+            errs() << "insert 1 initVal = " << initAt << " endAt Ptr = " << outVal->getName()<< "\n";
+
+            if(initAt!=0)
+              Bout = BinaryOperator::Create(Instruction::Sub, (Value*)BO, ConstantInt::get(outVal->getType(),initAt),"", FirstInst);		      		    
+            else{
+              useStoredVal = true;
+              storedVal = outVal;
+            }
+          }
+          else if(!initConst && endConst) //initAt NOT const, endAt const
+          {
+            errs() << "insert 2 \n";
+            Bout = BinaryOperator::Create(Instruction::Sub, ConstantInt::get(inVal->getType(),endAt), inVal,"", FirstInst);
+          }
+          else if(!initConst && !endConst) //both NOT const
+          {		    		   		    
+            unsigned b1 = inVal->getType()->getIntegerBitWidth();
+            unsigned b2 = outVal->getType()->getIntegerBitWidth();
+
+            errs() << "insert 3 \n";
+
+            if(b1>b2){
+              CastInst* TI = CastInst::CreateTruncOrBitCast(inVal,outVal->getType(),"",FirstInst);
+              BinaryOperator* BO = BinaryOperator::Create(Instruction::Add, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+              Bout = BinaryOperator::Create(Instruction::Sub, (Value*)BO, (Value*)TI,"", FirstInst);		      
+            }
+            else{
+              BinaryOperator* BO = BinaryOperator::Create(Instruction::Add, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+              CastInst* TI = CastInst::CreateTruncOrBitCast((Value*)BO,inVal->getType(),"",FirstInst);
+              Bout = BinaryOperator::Create(Instruction::Sub, (Value*)TI, inVal,"", FirstInst);		      
+            }
+          }
+        } //end addOne and biggerEnd
+
+        else if(addOne && !biggerEnd) //start - end
+        {
+
+          if(initConst && !endConst) //initAt = constant, endAt not constant
+          {
+            errs() << "insert 4 initVal = " << initAt << " endAt Ptr = " << outVal->getName()<< "\n";		    		    
+            BinaryOperator* BO = BinaryOperator::Create(Instruction::Add, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);		    
+            Bout = BinaryOperator::Create(Instruction::Sub, ConstantInt::get(outVal->getType(),initAt),(Value*)BO, "", FirstInst);
+          }
+          else if(!initConst && endConst) //initAt NOT const, endAt const
+          {
+            errs() << "insert 5 \n";
+            Bout = BinaryOperator::Create(Instruction::Sub, inVal, ConstantInt::get(inVal->getType(),endAt), "", FirstInst);
+          }
+          else if(!initConst && !endConst) //both NOT const
+          {                             
+            unsigned b1 = inVal->getType()->getIntegerBitWidth();
+            unsigned b2 = outVal->getType()->getIntegerBitWidth();
+
+            errs() << "insert 6 \n";
+
+            if(b1>b2){
+              CastInst* TI = CastInst::CreateTruncOrBitCast(inVal,outVal->getType(),"",FirstInst);
+              BinaryOperator* BO = BinaryOperator::Create(Instruction::Add, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+              Bout = BinaryOperator::Create(Instruction::Sub, (Value*)TI, (Value*)BO, "", FirstInst);
+            }
+            else{
+              BinaryOperator* BO = BinaryOperator::Create(Instruction::Add, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+              CastInst* TI = CastInst::CreateTruncOrBitCast((Value*)BO,inVal->getType(),"",FirstInst);		      
+              Bout = BinaryOperator::Create(Instruction::Sub, inVal, (Value*)TI, "", FirstInst);
+
+            }
+          }
+        } //end addOne and not biggerEnd
+
+        else if(subOne && biggerEnd) //end - start
+        {
+
+          if(initConst && !endConst) //initAt = constant, endAt not constant
+          {
+            errs() << "insert 7 initVal = " << initAt << " endAt Ptr = " << outVal->getName()<< "\n";
+            BinaryOperator* BO = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+
+            if(initAt!=0)		      
+              Bout = BinaryOperator::Create(Instruction::Sub, (Value*)BO, ConstantInt::get(outVal->getType(),initAt),"", FirstInst);
+            else{
+              useStoredVal = true;
+              storedVal = (Value*)BO;
+            }
+          }
+          else if(!initConst && endConst) //initAt NOT const, endAt const
+          {
+            Bout = BinaryOperator::Create(Instruction::Sub, ConstantInt::get(inVal->getType(),endAt), inVal,"", FirstInst);
+          }
+          else if(!initConst && !endConst) //both NOT const
+          {		    		              
+            unsigned b1 = inVal->getType()->getIntegerBitWidth();
+            unsigned b2 = outVal->getType()->getIntegerBitWidth();
+
+
+            if(b1>b2){
+              CastInst* TI = CastInst::CreateTruncOrBitCast(inVal,outVal->getType(),"",FirstInst);
+              BinaryOperator* BO = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+              Bout = BinaryOperator::Create(Instruction::Sub, (Value*)BO, (Value*)TI,"", FirstInst);
+            }
+            else{
+              BinaryOperator* BO = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+              CastInst* TI = CastInst::CreateTruncOrBitCast((Value*)BO,inVal->getType(),"",FirstInst);		      
+              Bout = BinaryOperator::Create(Instruction::Sub, (Value*)TI, inVal,"", FirstInst);		      
+            }
+          }
+          else errs() << "WARNING: This case should not occur. TripCount should have been known by here.\n";                
+        } //end of subOne and biggerEnd
+
+        else if(subOne && !biggerEnd) //start - end
+        {
+
+          if(initConst && !endConst) //initAt = constant, endAt not constant
+          {
+            BinaryOperator* BO = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);		    
+            Bout = BinaryOperator::Create(Instruction::Sub, ConstantInt::get(outVal->getType(),initAt),(Value*)BO, "", FirstInst);
+          }
+          else if(!initConst && endConst) //initAt NOT const, endAt const
+          {
+            Bout = BinaryOperator::Create(Instruction::Sub, inVal, ConstantInt::get(inVal->getType(),endAt), "", FirstInst);
+          }
+          else if(!initConst && !endConst) //both NOT const
+          {		    		    		    
+            unsigned b1 = inVal->getType()->getIntegerBitWidth();
+            unsigned b2 = outVal->getType()->getIntegerBitWidth();
+
+
+            if(b1>b2){
+              CastInst* TI = CastInst::CreateTruncOrBitCast(inVal,outVal->getType(),"",FirstInst);
+              BinaryOperator* BO = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+              Bout = BinaryOperator::Create(Instruction::Sub, (Value*)TI, (Value*)BO, "", FirstInst);
+            }
+            else{
+              BinaryOperator* BO = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+              CastInst* TI = CastInst::CreateTruncOrBitCast((Value*)BO,inVal->getType(),"",FirstInst);		      
+              Bout = BinaryOperator::Create(Instruction::Sub, inVal, (Value*)TI, "", FirstInst);
+            }
+          }
+        } //end of subOne and NOT biggerEnd
+
+        else if(!addOne && !subOne && biggerEnd) //end - start
+        {
+
+          if(initConst && !endConst) //initAt = constant, endAt not constant
+          {
+
+            if(initAt!=0)		      
+              Bout = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),initAt),"", FirstInst);
+            else{
+              useStoredVal = true;
+              storedVal = outVal;
+            }
+          }
+          else if(!initConst && endConst) //initAt NOT const, endAt const
+          {
+            Bout = BinaryOperator::Create(Instruction::Sub, ConstantInt::get(inVal->getType(),endAt), inVal,"", FirstInst);
+          }
+          else if(!initConst && !endConst) //both NOT const
+          {		    		              
+            unsigned b1 = inVal->getType()->getIntegerBitWidth();
+            unsigned b2 = outVal->getType()->getIntegerBitWidth();
+
+            if(b1>b2){
+              CastInst* TI = CastInst::CreateTruncOrBitCast(inVal,outVal->getType(),"",FirstInst);
+              Bout = BinaryOperator::Create(Instruction::Sub, outVal, (Value*)TI,"", FirstInst);
+            }
+            else{
+              CastInst* TI = CastInst::CreateTruncOrBitCast(outVal,inVal->getType(),"",FirstInst);		      
+              Bout = BinaryOperator::Create(Instruction::Sub, (Value*)TI, inVal,"", FirstInst);		      
+            }
+          }
+          if(debugDynRollupLoops)
+            errs() << "useStoredValue 1 = " <<useStoredVal << "\n";
+        } //end of subOne and biggerEnd
+
+        else if(!addOne && !subOne && !biggerEnd) //start - end
+        {
+
+          if(initConst && !endConst) //initAt = constant, endAt not constant
+          {
+            Bout = BinaryOperator::Create(Instruction::Sub, ConstantInt::get(outVal->getType(),initAt),outVal, "", FirstInst);
+          }
+          else if(!initConst && endConst) //initAt NOT const, endAt const
+          {
+            Bout = BinaryOperator::Create(Instruction::Sub, inVal, ConstantInt::get(inVal->getType(),endAt), "", FirstInst);
+          }
+          else if(!initConst && !endConst) //both NOT const
+          {		    		    		    
+            unsigned b1 = inVal->getType()->getIntegerBitWidth();
+            unsigned b2 = outVal->getType()->getIntegerBitWidth();
+
+
+            if(b1>b2){
+              CastInst* TI = CastInst::CreateTruncOrBitCast(inVal,outVal->getType(),"",FirstInst);
+              Bout = BinaryOperator::Create(Instruction::Sub, (Value*)TI, outVal, "", FirstInst);
+            }
+            else{		      
+              CastInst* TI = CastInst::CreateTruncOrBitCast(outVal,inVal->getType(),"",FirstInst);		      
+              Bout = BinaryOperator::Create(Instruction::Sub, inVal, (Value*)TI, "", FirstInst);
+            }
+          }
+        } //end of NOT biggerEnd
+      }                    
+      //if(useStoredVal) errs() << "StoredVal: " << storedVal->getName() << "\n";
+      //errs() << " 15e \n";
+
+      if(useStoredVal) bbTripCountVal[Header] = storedVal;
+      else 
+        if(Bout!=NULL)
+          bbTripCountVal[Header] = (Value*)Bout;
+
+
+
+      blockBodyInc[Header] = BB;
+      bbFirstInst[Header] = FirstInst;
+
+
+      /*
+
+         if(initVal.str()!="" && cmpVal.str()!="" && incVal.str()!=""){
+      //errs() << "Searching blockForAll for " << Header << ":" << Header->getName() << "\n";
+      vector<BasicBlock*>::iterator isForAll = find(blockForAll.begin(), blockForAll.end(),Header);
+      if(isForAll!=blockForAll.end())		
+      //loopRepStr << "forall "<< initVal.str() << "; " << cmpVal.str() << "; " << incVal.str();
+      loopRepStr << "forall ["<< initVal2.str() << ":" << cmpVal2.str() << ":" << incVal2.str() << "]";
+
+      else{
+      //loopRepStr << "repeat "<< initVal.str() << "; " << cmpVal.str() << "; " << incVal.str();
+      int numRepeats = endAt - initAt + 1;
+      if(numRepeats>0)
+      loopRepStr << "repeat "<< (endAt-initAt+1) << " times ";
+      }
+      }
+      if(debugDynRollupLoops)
+      errs() << "Rep String1 = " << loopRepStr.str() << "\n";
+
+      blockRepCond[Header] = loopRepStr.str();*/
+      //}
+
+    }
+
+
+    void getBBInsts(Loop *L,BasicBlock* BB,BasicBlock* Header)
+    {
+      if(debugDynRollupLoops)
+        errs() << "getBBInsts: BB = " << BB->getName() << "\n";
+      blockBodyInc[Header] = BB;
+
+      BasicBlock::iterator firstIter = Header->begin();
+      //if(isa<PHINode>(*firstIter)){
+      if(PHINode *PN = dyn_cast<PHINode>(&*firstIter)){ //assuming we will get one PHI node at the beginning of the block. Will get this if -indvars has been run on the code before.       
+        bbPhiInst[Header] = PN;
+        if(debugDynRollupLoops)
+
+          errs() << "Found PHI \n";
+
+        unsigned IncomingEdge = L->contains(PN->getIncomingBlock(0));	       
+        unsigned BackEdge     = IncomingEdge^1;
+
+        if(BinaryOperator *Incr = dyn_cast<BinaryOperator>(PN->getIncomingValue(BackEdge))){
+          bbIncrInst[BB] = Incr;
+          if(debugDynRollupLoops)
+            errs() << "Found Incr : " << *Incr << "\n";
+        }
+      }
+
+      while(isa<PHINode>(&*firstIter)) ++firstIter;
+      Instruction* FirstInst = &*(firstIter);
+      bbFirstInst[Header] = FirstInst;
+
+
+
+      for(BasicBlock::iterator bbi = BB->begin(); bbi != BB->end(); ++bbi)
+      {
+        if(debugDynRollupLoops)
+          errs() << "Inst : " << *bbi << "\n";
+
+        Instruction* bInst = &*bbi;
+
+        if(ICmpInst *IC = dyn_cast<ICmpInst>(bInst))
+        {
+          if(debugDynRollupLoops)
+            errs() << "Found Compare Inst = "<<*IC<<"\n";
+
+          bbICmpInst[BB] = IC;
+          break;
+        }
+
+      }
+
+    }
+
+
+    bool checkIfQuantumHeaderLatch(Loop *L, BasicBlock *BB){
+      //One arithmetic/compare instruction on indvar
+      //Does not allow function calls to have non-qbit/non-cbit arguments
+      //all gepi instructions muct depend directly on indvar
+
+      //distinguishes between repeat loops and forall loops
+      //repeat loops do not have indvar in its body
+
+      //errs() << "In checkIfQuantumHeaderLatch \n";
+
+      bool isQtm = true;
+
+      bool bodyHasIndVarComputation = false;
+
+      string indVarStr = "";
+      stringstream loopRepStr;
+      stringstream incVal;
+      stringstream cmpVal;
+      stringstream initVal;
+
+      stringstream incVal2;
+      stringstream cmpVal2;
+      stringstream initVal2;
+
+      int incBy = 0;
+      int initAt = 0;
+      int endAt = 0;
+
+      bool hasOtherThanPhiAndBrInst = false;      
+
+      Instruction* incrInst = NULL;
+
+      for(BasicBlock::iterator bbi = BB->begin(); bbi != BB->end(); ++bbi)
+      {
+        if(debugDynRollupLoops)
+          errs() << *bbi << "\n";
+
+        if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(&*bbi)){
+          if(debugDynRollupLoops)
+            errs() << "Is a GEPI \n";
+
+          hasOtherThanPhiAndBrInst = true;
+
+          //check type of GEPI inst first
+          Type* gepiType = GEPI->getType();
+
+          if(!checkIfQuantumType(gepiType)){
+            isQtm = false;
+            if(debugDynRollupLoops)
+              errs() << "Unrecognized Type of GEPI Inst. \n";
+            break;
+          }
+
+          //check indices of GEPI inst next: should be constant or indvars
+          if(isQtm && GEPI->hasIndices())
+          {
+            unsigned numOps = GEPI->getNumOperands();
+            for(unsigned opIter=1; opIter < numOps; opIter++)
+            {
+              Value* opInst = GEPI->getOperand(opIter);
+
+              if(opInst->getName().str()==indVarStr){
+                //errs() << "2: Body has IndVar \n";
+                bodyHasIndVarComputation = true;
+              }    
+
+              if(isa<ConstantInt>(opInst)){
+                isQtm &= true;
+              }
+              //else if(opInst->getName().find("indvars.iv")!=string::npos)
+              else if(opInst->getName().str()==indVarStr)
+                isQtm &= true;
+              else{
+                //isQtm = false;
+                if(debugDynRollupLoops)
+                  errs() << "GEPI indices do not satisfy qtm block criteria \n";
+                return false;
+                //break;
+              }
+
+            }
+          }
+        }
+
+        else if(isa<LoadInst>(*bbi)){
+          if(debugDynRollupLoops)
+            errs() << "Is a Load \n";
+        }
+
+
+        else if(isa<TruncInst>(*bbi)){
+          if(debugDynRollupLoops)
+            errs() << "Is Trunc \n";
+        }
+
+
+        else if(PHINode *PN = dyn_cast<PHINode>(&*bbi)){ //assuming we will get one PHI node at the beginning of the block
+
+          if(debugDynRollupLoops)
+            errs() << "Is a PHI Node \n";
+          //errs() << *bbi << "\n";
+          indVarStr = (*bbi).getName();
+          //errs() << "Phi Node Var = " << (*bbi).getName() << "\n";
+
+
+          //errs() << "Found PHI Node \n";
+          //errs() << *PN << "\n";
+
+          unsigned IncomingEdge = L->contains(PN->getIncomingBlock(0));	       
+          unsigned BackEdge     = IncomingEdge^1;
+          if(ConstantInt *CInt = dyn_cast<ConstantInt>(PN->getIncomingValue(IncomingEdge))){
+            int val = CInt->getZExtValue();
+            if(debugDynRollupLoops)
+              errs() << "Incoming Value = "<< val << "\n";
+            initVal << "i="<<val;
+            initVal2 << val;
+            initAt = val;	     
+          }
+
+          if(BinaryOperator *Incr = dyn_cast<BinaryOperator>(PN->getIncomingValue(BackEdge))){
+            //Instruction* bInst = &*bbi;
+            unsigned instOp = Incr->getOpcode();
+            incrInst = Incr; //save incr inst
+
+            if(debugDynRollupLoops)
+              errs() << *Incr << "\n";
+
+            if(instOp == Instruction::Add || instOp == Instruction::Sub){
+
+              unsigned numOps = Incr->getNumOperands();
+              for(unsigned opIter=0; opIter < numOps; opIter++)
+              {
+                Value* opInst = Incr->getOperand(opIter);
+
+                if(ConstantInt *CI = dyn_cast<ConstantInt>(opInst)){
+                  int val = CI->getZExtValue();
+                  if(debugDynRollupLoops)
+                    errs() << "Arith value = "<< val << "\n";
+
+                  if(instOp == Instruction::Add){
+                    if(val == 1) { incVal << "i++"; incVal2 << 1; incBy = -1; }
+                    else if(val == -1) { incVal << "i--"; incVal2 << -1; incBy = 1; }
+                    else if(val>0) incVal << "i+=" << val;
+                    else if(val<0) incVal << "i-=" << val;		  
+                  }
+
+                  if(instOp == Instruction::Sub){
+                    if(val == 1) { incVal << "i--"; incVal2<<-1; incBy=1; }
+                    else if(val == -1) { incVal << "i++"; incVal2<<1; incBy=-1; }
+                    else if(val>0) incVal << "i-=" << val;
+                    else if(val<0) incVal << "i+=" << val;		  
+                  }
+
+                }
+              }
+
+            } //end of inst::Add or Inst::Sub		    
+          } //end of Incr
+        }	    	  
+
+        else if(CallInst *CI = dyn_cast<CallInst>(&*bbi))
+        {
+          hasOtherThanPhiAndBrInst = true;
+
+          /*if((CI->getCalledFunction()->getName() == "llvm.PrepZ") || (CI->getCalledFunction()->getName() == "llvm.PrepX")){
+            isQtm &= true;
+          //errs() << "Found PrepZ or PrepX\n";		
+          }
+          else{
+           */
+          //check if all operands of call inst are i16 or i16*
+          //if not i16 or i16*, they should be constant integers i64 or i32
+          for(unsigned iop=0;iop<CI->getNumArgOperands();iop++){
+            //if(debugDynRollupLoops)
+            //errs() << "Processing arg num = " << iop << "\n";
+
+            Type* argType = CI->getArgOperand(iop)->getType();
+
+            //errs() << "Called Func = " << CI->getCalledFunction()->getName() << "\n";
+            //errs() << "Call inst = " << *CI << "\n";
+            if(argType->isIntegerTy(32) || argType->isIntegerTy(64)){
+              //errs() << "Arg type integer \n";
+              //must be constant int
+              if(!isa<ConstantInt>(CI->getArgOperand(iop))){
+                if(debugDynRollupLoops)
+                  errs() << "Not a constant int \n";
+                return false;
+              }
+            }
+
+            else if(!checkIfQuantumType(argType)){
+              if(debugDynRollupLoops)
+                errs() << "Operand Type of Call inst is non-quantum \n";
+              //isQtm = false;
+              return false;
+
+            }
+            //else errs() << "Call inst is qtm \n";
+          }
+          //}
+        }
+
+
+
+        else if(isa<BranchInst>(*bbi)){
+          if(debugDynRollupLoops)
+            errs() << "Is a Branch Inst \n";
+        }
+
+
+
+        else if(ICmpInst *IC = dyn_cast<ICmpInst>(&*bbi))
+        {
+          if(debugDynRollupLoops)
+            errs() << "Compare Inst = "<<*IC<<"\n";
+          int val = INT_MAX;
+
+          unsigned numOps = IC->getNumOperands();
+          for(unsigned opIter=0; opIter < numOps; opIter++)
+          {
+            Value* opInst = IC->getOperand(opIter);
+
+            if(ConstantInt *CI = dyn_cast<ConstantInt>(opInst)){
+              val = CI->getZExtValue();
+              if(debugDynRollupLoops)
+                errs() << "Arith value = "<< val << "\n";
+
+            }
+            //else if(opInst->getName().find("indvars.iv")==string::npos)
+            //errs() << "WARNING: Not an inc instruction. \n";
+          }
+
+          if(val != INT_MAX)
+          {
+            unsigned icmp_cond = IC->getUnsignedPredicate();
+            switch(icmp_cond){
+              case CmpInst::ICMP_EQ:
+                cmpVal << "i=" << val;
+                cmpVal2 << val+incBy;
+                endAt = val+incBy;
+                //errs() << "equal \n";
+                break;
+              case CmpInst::ICMP_NE:
+                cmpVal << "i!=" << val;
+                cmpVal2 << val+incBy;
+                endAt = val+incBy;
+                //errs() << "not equal \n";
+                break;
+              case CmpInst::ICMP_UGT:
+              case CmpInst::ICMP_SGT:
+                cmpVal << "i>" << val;
+                cmpVal2 << val+incBy;
+                endAt = val+incBy;
+                //errs() << "greater \n";
+                break;
+              case CmpInst::ICMP_UGE:
+              case CmpInst::ICMP_SGE:
+                cmpVal << "i>=" << val;
+                cmpVal2 << val;
+                endAt = val;
+                //errs() << "greater or equal \n";
+                break;
+              case CmpInst::ICMP_ULT:
+              case CmpInst::ICMP_SLT:
+                cmpVal << "i<" << val;
+                cmpVal2 << val+incBy;
+                endAt = val+incBy;
+                //errs() << "less \n";
+                break;
+              case CmpInst::ICMP_ULE:
+              case CmpInst::ICMP_SLE:
+                cmpVal << "i<=" << val;
+                cmpVal2 << val;
+                endAt = val;
+                //errs() << "less equal \n";
+                break;		  
+            } //end of switch
+          }	       	      
+
+        } //end of Icmp Inst	
+
+        else if(BinaryOperator *BIncr = dyn_cast<BinaryOperator>(&*bbi)){
+          if(BIncr != incrInst){
+            if(debugDynRollupLoops)
+              errs() << "unrecognized incr instr \n";
+            //debugDynRollupLoops = false;
+            return false;
+
+          }
+        }
+        else{
+          if(debugDynRollupLoops)
+            errs() << "Unrecognized in quantum module. \n";
+          //isQtm = false;
+          //debugDynRollupLoops = false;
+          return false;
+          //break;
+        }
+      }      
+
+      if(hasOtherThanPhiAndBrInst && isQtm){
+        if(initVal.str()!="" && cmpVal.str()!="" && incVal.str()!=""){
+          if(bodyHasIndVarComputation)
+            //loopRepStr << "forall "<< initVal.str() << "; " << cmpVal.str() << "; " << incVal.str();
+            loopRepStr << "forall ["<< initVal2.str() << ":" << cmpVal2.str() << ":" << incVal2.str() << "]";	    
+          else{
+            //loopRepStr << "repeat "<< initVal.str() << "; " << cmpVal.str() << "; " << incVal.str();
+            int numRepeats = endAt - initAt + 1;
+            if(numRepeats>0)	      
+              loopRepStr << "repeat "<< (endAt-initAt+1) << " times ";
+          }
+        }
+        if(debugDynRollupLoops)
+          errs() << "Rep String2 = " << loopRepStr.str() << "\n";
+
+        blockRepCond[BB] = loopRepStr.str();
+        blockBodyInc[BB] = BB;
+        //debugDynRollupLoops = false;
+        return isQtm;
+      }
+      else{
+        //errs() << "Only contains Phi and Br \n";
+        //debugDynRollupLoops = false;
+        return false;
+
+      }
+    }    
+
+    void getLoopInfo(Function& F) {
+      LoopInfo *LI = &getAnalysis<LoopInfo> ( F );
+      ScalarEvolution *SE = &getAnalysis<ScalarEvolution>( F );
+
+      for (Function::iterator BB = F.begin(), E = F.end(); BB != E; ++BB)
+      {           
+
+        string BBname = BB->getName();
+        //errs() << "Basic Block Name = "<<BBname << "\n";	    
+
+
+        Loop* L = LI->getLoopFor(&*BB);
+        if (L != NULL)
+        {    
+
+          if(BBname.find("for.body")!=string::npos){
+            ++NumTotalLoops;
+            if(debugDynRollupLoops)
+              errs() << "Counting this: "<<BBname<<"\n";
+
+            BasicBlock* Latch = L->getLoopLatch();
+            if(Latch){
+
+              int tripCount = SE->getSmallConstantTripCount(L, Latch);
+
+              if(tripCount > 1)
+                bbTripCount[BB] = tripCount;
+
+
+              if(Latch!=&*BB){
+                bool isCollapsable = (checkIfGoesToLatch(&*BB, Latch) && checkIfQuantum(&*BB));
+                if(debugDynRollupLoops)
+                  errs() << "isCollapsable = " << isCollapsable << "\n";
+
+                if(isCollapsable && tripCount!=1){		      
+                  //blockCollapse[&*BB] = isCollapsable;		    
+                  blockCollapse.push_back(&*BB);
+
+                  if(debugDynRollupLoops)
+                    errs() << "Trip Count of " << BBname << " is " << tripCount <<"\n";
+
+                  //errs() << "Latch is: " << Latch->getName() << "\n";
+
+                  if(tripCount == 0)
+                    getIncAndCmpConditions(L, Latch, &*BB);
+                  else
+                    getBBInsts(L,Latch,&*BB);
+
+
+                  //blockBodyInc[&*BB] = Latch;
+
+                  //check if it has parent - do this recursively.
+
+
+                }
+              }
+              else{ //Latch and BB are the same basic blocks
+
+                //bool isCollapsable = checkIfQuantumHeaderLatch(L,&*BB);
+                //if(debugDynRollupLoops)
+                //  errs() << "isCollapsable = " << isCollapsable << "\n";
+
+                //blockCollapse[&*BB] = isCollapsable;
+
+
+              }
+
+            }
+
+          }
+          /*
+             else if(BBname.find("for.inc") != string::npos){	      
+             BasicBlock *Header = L->getHeader();                        
+             errs() << "Parent: F[" << Header->getParent()->getName()
+             << "] Loop %" << Header->getName() << "\n";
+
+             getIncAndCmpConditions(L, &*BB, Header);
+
+             }*/
+        }
+
+        //errs() << "\n";
+      }
+    }
+
+
+    void addDummyStart(BasicBlock* BB){
+
+      //BasicBlock::iterator BBiter = BB->getFirstNonPHI();
+
+      //while(isa<AllocaInst>(BBiter))
+      //++BBiter;
+      if(debugDynRollupLoops)
+        errs() << "addDummyStart: " << BB->getName() << "\n";
+
+      map<BasicBlock*, Instruction*>::iterator fi_iter = bbFirstInst.find(BB);
+      assert(fi_iter!=bbFirstInst.end() && "First Inst not found for this BB");
+
+      Instruction* BBiter = (*fi_iter).second;
+
+      map<BasicBlock*,int>::iterator tcIter = bbTripCount.find(BB);
+      if(tcIter!=bbTripCount.end()){
+        int tripCount = (*tcIter).second;
+        //errs() << "Adding TripCount of " << BB->getName() << " is "<<tripCount<<"\n";	      	
+
+        //add dummy function with trip count as argument
+
+        Value* intArg = ConstantInt::get(Type::getInt32Ty(BB->getContext()),tripCount);
+
+        CallInst::Create(dummyStartLoop32, intArg, "",BBiter);      	
+      }
+      else{
+        map<BasicBlock*,Value*>::iterator tcvalIter = bbTripCountVal.find(BB);
+        if(tcvalIter!=bbTripCountVal.end()){
+          Value* tripCountVal = (*tcvalIter).second;
+
+          if(debugDynRollupLoops)
+            errs() << "tripcountVal name = " << tripCountVal->getName() << "\n";
+          //add dummy function with trip count as argument
+
+
+          //Value* intArg = ConstantInt::get(Type::getInt32Ty(BB->getContext()),tripCount);
+
+          if(tripCountVal->getType()->isIntegerTy(32))
+            CallInst::Create(dummyStartLoop32, tripCountVal, "",BBiter);      	
+          if(tripCountVal->getType()->isIntegerTy(64)) {
+            CastInst* TI = CastInst::CreateTruncOrBitCast(tripCountVal, Type::getInt32Ty(getGlobalContext()), "", BBiter);      
+            CallInst::Create(dummyStartLoop32, TI, "",BBiter);      	
+          }
+
+
+        }
+      }            
+    }
+
+
+    void addDummyEnd(BasicBlock* BB){
+
+      TerminatorInst *BBTerm = BB->getTerminator();
+
+      //while(isa<AllocaInst>(BBiter))
+      //++BBiter;
+
+      CallInst::Create(dummyEndLoop, "",(Instruction*)BBTerm);      
+
+      return;
+
+    }
+    void modifyIndVars(Loop* L, BasicBlock* BB){
+
+      string indVarStr = "";
+      if(debugDynRollupLoops)
+        errs() << "modifyIndVars: " << BB->getName() << "\n";
+
+      map<BasicBlock*, PHINode*>::iterator piter = bbPhiInst.find(BB);
+      assert(piter != bbPhiInst.end() && "Phi Inst for this BB not found");
+
+
+      //for(BasicBlock::iterator bbi = BB->begin(); bbi!=BB->end(); ++bbi)
+      //{
+      //if(debugDynRollupLoops)
+      //    errs()<<"\t" << *bbi<<"\n";
+
+      PHINode *PN = (*piter).second;
+      //if(PHINode *PN = dyn_cast<PHINode>(&*bbi)){
+
+      //if(debugDynRollupLoops)
+      //    errs() << "Is a PHI Node: " << *bbi << "\n";                                               
+      //  indVarStr = (*bbi).getName();
+      //errs() << "Phi Node Var = " << (*bbi).getName() << "\n";    	 
+
+      indVarStr = PN->getName();
+
+      //rewrite Init Value
+      unsigned IncomingEdge = L->contains(PN->getIncomingBlock(0));
+      //unsigned BackEdge     = IncomingEdge^1;
+
+      Value* currVal = PN->getIncomingValue(IncomingEdge);
+
+      PN->setIncomingValue(IncomingEdge,Constant::getNullValue(currVal->getType()));	    
+
+      // }
+      /*else if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(&*bbi)){
+      //check indices of GEPI inst next: should be constant or indvars          
+      if(GEPI->hasIndices())
+      {
+      unsigned numOps = GEPI->getNumOperands();
+      for(unsigned opIter=1; opIter < numOps; opIter++)
+      {
+      Value* opInst = GEPI->getOperand(opIter);               
+      if(opInst->getName().str()==indVarStr){
+      //GEPI->setOperand(opIter, Constant::getNullValue(Type::getInt16Ty(BB->getContext())));
+      GEPI->setOperand(opIter, ConstantInt::get(Type::getInt16Ty(BB->getContext()),-2));
+      }           
+      }
+      }
+      } //end of GEPI */
+      //}           
+    }
+
+    void transformInc(Loop* L, BasicBlock* BB){
+      //errs() << "In Transform Inc\n";
+
+      if(debugDynRollupLoops)
+        errs() << "transformInc: " << BB->getName() << "\n";
+
+      map<BasicBlock*, BinaryOperator*>::iterator incriter = bbIncrInst.find(BB);
+      assert(incriter != bbIncrInst.end() && "Incr Inst for this BB not found");          
+
+      BinaryOperator* Incr = (*incriter).second;
+
+      //Instruction* IncrInst;
+
+      //for(BasicBlock::iterator bbi = BB->begin(); bbi != BB->end(); ++bbi)
+      //{
+      //  if(debugDynRollupLoops)
+      //    errs() << *bbi << "\n";
+
+      //  Instruction* bInst = &*bbi;	  
+
+      //  if(BinaryOperator *Incr = dyn_cast<BinaryOperator>(bInst)){
+
+      unsigned instOp = Incr->getOpcode();
+      if(instOp == Instruction::Add) // || instOp == Instruction::Sub){
+      {
+
+        //IncrInst = Incr;
+
+        //errs() << "Inc inst name = "<<bInst->getName() << "\n";
+        //assert(Incr->getName().find("indvars.iv")!=string::npos && "Not an inc instr in for.inc");
+
+        unsigned numOps = Incr->getNumOperands();
+        for(unsigned opIter=0; opIter < numOps; opIter++)
+        {
+          Value* opInst = Incr->getOperand(opIter);
+
+          if(isa<ConstantInt>(opInst)){
+            Incr->setOperand(opIter, ConstantInt::get(opInst->getType(),1));
+            break;		    
+          }
+
+        }
+      } //end of Inst::Add
+      else if(instOp == Instruction::Sub){ //should not contain a sub inst
+        unsigned numOps = Incr->getNumOperands();
+        for(unsigned opIter=0; opIter < numOps; opIter++)
+        {
+          Value* opInst = Incr->getOperand(opIter);
+
+          if(isa<ConstantInt>(opInst)){
+            Incr->setOperand(opIter, ConstantInt::get(opInst->getType(),-1));
+            break;
+          }
+
+        }
+      } //end of Inst::Sub     
+      //} //end of if Binary Operator
+
+      //Rewrite Exit Value and Condition
+      map<BasicBlock*, ICmpInst*>::iterator icmpiter = bbICmpInst.find(BB);
+      assert(icmpiter != bbICmpInst.end() && "ICmp Inst for this BB not found");                
+      ICmpInst* IC = (*icmpiter).second;
+
+      //if(ICmpInst *IC = dyn_cast<ICmpInst>(bInst))
+      //    {
+
+      CmpInst::Predicate NewPred = CmpInst::ICMP_SLT;	     
+
+      //hack for bwt loop rotate problem
+      //get IC pred, if it is eq, keep eq.
+      unsigned currPred = IC->getUnsignedPredicate();
+
+      if(currPred == CmpInst::ICMP_EQ)
+        NewPred = CmpInst::ICMP_EQ;
+
+      if(currPred == CmpInst::ICMP_NE)
+        NewPred = CmpInst::ICMP_NE;
+
+      BranchInst *Br = cast<BranchInst>(IC->use_back());
+      assert(Br->isConditional() && "Did not find a branch");
+
+      /*
+         if(ConstantInt *Val1 = dyn_cast<ConstantInt>(IC->getOperand(1))){
+         errs() << "Opd1: Val: "<< Val1->getZExtValue() << "\n";		
+         }
+         else{
+
+         errs() << "Opd1: Name: "<< IC->getOperand(1)->getName() << "\n";		
+
+         }
+
+         if(ConstantInt *Val0 = dyn_cast<ConstantInt>(IC->getOperand(0))){
+         errs() << "Opd0: Val: "<< Val0->getZExtValue() << "\n";		
+         }
+         else{
+
+         errs() << "Opd0: Name: "<< IC->getOperand(0)->getName() << "\n";		
+
+         }	*/      
+
+      Value* ICop = IC->getOperand(0);
+
+      ICmpInst *NewCmp = new ICmpInst(Br,NewPred,ICop,ConstantInt::get(ICop->getType(),1),IC->getName());
+
+      NewCmp->takeName(IC);
+      IC->replaceAllUsesWith(NewCmp);
+      RecursivelyDeleteTriviallyDeadInstructions(IC);
+
+      //break;
+      //    }
+
+      //} //end of BB iterator      
+
+      return;
+    }
+
+
+    void getLoopInfoAndModify(Function &F,BasicBlock* thisBB,BasicBlock* thisInc){
+
+
+      //errs() << "BB = " << thisBB->getName() << " Func=" << F->getName() <<"\n";                   
+      LoopInfo *LI = &getAnalysis<LoopInfo> ( F );                                                                Loop* L1 = LI->getLoopFor(&*thisBB);                                                           
+      //assert(L1 != NULL); //must be a loop by this point                                           
+      modifyIndVars(L1, thisBB);                                                                                                                                                                                
+      Loop* L2 = LI->getLoopFor(&*thisInc);                                                          
+      transformInc(L2, thisInc);                                                                   
+    }
+
+    void processLoopsToRoll(Module &M)
+    {
+      //for(map<BasicBlock*, bool>::iterator bbc = blockCollapse.begin(); bbc!=blockCollapse.end(); ++bbc){
+      for(vector<BasicBlock*>::iterator bbc = blockCollapse.begin(); bbc!=blockCollapse.end(); ++bbc){
+
+        //if((*bbc).second == true){
+
+        //map<BasicBlock*, string>::iterator bbrep = blockRepCond.find((*bbc).first);
+        //if(bbrep!=blockRepCond.end())
+        //if((*bbrep).second != ""){
+
+
+        //BasicBlock* thisBB = (*bbc).first;
+        BasicBlock* thisBB = (*bbc);
+
+        ++NumLoopsRolled;
+
+
+        map<BasicBlock*, BasicBlock*>::iterator bbInc = blockBodyInc.find(thisBB);
+        assert(bbInc!=blockBodyInc.end());
+        BasicBlock* thisInc = (*bbInc).second;
+        if(debugDynRollupLoops){
+          errs() << "Found basicblock to collapse : " << thisBB->getName() <<"\n";
+          for(BasicBlock::iterator bbi = thisBB->begin(); bbi!=thisBB->end(); ++bbi)
+          {
+            errs()<<"\t" << *bbi<<"\n";		  		
+          }
+        }
+
+
+        //addDummyStart(M,thisBB,(*bbrep).second);
+        //addDummyEnd(M,thisBB,(*bbrep).second);
+
+        addDummyStart(thisBB);
+        addDummyEnd(thisBB);
+
+        Function* F = thisBB->getParent();
+        getLoopInfoAndModify(*F,thisBB,thisInc);
+
+        //} //end of found basic block to collapse
+
+        //}
+
+
+
+
+      } //blockCollapse iterator
+
+
+    }
+
+
+
+    void processFunctions(Function &F) {
+      if(F.isDeclaration())
+        if(debugDynRollupLoops)
+          errs() << "Fn is declaration\n";      
+
+      //blockCollapse.clear();
+      //blockRepCond.clear();
+      if(debugDynRollupLoops)
+        errs() << "==========Function: " << F.getName() << '\n';
+
+      getLoopInfo(F);
+      //errs() << "\n";
+
+    } // End runOnFunction
+
+
+    bool runOnModule(Module &M){
+      for(Module::iterator mIter = M.begin(); mIter != M.end(); ++mIter) {
+        Function* F = &(*mIter);
+
+        if(F && !F->isDeclaration()){
+          processFunctions((*F));
+        }	
+      }
+
+      //add global variable to replace globalRepValue=0
+      //Value* initGV = ConstantInt::get(Type::getInt64Ty(M.getContext()),0);
+      //GlobalVariable *GV = new GlobalVariable(M,Type::getInt64Ty(M.getContext()), true, GlobalValue::ExternalLinkage, (Constant*) initGV, "globalRepValue");
+
+
+      string dummyFnNameSt = "qasmRepLoopStart";
+      //dummyFnName.append(repStr);
+      //if(debugDynRollupLoops)
+      //errs() << "Dummy Fn Name = " << dummyFnName << "\n";
+
+
+      dummyStartLoop32 = cast<Function>(M.getOrInsertFunction("qasmRepLoopStart32", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), (Type*)0));
+      dummyStartLoop64 = cast<Function>(M.getOrInsertFunction("qasmRepLoopStart64", Type::getVoidTy(M.getContext()), Type::getInt64Ty(M.getContext()), (Type*)0));
+
+      string dummyFnNameE = "qasmRepLoopEnd";
+      //dummyFnName.append(repStr);
+      //if(debugDynRollupLoops)
+      //	errs() << "Dummy Fn Name = " << dummyFnName << "\n";
+
+      //addDummyFunc
+
+      dummyEndLoop = cast<Function>(M.getOrInsertFunction(dummyFnNameE, Type::getVoidTy(M.getContext()), (Type*)0));
+
+
+      //process loops identified as candidates
+      if(debugDynRollupLoops)
+        errs() << "Processing Loops " << blockCollapse.size() << "\n";
+      processLoopsToRoll(M);
+
+      return true;
+    }
+
+
+    }; // End of struct FunctionDynRollupLoops
+    } // End of anonymous namespace
+
+    char DynRollupLoops::ID = 0;
+    static RegisterPass<DynRollupLoops> X("dyn-rollup-loops", "Do not unroll loops if possible.");
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/DynRollupRepLoops.cpp llvm/lib/Transforms/Scaffold/DynRollupRepLoops.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/DynRollupRepLoops.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/DynRollupRepLoops.cpp	2017-10-12 11:09:31.091119588 +0800
@@ -0,0 +1,1229 @@
+//===----------------------- DynRollupRepLoops.cpp --------------------------===///
+// This file implements the Scaffold pass of traversing basic blocks, finding
+// purely quantum loops, and transforming them so they get called only once.
+
+
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "DynRollupRepLoops"
+#include "llvm/Module.h"
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/ScalarEvolution.h"
+#include "llvm/Analysis/ScalarEvolutionExpressions.h"
+#include "llvm/Transforms/Utils/Local.h"
+#include "llvm/Intrinsics.h"
+#include <sstream>
+#include <climits>
+
+using namespace llvm;
+using namespace std;
+
+
+bool debugDynRollupRepLoops = false;
+
+
+STATISTIC(NumLoopsRolled, "Number of loops rolled up");
+STATISTIC(NumDynLoopsRolled, "Number of dynamic loops rolled up");
+STATISTIC(NumTotalLoops, "Number of total loops");
+
+// An anonymous namespace for the pass. Things declared inside it are
+// only visible to the current file.
+namespace {
+
+    // Derived from FunctionPass to count qbits in functions
+  struct DynRollupRepLoops : public ModulePass {
+    static char ID; // Pass identification
+    
+    //map<BasicBlock*, bool> blockCollapse; //roll this loop
+    vector<BasicBlock*> blockCollapse; //roll this loop
+    map<BasicBlock*, string> blockRepCond; //repeat condition
+    map<BasicBlock*, BasicBlock*> blockBodyInc; //map for.body and for.inc
+    vector<BasicBlock*> blockForAll; //list of forall basicblocks
+    map<BasicBlock*, int> bbTripCount; //non zero trip count of loops
+
+    map<BasicBlock*, Instruction*> bbFirstInst;
+    map<BasicBlock*, BinaryOperator*> bbIncrInst;
+    map<BasicBlock*, ICmpInst*> bbICmpInst;
+    map<BasicBlock*, PHINode*> bbPhiInst;
+    map<BasicBlock*, Value*> bbTripCountVal;
+
+    Function* dummyStartLoop32; //dummyFunc to mark start of loop      
+    Function* dummyStartLoop64; //dummyFunc to mark start of loop      
+    Function* dummyEndLoop; //dummyFunc to mark start of loop
+    
+    DynRollupRepLoops() : ModulePass(ID) {}
+    //AnalysisUsage AU;
+    
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.addRequired<LoopInfo>();
+      AU.addPreserved<LoopInfo>();
+      AU.addRequired<ScalarEvolution>();
+      AU.addPreserved<ScalarEvolution>();            
+    }
+    
+
+    /*void print_blockForAll(){
+      errs() << "Printing blockForAll: \n";
+      for(vector<BasicBlock*>::iterator vit = blockForAll.begin(); vit!=blockForAll.end();++vit)
+	errs() << (*vit) << ":" << (*vit)->getName() << " ";
+      errs() << "\n";
+     
+      }*/
+    
+    bool checkIfQuantumType(Type* t) {
+      bool isQtmTy = true;
+      
+      if(t->isIntegerTy(16) || t->isIntegerTy(1))
+	isQtmTy &= true;
+      else if(ArrayType *arrayType = dyn_cast<ArrayType>(t))
+	{
+	  Type *elementType = arrayType->getElementType();
+	  if(elementType->isIntegerTy(16) || elementType->isIntegerTy(1))
+	    isQtmTy &= true;
+	  else isQtmTy &= false;
+	}	      
+      else if(t->isPointerTy()){
+	Type* elementType = t->getPointerElementType();
+	if(elementType->isIntegerTy(16) || elementType->isIntegerTy(1))
+	  isQtmTy &= true;
+      }
+      else{
+	isQtmTy = false;
+	
+      }
+      
+      return isQtmTy;
+    }    
+    
+    bool checkIfQuantum(BasicBlock* BB) {
+
+      //does not allow non-constant integer/double arguments to calls
+      //must contain atleast one call instruction
+
+
+      bool isQtm = true;
+
+      string indVarStr = "";
+
+      //errs() << "BB name: " << BB->getName() << "\n";
+
+      bool hasOtherThanPhiAndBrInst = false;      
+      //bool bodyHasIndVarComputation = false;
+      bool hasCallInst = false; //must have atleast one call inst
+      
+      for(BasicBlock::iterator bbi = BB->begin(); bbi != BB->end(); ++bbi)
+	{
+	  if(debugDynRollupRepLoops)
+	    errs() << *bbi << "\n";
+
+	    	    	  
+	  if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(&*bbi)){
+	    if(debugDynRollupRepLoops)
+	      errs() << "Is a GEPI \n";
+
+	    hasOtherThanPhiAndBrInst = true;
+	  }
+	  /***
+	    //check type of GEPI inst first
+	    Type* gepiType = GEPI->getType();
+	    
+	    if(!checkIfQuantumType(gepiType)){
+	      isQtm = false;
+	      if(debugDynRollupRepLoops)
+		errs() << "Unrecognized Type of GEPI Inst. \n";
+	      break;
+	    }
+
+
+	    //check indices of GEPI inst next: should be constant or indvars
+	    if(isQtm && GEPI->hasIndices())
+	      {
+		unsigned numOps = GEPI->getNumOperands();
+		for(unsigned opIter=1; opIter < numOps; opIter++)
+		  {
+		    Value* opInst = GEPI->getOperand(opIter);
+
+		    if(opInst->getName().str()==indVarStr){
+		      //bodyHasIndVarComputation = true;
+		      errs() << "IndVar is present in block \n";
+		      return false;
+		      //blockForAll.push_back(BB);
+		      //print_blockForAll();
+		    }      
+		    /*
+		    if(isa<ConstantInt>(opInst)){
+		      isQtm &= true;
+		    }
+		    //else if(opInst->getName().find("indvars.iv")!=string::npos)
+		    else if(opInst->getName().str()==indVarStr)
+		      isQtm &= true;
+		    else{
+		      isQtm = false;
+		      if(debugDynRollupRepLoops)
+			errs() << "GEPI indices do not satisfy qtm block criteria \n";
+		      return isQtm;
+		      //break;
+		      }*/
+	    /**		    
+		  }
+	      }
+	      }**/
+
+	  else if(isa<LoadInst>(*bbi)){
+	    if(debugDynRollupRepLoops)
+	      errs() << "Is a Load \n";
+	  }
+	  
+
+	  else if(isa<TruncInst>(*bbi)){
+	    if(debugDynRollupRepLoops)
+	      errs() << "Is Trunc \n";
+	  }
+
+	  else if(isa<PHINode>(*bbi)){
+	    if(debugDynRollupRepLoops)
+	      errs() << "Is a PHI Node \n";
+	      //errs() << *bbi << "\n";
+	    //indVarStr = (*bbi).getName();
+	      //errs() << "Phi Node Var = " << (*bbi).getName() << "\n";
+	  }
+	  
+		
+	  else if(CallInst *CI = dyn_cast<CallInst>(&*bbi))
+	    {
+	      hasOtherThanPhiAndBrInst = true;
+	      hasCallInst = true;
+
+		//check if all operands of call inst are i16 or i16*
+		//if not i16 or i16*, they should be constant integers i64 or i32 or floats
+		for(unsigned iop=0;iop<CI->getNumArgOperands();iop++){
+		  Type* argType = CI->getArgOperand(iop)->getType();
+		  
+		  //errs() << "Called Func = " << CI->getCalledFunction()->getName() << "\n";
+		  //errs() << "Call inst = " << *CI << "\n";
+
+		  if(argType->isIntegerTy(32) || argType->isIntegerTy(64)){
+		    //must be constant int
+		    if(!isa<ConstantInt>(CI->getArgOperand(iop))){
+		      if(debugDynRollupRepLoops)
+		      errs() << "Not a constant int \n";
+		      return false;
+		    }
+		  }
+		  else if(argType->isDoubleTy() || argType->isFloatTy()){
+		    //must be constant
+		    if(!isa<ConstantFP>(CI->getArgOperand(iop))){
+		      if(debugDynRollupRepLoops)
+		      errs() << "Not a constant double/float \n";
+		      return false;
+		    }
+		  }
+		  else if(!checkIfQuantumType(argType)){
+		    if(debugDynRollupRepLoops)
+		      errs() << "Operand Type of Call inst is non-quantum \n";
+		    //isQtm = false;
+		    return false; 
+		  }
+		  //else errs() << "Is qtm \n";
+		}
+	    }
+
+	  else if(isa<BranchInst>(*bbi)){
+	    if(debugDynRollupRepLoops)
+	      errs() << "Is a Branch Inst \n";
+	  }
+	  
+	  else{
+	    if(debugDynRollupRepLoops)
+	      errs() << "Unrecognized in quantum module. \n";
+	    //isQtm = false;
+	    return false;
+	    //break;
+	  }
+	  
+	}
+
+      if(hasOtherThanPhiAndBrInst)
+	return isQtm;
+      else{
+	//errs() << "Only contains Phi and Br \n";
+	return false;
+
+      }
+    }
+    
+    
+    
+    void getIncAndCmpConditions(Loop *L, BasicBlock *BB, BasicBlock* Header){
+      if(debugDynRollupRepLoops){
+	errs() << "Basic Block: " << BB->getName() << "\n";
+	errs() << "Get Inc and Cmp conditions \n";
+      }
+	    stringstream loopRepStr;
+	    stringstream incVal;
+	    stringstream cmpVal;
+	    stringstream initVal;
+
+	    stringstream incVal2;
+	    stringstream cmpVal2;
+	    stringstream initVal2;
+
+
+	    int initAt = 0;
+	    int incBy = 0;
+	    int endAt = 0;
+
+	    bool initConst = false;
+	    bool endConst = false;
+
+	    //PHINode* PN;
+	    //unsigned IncomingEdge;
+	    //unsigned BackEdge;
+
+
+	    Value* inVal;
+	    Value* outVal;
+
+	    BasicBlock::iterator firstIter = Header->begin();
+	    while(isa<PHINode>(&*firstIter)) ++firstIter;
+	    Instruction* FirstInst = &*(firstIter);
+
+	    //errs() << "First Inst of BB body = " << *FirstInst << "\n";
+
+	    //get initVal str
+	    for(BasicBlock::iterator hIter = Header->begin(); hIter!=Header->end(); ++hIter)
+	      {
+		//find phinode - process only the first phinode found
+		if(PHINode *PN = dyn_cast<PHINode>(&*hIter)){ //assuming we will get one PHI node at the beginning of the block. Will get this if -indvars has been run on the code before.
+		  //errs() << "Found PHI Node \n";
+		  //errs() << *PN << "\n";
+
+		  bbPhiInst[Header] = PN;
+
+		  unsigned IncomingEdge = L->contains(PN->getIncomingBlock(0));	       
+		  unsigned BackEdge     = IncomingEdge^1;
+		  if(ConstantInt *CInt = dyn_cast<ConstantInt>(PN->getIncomingValue(IncomingEdge))){
+		    int val = CInt->getZExtValue();
+		    if(debugDynRollupRepLoops)
+		      errs() << "Incoming Value = "<< val << "\n";
+		    initVal << "i="<<val;
+		    initVal2 << val;
+		    initAt = val;
+		    initConst = true;
+		    
+		  }
+		  else{
+		    //Incoming Value will be set at runtime
+		    inVal = PN->getIncomingValue(IncomingEdge);
+		    //if(debugDynRollupRepLoops)
+		      errs() << "Found dyn Incoming Value = "<< inVal->getName() << "\n";
+		      ++NumDynLoopsRolled;
+
+		  }
+
+		  if(BinaryOperator *Incr = dyn_cast<BinaryOperator>(PN->getIncomingValue(BackEdge))){
+
+		    bbIncrInst[BB] = Incr;
+
+		    //Instruction* bInst = &*bbi;
+		    unsigned instOp = Incr->getOpcode();
+		    
+		    //for(BasicBlock::iterator bbi = BB->begin(); bbi != BB->end(); ++bbi)
+		    //{
+		    if(debugDynRollupRepLoops)
+		    errs() << *Incr << "\n";
+		
+		    //Instruction* bInst = &*bbi;
+		    //unsigned instOp = bInst->getOpcode();
+		    if(instOp == Instruction::Add || instOp == Instruction::Sub){
+		      
+		      unsigned numOps = Incr->getNumOperands();
+		      for(unsigned opIter=0; opIter < numOps; opIter++)
+			{
+			  Value* opInst = Incr->getOperand(opIter);
+			  
+			  if(ConstantInt *CI = dyn_cast<ConstantInt>(opInst)){
+			    int val = CI->getZExtValue();
+			    if(debugDynRollupRepLoops)
+			      errs() << "Arith value = "<< val << "\n";
+			    
+			    if(instOp == Instruction::Add){
+			      if(val == 1) { incVal << "i++"; incBy = -1; incVal2<<1; }
+			      else if(val == -1) { incVal << "i--"; incBy = 1; incVal2<< -1; }
+			      else if(val>0) {incVal << "i+=" << val; incBy = -1*val; incVal2<<val; }
+			      else if(val<0) {incVal << "i-=" << val; incBy = val; incVal2 << val; }		  
+			    }
+			    
+			    if(instOp == Instruction::Sub){
+			      if(val == 1) { incVal << "i--"; incBy = 1; incVal2 << -1; }
+			      else if(val == -1) { incVal << "i++"; incBy = -1; incVal2<< 1; }
+			      else if(val>0) { incVal << "i-=" << val; incBy = val; incVal2 << val; }		  
+				else if(val<0) { incVal << "i+=" << val; incBy = -1*val; incVal2<<val; }		  
+			    }
+			   
+			    assert((incBy==1 || incBy==-1) && "Loop Step Value NOT EQ 1");
+ 
+			  }
+			  //else if(Incr->getName().find("indvars.iv")==string::npos)
+			  //errs() << "WARNING: Not an inc instruction. \n";
+			}
+		      
+		    } //end of inst::Add or Inst::Sub		    
+		  } //end of Incr
+		  break; // process only one Phi Node
+		} //end of PHI Node
+	      } //end of BB iterator
+
+	    bool addOne = false;
+	    bool biggerEnd = false;
+	    bool subOne = false;
+	    		    
+	    for(BasicBlock::iterator bbi = BB->begin(); bbi != BB->end(); ++bbi)
+	      {
+		if(debugDynRollupRepLoops)
+		  errs() << "Inst : " << *bbi << "\n";
+		
+		Instruction* bInst = &*bbi;
+		
+		if(ICmpInst *IC = dyn_cast<ICmpInst>(bInst))
+		  {
+		    if(debugDynRollupRepLoops)
+		      errs() << "Compare Inst = "<<*IC<<"\n";
+
+		    bbICmpInst[BB] = IC;
+
+		    int val = INT_MAX;
+		    
+		    unsigned numOps = IC->getNumOperands();
+		    //for(unsigned opIter=0; opIter < numOps; opIter++)
+		    unsigned opIter = 1;//check only second operand
+		      {
+			Value* opInst = IC->getOperand(opIter);
+			
+			if(ConstantInt *CI = dyn_cast<ConstantInt>(opInst)){
+			  val = CI->getZExtValue();
+			  if(debugDynRollupRepLoops)
+			    errs() << "Arith value = "<< val << "\n";
+			  
+			}
+			
+			else{
+
+			  //trace back once to check if result of trunc inst 
+			  //if so, use the operand of trunc inst as outVal
+			  if(isa<TruncInst>(opInst)){
+			    Instruction* TI = dyn_cast<Instruction>(opInst);
+			    //errs() << "Is from a trunc inst \n";
+			    opInst = TI->getOperand(0);
+			  }
+
+			  outVal = opInst;
+			  //if(outVal->getName() != "")
+			  //errs() << "Dyn Cmp Value = "<< outVal->getName() << " Type = " << outVal->getType()->getTypeID() << "\n";			  
+			  ++NumDynLoopsRolled;
+			}
+
+			//else if(opInst->getName().find("indvars.iv")==string::npos)
+			//errs() << "WARNING: Not an inc instruction. \n";
+		      }
+		    
+
+		      if(val!= INT_MAX)
+			endConst = true;
+
+		      //{
+		      unsigned icmp_cond = IC->getUnsignedPredicate();
+		      switch(icmp_cond){
+		      case CmpInst::ICMP_EQ:
+			if(endConst){
+			  cmpVal << "i=" << val;
+			  cmpVal2 << val;
+			  endAt = val; }
+			//errs() << "WARNING: equal SHOULD NOT OCCUR \n";
+			break;
+		      case CmpInst::ICMP_NE:
+			if(endConst){
+			  cmpVal << "i!=" << val;
+			  cmpVal2 << val+incBy;
+			  endAt = val+incBy; }
+			else { addOne = false; subOne = false; }
+			biggerEnd = true; 
+			
+			//errs() << "WARNING: not equal SHOULD NOT OCCUR \n";
+			break;
+		      case CmpInst::ICMP_UGT:
+		      case CmpInst::ICMP_SGT:
+			if(endConst){
+			  cmpVal << "i>" << val;
+			  cmpVal2 << val+incBy;
+			  endAt = val; //+incBy; 
+			}
+			else { addOne = false; subOne = false; }
+			biggerEnd = false; 
+			//errs() << "greater \n";
+			break;
+		      case CmpInst::ICMP_UGE:
+		      case CmpInst::ICMP_SGE:
+			if(endConst){
+			  cmpVal << "i>=" << val;
+			  cmpVal2 << val;
+			  endAt = val+incBy; }
+			else { addOne = false; subOne = true; }
+			biggerEnd = false; 
+			//errs() << "greater or equal \n";
+			break;
+			case CmpInst::ICMP_ULT:
+		      case CmpInst::ICMP_SLT:
+			if(endConst){
+			  cmpVal << "i<" << val;
+			  cmpVal2 << val+incBy;
+			  endAt = val; //+incBy; }
+			}			 
+			else { addOne =  false; subOne = false; }
+			biggerEnd = true; 
+			//errs() << "less \n";
+			break;
+		      case CmpInst::ICMP_ULE:
+		      case CmpInst::ICMP_SLE:
+			if(endConst){
+			  cmpVal << "i<=" << val;
+			  cmpVal2 << val;
+			  endAt = val+incBy; }			
+			else { addOne=true; subOne = false; }
+			biggerEnd = true;
+			//errs() << "less equal \n";
+			break;		  
+		      } //end of switch
+		      //}	       	      
+		      
+
+
+		  } //end of Icmp Inst	
+	      } //end of BB iterator       		      
+
+
+	    BinaryOperator* Bout = NULL;
+	    bool useStoredVal = false;
+	    Value* storedVal = NULL;
+	    { //hello
+	    if(addOne && biggerEnd) //end - start
+	      {		
+		if(initConst && !endConst) //initAt = constant, endAt not constant
+		  {
+		    BinaryOperator* BO = BinaryOperator::Create(Instruction::Add, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+
+		    if(initAt!=0)
+		      Bout = BinaryOperator::Create(Instruction::Sub, (Value*)BO, ConstantInt::get(outVal->getType(),initAt),"", FirstInst);		      		    
+		    else{
+		      useStoredVal = true;
+		      storedVal = outVal;
+		    }
+		  }
+		else if(!initConst && endConst) //initAt NOT const, endAt const
+		  {
+		    Bout = BinaryOperator::Create(Instruction::Sub, ConstantInt::get(inVal->getType(),endAt), inVal,"", FirstInst);
+		  }
+		else if(!initConst && !endConst) //both NOT const
+		  {		    		   		    
+		    unsigned b1 = inVal->getType()->getIntegerBitWidth();
+		    unsigned b2 = outVal->getType()->getIntegerBitWidth();
+		    
+		    if(b1>b2){
+		      CastInst* TI = CastInst::CreateTruncOrBitCast(inVal,outVal->getType(),"",FirstInst);
+		      BinaryOperator* BO = BinaryOperator::Create(Instruction::Add, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+		      Bout = BinaryOperator::Create(Instruction::Sub, (Value*)BO, (Value*)TI,"", FirstInst);		      
+		    }
+		    else{
+		      BinaryOperator* BO = BinaryOperator::Create(Instruction::Add, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+		      CastInst* TI = CastInst::CreateTruncOrBitCast((Value*)BO,inVal->getType(),"",FirstInst);
+		      Bout = BinaryOperator::Create(Instruction::Sub, (Value*)TI, inVal,"", FirstInst);		      
+		    }
+		  }
+		else errs() << "WARNING: This case should not occur. TripCount should have been known by here.\n";                
+	      } //end addOne and biggerEnd
+         
+            else if(addOne && !biggerEnd) //start - end
+	      {
+		
+		if(initConst && !endConst) //initAt = constant, endAt not constant
+		  {
+		    BinaryOperator* BO = BinaryOperator::Create(Instruction::Add, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);		    
+		    Bout = BinaryOperator::Create(Instruction::Sub, ConstantInt::get(outVal->getType(),initAt),(Value*)BO, "", FirstInst);
+		  }
+		else if(!initConst && endConst) //initAt NOT const, endAt const
+		  {
+
+		      Bout = BinaryOperator::Create(Instruction::Sub, inVal, ConstantInt::get(inVal->getType(),endAt), "", FirstInst);
+		  }
+		else if(!initConst && !endConst) //both NOT const
+		  {                             
+		    unsigned b1 = inVal->getType()->getIntegerBitWidth();
+		    unsigned b2 = outVal->getType()->getIntegerBitWidth();
+		    
+
+		    
+		    if(b1>b2){
+		      CastInst* TI = CastInst::CreateTruncOrBitCast(inVal,outVal->getType(),"",FirstInst);
+		      BinaryOperator* BO = BinaryOperator::Create(Instruction::Add, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+		      Bout = BinaryOperator::Create(Instruction::Sub, (Value*)TI, (Value*)BO, "", FirstInst);
+		    }
+		    else{
+		      BinaryOperator* BO = BinaryOperator::Create(Instruction::Add, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+		      CastInst* TI = CastInst::CreateTruncOrBitCast((Value*)BO,inVal->getType(),"",FirstInst);		      
+		      Bout = BinaryOperator::Create(Instruction::Sub, inVal, (Value*)TI, "", FirstInst);
+
+		    }
+		  }
+		else errs() << "WARNING: This case should not occur. TripCount should have been known by here.\n";                
+	      } //end addOne and not biggerEnd
+
+	    else if(subOne && biggerEnd) //end - start
+	      {
+		
+		if(initConst && !endConst) //initAt = constant, endAt not constant
+		  {
+
+		    BinaryOperator* BO = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+		    
+		    if(initAt!=0)		      
+		      Bout = BinaryOperator::Create(Instruction::Sub, (Value*)BO, ConstantInt::get(outVal->getType(),initAt),"", FirstInst);
+		    else{
+		      useStoredVal = true;
+		      storedVal = (Value*)BO;
+		    }
+		  }
+		else if(!initConst && endConst) //initAt NOT const, endAt const
+		  {
+
+		    Bout = BinaryOperator::Create(Instruction::Sub, ConstantInt::get(inVal->getType(),endAt), inVal,"", FirstInst);
+		  }
+		else if(!initConst && !endConst) //both NOT const
+		  {		    		              
+		    unsigned b1 = inVal->getType()->getIntegerBitWidth();
+		    unsigned b2 = outVal->getType()->getIntegerBitWidth();
+
+
+
+		    if(b1>b2){
+		      CastInst* TI = CastInst::CreateTruncOrBitCast(inVal,outVal->getType(),"",FirstInst);
+		      BinaryOperator* BO = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+		      Bout = BinaryOperator::Create(Instruction::Sub, (Value*)BO, (Value*)TI,"", FirstInst);
+		    }
+		    else{
+		      BinaryOperator* BO = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+		      CastInst* TI = CastInst::CreateTruncOrBitCast((Value*)BO,inVal->getType(),"",FirstInst);		      
+		      Bout = BinaryOperator::Create(Instruction::Sub, (Value*)TI, inVal,"", FirstInst);		      
+		    }
+		  }
+		else errs() << "WARNING: This case should not occur. TripCount should have been known by here.\n";                
+	      } //end of subOne and biggerEnd
+                    
+            else if(subOne && !biggerEnd) //start - end
+	      {
+		
+		if(initConst && !endConst) //initAt = constant, endAt not constant
+		  {
+		    BinaryOperator* BO = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);		    
+		    Bout = BinaryOperator::Create(Instruction::Sub, ConstantInt::get(outVal->getType(),initAt),(Value*)BO, "", FirstInst);
+		  }
+		else if(!initConst && endConst) //initAt NOT const, endAt const
+		  {
+		    Bout = BinaryOperator::Create(Instruction::Sub, inVal, ConstantInt::get(inVal->getType(),endAt), "", FirstInst);
+		  }
+		else if(!initConst && !endConst) //both NOT const
+		  {		    		    		    
+		    unsigned b1 = inVal->getType()->getIntegerBitWidth();
+		    unsigned b2 = outVal->getType()->getIntegerBitWidth();
+		    
+		    if(b1>b2){
+		      CastInst* TI = CastInst::CreateTruncOrBitCast(inVal,outVal->getType(),"",FirstInst);
+		      BinaryOperator* BO = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+		      Bout = BinaryOperator::Create(Instruction::Sub, (Value*)TI, (Value*)BO, "", FirstInst);
+		    }
+		    else{
+		      BinaryOperator* BO = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),1),"", FirstInst);
+		      CastInst* TI = CastInst::CreateTruncOrBitCast((Value*)BO,inVal->getType(),"",FirstInst);		      
+		      Bout = BinaryOperator::Create(Instruction::Sub, inVal, (Value*)TI, "", FirstInst);
+		    }
+		  }
+		else errs() << "WARNING: This case should not occur. TripCount should have been known by here.\n";        
+	      } //end of subOne and NOT biggerEnd
+	    
+	    else if(!addOne && !subOne && biggerEnd) //end - start
+	      {
+		
+		if(initConst && !endConst) //initAt = constant, endAt not constant
+		  {
+		    //errs() << "insert 101 initVal = " << initAt << " endAt Ptr = " << outVal->getName()<< "\n";
+		    
+		    if(initAt!=0)		      
+		      Bout = BinaryOperator::Create(Instruction::Sub, outVal, ConstantInt::get(outVal->getType(),initAt),"", FirstInst);
+		    else{
+		      useStoredVal = true;
+		      storedVal = outVal;
+		      //errs() << "useStoredValue set = " <<useStoredVal << "\n";
+		    }
+		  }
+		else if(!initConst && endConst) //initAt NOT const, endAt const
+		  {
+		    Bout = BinaryOperator::Create(Instruction::Sub, ConstantInt::get(inVal->getType(),endAt), inVal,"", FirstInst);
+		  }
+		else if(!initConst && !endConst) //both NOT const
+		  {		    		              
+		    unsigned b1 = inVal->getType()->getIntegerBitWidth();
+		    unsigned b2 = outVal->getType()->getIntegerBitWidth();
+
+		    if(b1>b2){
+		      CastInst* TI = CastInst::CreateTruncOrBitCast(inVal,outVal->getType(),"",FirstInst);
+		      Bout = BinaryOperator::Create(Instruction::Sub, outVal, (Value*)TI,"", FirstInst);
+		    }
+		    else{
+		      CastInst* TI = CastInst::CreateTruncOrBitCast(outVal,inVal->getType(),"",FirstInst);		      
+		      Bout = BinaryOperator::Create(Instruction::Sub, (Value*)TI, inVal,"", FirstInst);		      
+		    }
+		  }
+		else errs() << "WARNING: This case should not occur. TripCount should have been known by here.\n";                
+		//errs() << "useStoredValue 1 = " <<useStoredVal << "\n";
+	      } //end of subOne and biggerEnd
+                    
+            else if(!addOne && !subOne && !biggerEnd) //start - end
+	      {
+		
+		if(initConst && !endConst) //initAt = constant, endAt not constant
+		  {
+		    Bout = BinaryOperator::Create(Instruction::Sub, ConstantInt::get(outVal->getType(),initAt),outVal, "", FirstInst);
+		  }
+		else if(!initConst && endConst) //initAt NOT const, endAt const
+		  {
+		    Bout = BinaryOperator::Create(Instruction::Sub, inVal, ConstantInt::get(inVal->getType(),endAt), "", FirstInst);
+		  }
+		else if(!initConst && !endConst) //both NOT const
+		  {		    		    		    
+		    unsigned b1 = inVal->getType()->getIntegerBitWidth();
+		    unsigned b2 = outVal->getType()->getIntegerBitWidth();
+		    
+		    
+		    if(b1>b2){
+		      CastInst* TI = CastInst::CreateTruncOrBitCast(inVal,outVal->getType(),"",FirstInst);
+		      Bout = BinaryOperator::Create(Instruction::Sub, (Value*)TI, outVal, "", FirstInst);
+		    }
+		    else{		      
+		      CastInst* TI = CastInst::CreateTruncOrBitCast(outVal,inVal->getType(),"",FirstInst);		      
+		      Bout = BinaryOperator::Create(Instruction::Sub, inVal, (Value*)TI, "", FirstInst);
+		    }
+		  }
+		else errs() << "WARNING: This case should not occur. TripCount should have been known by here.\n";        
+	      } //end of NOT biggerEnd
+	    }                    
+	    //if(useStoredVal) errs() << "StoredVal: " << storedVal->getName() << "\n";
+	    //errs() << " 15e \n";
+
+	    if(useStoredVal) bbTripCountVal[Header] = storedVal;
+	    else 
+	      if(Bout!=NULL)
+		bbTripCountVal[Header] = (Value*)Bout;
+	      else errs() << "WARNING: NO TRIP COUNT FOUND \n";
+
+
+
+	    blockBodyInc[Header] = BB;
+	    bbFirstInst[Header] = FirstInst;
+
+
+      /*
+
+	    if(initVal.str()!="" && cmpVal.str()!="" && incVal.str()!=""){
+	      //errs() << "Searching blockForAll for " << Header << ":" << Header->getName() << "\n";
+	      vector<BasicBlock*>::iterator isForAll = find(blockForAll.begin(), blockForAll.end(),Header);
+	      if(isForAll!=blockForAll.end())		
+		//loopRepStr << "forall "<< initVal.str() << "; " << cmpVal.str() << "; " << incVal.str();
+		loopRepStr << "forall ["<< initVal2.str() << ":" << cmpVal2.str() << ":" << incVal2.str() << "]";
+	     
+	      else{
+		//loopRepStr << "repeat "<< initVal.str() << "; " << cmpVal.str() << "; " << incVal.str();
+		int numRepeats = endAt - initAt + 1;
+		if(numRepeats>0)
+		  loopRepStr << "repeat "<< (endAt-initAt+1) << " times ";
+	      }
+	    }
+	    if(debugDynRollupRepLoops)
+	      errs() << "Rep String1 = " << loopRepStr.str() << "\n";
+	    
+	      blockRepCond[Header] = loopRepStr.str();*/
+	    //}
+      
+    }
+
+
+    void getBBInsts(Loop *L,BasicBlock* BB,BasicBlock* Header)
+    {
+
+      //errs() << "getBBInsts: BB = " << BB->getName() << "\n";
+      blockBodyInc[Header] = BB;
+
+      BasicBlock::iterator firstIter = Header->begin();
+      //if(isa<PHINode>(*firstIter)){
+      if(PHINode *PN = dyn_cast<PHINode>(&*firstIter)){ //assuming we will get one PHI node at the beginning of the block. Will get this if -indvars has been run on the code before.       
+	bbPhiInst[Header] = PN;
+	//errs() << "Found PHI \n";
+
+	unsigned IncomingEdge = L->contains(PN->getIncomingBlock(0));	       
+	unsigned BackEdge     = IncomingEdge^1;
+
+	if(BinaryOperator *Incr = dyn_cast<BinaryOperator>(PN->getIncomingValue(BackEdge))){
+	  bbIncrInst[BB] = Incr;
+	  //errs() << "Found Incr : " << *Incr << "\n";
+	}
+	else errs() << "WARNING: Incr Inst Not Found \n";
+      }
+
+      while(isa<PHINode>(&*firstIter)) ++firstIter;
+      Instruction* FirstInst = &*(firstIter);
+      bbFirstInst[Header] = FirstInst;
+
+
+
+      for(BasicBlock::iterator bbi = BB->begin(); bbi != BB->end(); ++bbi)
+	{
+	  if(debugDynRollupRepLoops)
+	    errs() << "Inst : " << *bbi << "\n";
+	  
+	  Instruction* bInst = &*bbi;
+	  
+	  if(ICmpInst *IC = dyn_cast<ICmpInst>(bInst))
+	    {
+	      if(debugDynRollupRepLoops)
+		errs() << "Found Compare Inst = "<<*IC<<"\n";
+	      
+	      bbICmpInst[BB] = IC;
+	      break;
+	    }
+
+	}
+
+    }
+    
+    void getLoopInfo(Function& F) {
+      LoopInfo *LI = &getAnalysis<LoopInfo> ( F );
+      ScalarEvolution *SE = &getAnalysis<ScalarEvolution>( F );
+
+      for (Function::iterator BB = F.begin(), E = F.end(); BB != E; ++BB)
+	{           
+	  
+	  string BBname = BB->getName();
+	  //errs() << "Basic Block Name = "<<BBname << "\n";	    
+	  
+	  
+	  Loop* L = LI->getLoopFor(&*BB);
+	  if (L != NULL)
+	    {    
+	      
+	      if(BBname.find("for.body")!=string::npos){
+		++NumTotalLoops;
+		if(debugDynRollupRepLoops)
+		  errs() << "Counting this: "<<BBname<<"\n";
+
+		BasicBlock* Latch = L->getLoopLatch();
+                if(Latch){
+
+		  int tripCount = SE->getSmallConstantTripCount(L, Latch);
+
+		  if(tripCount > 1)
+		    bbTripCount[BB] = tripCount;
+
+
+		  if(Latch!=&*BB){
+		    bool isCollapsable = checkIfQuantum(&*BB);
+		    if(debugDynRollupRepLoops)
+		      errs() << "isCollapsable = " << isCollapsable << "\n";
+
+		    if(isCollapsable && tripCount!=1){		      
+		      //blockCollapse[&*BB] = isCollapsable;		    
+		      blockCollapse.push_back(&*BB);
+
+		      if(debugDynRollupRepLoops)
+			errs() << "Trip Count of " << BBname << " is " << tripCount <<"\n";
+		  
+		      //errs() << "Latch is: " << Latch->getName() << "\n";
+		   
+		      if(tripCount == 0)
+			getIncAndCmpConditions(L, Latch, &*BB);
+		      else
+			getBBInsts(L,Latch,&*BB);		      
+		    }
+		  }
+		  else{ //Latch and BB are the same basic blocks
+		    errs() << "WARNING: Latch and BB are the same basic blocks. This condition should never occur here\n.";
+		   
+		    }
+
+		}
+
+	      }
+	    }
+	  
+	  //errs() << "\n";
+	}
+    }
+    
+   
+    void addDummyStart(BasicBlock* BB){
+      
+      //BasicBlock::iterator BBiter = BB->getFirstNonPHI();
+
+      //while(isa<AllocaInst>(BBiter))
+      //++BBiter;
+
+      //errs() << "addDummyStart: " << BB->getName() << "\n";
+
+      map<BasicBlock*, Instruction*>::iterator fi_iter = bbFirstInst.find(BB);
+      assert(fi_iter!=bbFirstInst.end() && "First Inst not found for this BB");
+
+      Instruction* BBiter = (*fi_iter).second;
+
+      map<BasicBlock*,int>::iterator tcIter = bbTripCount.find(BB);
+      if(tcIter!=bbTripCount.end()){
+	int tripCount = (*tcIter).second;
+	//errs() << "Adding TripCount of " << BB->getName() << " is "<<tripCount<<"\n";	      	
+	
+	//add dummy function with trip count as argument
+
+	Value* intArg = ConstantInt::get(Type::getInt32Ty(BB->getContext()),tripCount);
+	
+	CallInst::Create(dummyStartLoop32, intArg, "",BBiter);      	
+      }
+      else{
+	map<BasicBlock*,Value*>::iterator tcvalIter = bbTripCountVal.find(BB);
+	if(tcvalIter!=bbTripCountVal.end()){
+	  Value* tripCountVal = (*tcvalIter).second;
+
+	  //errs() << "tripcountVal name = " << tripCountVal->getName() << "\n";
+	  //add dummy function with trip count as argument
+
+	  
+	  //Value* intArg = ConstantInt::get(Type::getInt32Ty(BB->getContext()),tripCount);
+	  
+	  if(tripCountVal->getType()->isIntegerTy(32))
+	    CallInst::Create(dummyStartLoop32, tripCountVal, "",BBiter);      	
+	  if(tripCountVal->getType()->isIntegerTy(64))
+	    CallInst::Create(dummyStartLoop64, tripCountVal, "",BBiter);      	
+	  
+	}
+	else errs() << "WARNING: Trip Count Value not found for this BB \n";	
+      }            
+    }
+
+
+    void addDummyEnd(BasicBlock* BB){
+
+     TerminatorInst *BBTerm = BB->getTerminator();
+
+     //while(isa<AllocaInst>(BBiter))
+     //++BBiter;
+            
+      CallInst::Create(dummyEndLoop, "",(Instruction*)BBTerm);      
+
+      return;
+
+    }
+    void modifyIndVars(Loop* L, BasicBlock* BB){
+      
+      string indVarStr = "";
+
+      //errs() << "modifyIndVars: " << BB->getName() << "\n";
+
+      map<BasicBlock*, PHINode*>::iterator piter = bbPhiInst.find(BB);
+      assert(piter != bbPhiInst.end() && "Phi Inst for this BB not found");
+
+
+      
+
+      PHINode *PN = (*piter).second;
+      //if(PHINode *PN = dyn_cast<PHINode>(&*bbi)){
+      
+	//if(debugDynRollupRepLoops)
+	//    errs() << "Is a PHI Node: " << *bbi << "\n";                                               
+	//  indVarStr = (*bbi).getName();
+	    //errs() << "Phi Node Var = " << (*bbi).getName() << "\n";    	 
+
+	indVarStr = PN->getName();
+
+	    //rewrite Init Value
+	    unsigned IncomingEdge = L->contains(PN->getIncomingBlock(0));
+	    //unsigned BackEdge     = IncomingEdge^1;
+
+	    Value* currVal = PN->getIncomingValue(IncomingEdge);
+	    	    
+	    PN->setIncomingValue(IncomingEdge,Constant::getNullValue(currVal->getType()));	    
+
+	    // }
+	    //else
+	    /*
+
+	      for(BasicBlock::iterator bbi = BB->begin(); bbi!=BB->end(); ++bbi)
+	      {
+		//if(debugDynRollupRepLoops)
+		//    errs()<<"\t" << *bbi<<"\n";
+
+	    if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(&*bbi)){
+	    //check indices of GEPI inst next: should be constant or indvars          
+            if(GEPI->hasIndices())
+              {
+		unsigned numOps = GEPI->getNumOperands();
+                for(unsigned opIter=1; opIter < numOps; opIter++)
+                  {
+                    Value* opInst = GEPI->getOperand(opIter);               
+                    if(opInst->getName().str()==indVarStr){
+		      //GEPI->setOperand(opIter, Constant::getNullValue(Type::getInt16Ty(BB->getContext())));
+		      GEPI->setOperand(opIter, ConstantInt::get(Type::getInt16Ty(BB->getContext()),0));
+		    }           
+                  }
+              }
+	    } //end of GEPI 
+	    } //end of basic block iterator           */
+    }
+
+    void transformInc(Loop* L, BasicBlock* BB){
+      //errs() << "In Transform Inc\n";
+
+
+      //errs() << "transformInc: " << BB->getName() << "\n";
+
+      map<BasicBlock*, BinaryOperator*>::iterator incriter = bbIncrInst.find(BB);
+      assert(incriter != bbIncrInst.end() && "Incr Inst for this BB not found");          
+      
+      BinaryOperator* Incr = (*incriter).second;
+
+      //Instruction* IncrInst;
+
+      //for(BasicBlock::iterator bbi = BB->begin(); bbi != BB->end(); ++bbi)
+      //{
+      //  if(debugDynRollupRepLoops)
+      //    errs() << *bbi << "\n";
+	    
+      //  Instruction* bInst = &*bbi;	  
+
+      //  if(BinaryOperator *Incr = dyn_cast<BinaryOperator>(bInst)){
+
+	  unsigned instOp = Incr->getOpcode();
+	  if(instOp == Instruction::Add) // || instOp == Instruction::Sub){
+	    {
+
+	      //IncrInst = Incr;
+
+	      //errs() << "Inc inst name = "<<bInst->getName() << "\n";
+	      //assert(Incr->getName().find("indvars.iv")!=string::npos && "Not an inc instr in for.inc");
+
+	      unsigned numOps = Incr->getNumOperands();
+	      for(unsigned opIter=0; opIter < numOps; opIter++)
+		{
+		  Value* opInst = Incr->getOperand(opIter);
+
+		  if(isa<ConstantInt>(opInst)){
+		    Incr->setOperand(opIter, ConstantInt::get(opInst->getType(),1));
+		    break;		    
+		  }
+
+		}
+	    } //end of Inst::Add
+	  else if(instOp == Instruction::Sub){ //should not contain a sub inst
+	    unsigned numOps = Incr->getNumOperands();
+	    for(unsigned opIter=0; opIter < numOps; opIter++)
+	      {
+		Value* opInst = Incr->getOperand(opIter);
+
+		if(isa<ConstantInt>(opInst)){
+		  Incr->setOperand(opIter, ConstantInt::get(opInst->getType(),-1));
+		  break;
+		}
+
+	      }
+	  } //end of Inst::Sub     
+	  //} //end of if Binary Operator
+	  
+      //Rewrite Exit Value and Condition
+      map<BasicBlock*, ICmpInst*>::iterator icmpiter = bbICmpInst.find(BB);
+      assert(icmpiter != bbICmpInst.end() && "ICmp Inst for this BB not found");                
+      ICmpInst* IC = (*icmpiter).second;
+
+      //if(ICmpInst *IC = dyn_cast<ICmpInst>(bInst))
+      //    {
+
+	      CmpInst::Predicate NewPred = CmpInst::ICMP_SLT;	     
+	      
+	      //hack for bwt loop rotate problem
+	      //get IC pred, if it is eq, keep eq.
+	      unsigned currPred = IC->getUnsignedPredicate();
+
+	      if(currPred == CmpInst::ICMP_EQ)
+		NewPred = CmpInst::ICMP_EQ;
+		
+	      if(currPred == CmpInst::ICMP_NE)
+		NewPred = CmpInst::ICMP_NE;
+
+	      BranchInst *Br = cast<BranchInst>(IC->use_back());
+	      assert(Br->isConditional() && "Did not find a branch");
+
+	      /*
+	      if(ConstantInt *Val1 = dyn_cast<ConstantInt>(IC->getOperand(1))){
+		errs() << "Opd1: Val: "<< Val1->getZExtValue() << "\n";		
+	      }
+	      else{
+
+		errs() << "Opd1: Name: "<< IC->getOperand(1)->getName() << "\n";		
+
+	      }
+
+	      if(ConstantInt *Val0 = dyn_cast<ConstantInt>(IC->getOperand(0))){
+		errs() << "Opd0: Val: "<< Val0->getZExtValue() << "\n";		
+	      }
+	      else{
+
+		errs() << "Opd0: Name: "<< IC->getOperand(0)->getName() << "\n";		
+
+		}	*/      
+
+	      Value* ICop = IC->getOperand(0);
+
+	      ICmpInst *NewCmp = new ICmpInst(Br,NewPred,ICop,ConstantInt::get(ICop->getType(),1),IC->getName());
+
+	      NewCmp->takeName(IC);
+	      IC->replaceAllUsesWith(NewCmp);
+	      RecursivelyDeleteTriviallyDeadInstructions(IC);
+
+	      //break;
+	      //    }
+
+	  //} //end of BB iterator      
+
+      return;
+    }
+
+
+    void getLoopInfoAndModify(Function &F,BasicBlock* thisBB,BasicBlock* thisInc){
+
+
+    //errs() << "BB = " << thisBB->getName() << " Func=" << F->getName() <<"\n";                   
+              LoopInfo *LI = &getAnalysis<LoopInfo> ( F );                                                                Loop* L1 = LI->getLoopFor(&*thisBB);                                                           
+              //assert(L1 != NULL); //must be a loop by this point                                           
+              modifyIndVars(L1, thisBB);                                                                                                                                                                                
+              Loop* L2 = LI->getLoopFor(&*thisInc);                                                          
+              transformInc(L2, thisInc);                                                                   
+    }
+
+    void processLoopsToRoll(Module &M)
+    {
+      //for(map<BasicBlock*, bool>::iterator bbc = blockCollapse.begin(); bbc!=blockCollapse.end(); ++bbc){
+      for(vector<BasicBlock*>::iterator bbc = blockCollapse.begin(); bbc!=blockCollapse.end(); ++bbc){
+
+	//if((*bbc).second == true){
+
+	  //map<BasicBlock*, string>::iterator bbrep = blockRepCond.find((*bbc).first);
+	  //if(bbrep!=blockRepCond.end())
+	  //if((*bbrep).second != ""){
+	      
+
+	//BasicBlock* thisBB = (*bbc).first;
+	BasicBlock* thisBB = (*bbc);
+
+	      ++NumLoopsRolled;
+
+	      
+	      map<BasicBlock*, BasicBlock*>::iterator bbInc = blockBodyInc.find(thisBB);
+	      assert(bbInc!=blockBodyInc.end());
+	      BasicBlock* thisInc = (*bbInc).second;
+	      if(debugDynRollupRepLoops){
+		errs() << "Found basicblock to collapse : " << thisBB->getName() <<"\n";
+		for(BasicBlock::iterator bbi = thisBB->begin(); bbi!=thisBB->end(); ++bbi)
+		  {
+		    errs()<<"\t" << *bbi<<"\n";		  		
+		  }
+	      }
+  
+	      //addDummyStart(M,thisBB,(*bbrep).second);
+	      //addDummyEnd(M,thisBB,(*bbrep).second);
+
+	      addDummyStart(thisBB);
+	      addDummyEnd(thisBB);
+
+	      Function* F = thisBB->getParent();
+	      getLoopInfoAndModify(*F,thisBB,thisInc);
+
+	      //} //end of found basic block to collapse
+
+	//}
+
+
+
+
+      } //blockCollapse iterator
+
+    }
+
+
+
+    void processFunctions(Function &F) {
+      if(F.isDeclaration())
+	errs() << "Fn is declaration\n";      
+      
+      //blockCollapse.clear();
+      //blockRepCond.clear();
+      
+      //errs() << "==========Function: " << F.getName() << '\n';
+      
+      getLoopInfo(F);
+      //errs() << "\n";
+                 
+    } // End runOnFunction
+    
+
+    bool runOnModule(Module &M){
+      for(Module::iterator mIter = M.begin(); mIter != M.end(); ++mIter) {
+	Function* F = &(*mIter);
+
+	if(F && !F->isDeclaration()){
+	  processFunctions((*F));
+	}	
+      }
+
+      string dummyFnNameSt = "qasm_print_RepLoopStart";
+      //dummyFnName.append(repStr);
+      //if(debugDynRollupRepLoops)
+      //errs() << "Dummy Fn Name = " << dummyFnName << "\n";
+
+
+      dummyStartLoop32 = cast<Function>(M.getOrInsertFunction("qasm_print_RepLoopStart32", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), (Type*)0));
+      dummyStartLoop64 = cast<Function>(M.getOrInsertFunction("qasm_print_RepLoopStart64", Type::getVoidTy(M.getContext()), Type::getInt64Ty(M.getContext()), (Type*)0));
+
+      string dummyFnNameE = "qasm_print_RepLoopEnd";
+      //dummyFnName.append(repStr);
+      //if(debugDynRollupRepLoops)
+      //	errs() << "Dummy Fn Name = " << dummyFnName << "\n";
+
+      //addDummyFunc
+
+      dummyEndLoop = cast<Function>(M.getOrInsertFunction(dummyFnNameE, Type::getVoidTy(M.getContext()), (Type*)0));
+
+
+      //process loops identified as candidates
+      //errs() << "Processing Loops " << blockCollapse.size() << "\n";
+      processLoopsToRoll(M);
+
+      return true;
+      }
+   
+
+  }; // End of struct FunctionDynRollupRepLoops
+} // End of anonymous namespace
+
+char DynRollupRepLoops::ID = 0;
+static RegisterPass<DynRollupRepLoops> X("dyn-rollup-rep-loops", "Do not unroll repeat loops if possible.");
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/FlattenModule.cpp llvm/lib/Transforms/Scaffold/FlattenModule.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/FlattenModule.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/FlattenModule.cpp	2017-10-12 11:09:31.091119588 +0800
@@ -0,0 +1,182 @@
+//===-------------------------- FlattenModule.cpp ------------------------===//
+// This file implements the Scaffold pass of flattening modules whose gate 
+// counts are below the threshold. These modules' names have been previously 
+// written to the file "flat_info.txt".
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "FlattenModule"
+#include <sstream>
+#include <fstream>
+#include <string>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/Transforms/Utils/Cloning.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+#include "llvm/Support/CallSite.h"
+#include "llvm/Transforms/IPO/InlinerPass.h"
+#include "llvm/Transforms/Utils/Local.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/Target/TargetData.h"
+#include "llvm/ADT/SCCIterator.h"
+#include "llvm/Support/CommandLine.h"
+
+// DEBUG switch
+bool debugFlattening = false;
+
+using namespace llvm;
+
+static cl::opt<unsigned>
+FLAT("all", cl::init(0), cl::Hidden,
+    cl::desc("Toggle for complete inlining"));
+
+// An anonymous namespace for the pass. Things declared inside it are
+// only visible to the current file.
+namespace {
+
+  // Derived from ModulePass to work on callgraph
+  struct FlattenModule : public ModulePass {
+    static char ID; // Pass identification
+    FlattenModule() : ModulePass(ID) {}
+
+    // what functions to make leaves
+    std::vector <Function*> makeLeaf;
+    
+    // mark those call sites to be inlined
+    std::vector<CallInst*> inlineCallInsts; 
+
+    // functions in post-order
+    std::vector<Function*> vectPostOrder;
+
+    bool runOnModule (Module &M);
+    bool runOnSCC( const std::vector<CallGraphNode *> &scc );
+    bool runOnFunction( Function & F );    
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+        AU.setPreservesCFG();  
+        AU.addRequired<CallGraph>();
+        AU.addRequired<TargetData>();
+    }
+
+  }; // End of struct FlattenModule
+} // End of anonymous namespace
+
+
+char FlattenModule::ID = 0;
+static RegisterPass<FlattenModule> X("FlattenModule", "Quantum Module Flattening Pass", false, false);
+
+bool FlattenModule::runOnModule( Module & M ) {
+  
+  std::vector<std::string> leafNames;
+  
+  std::string line;
+  std::ifstream file ("flat_info.txt");
+  if(file.is_open()) {
+    while(std::getline(file, line))
+      leafNames.push_back(line);
+    file.close();
+  }
+  else{
+    if(debugFlattening) 
+        errs() << "Error: Could not open flat_info file.\n";
+  }
+  for (std::vector<std::string>::iterator i = leafNames.begin(), e = leafNames.end();
+      i!=e; ++i) {
+    if (debugFlattening)
+      errs() << "flat_info: " << *i << "\n";
+    makeLeaf.push_back(M.getFunction(*i));
+  }
+
+  // First, get a pointer to previous analysis results
+  CallGraph & CG = getAnalysis<CallGraph>();
+
+  CallGraphNode * entry = CG.getRoot();
+  if( entry && entry->getFunction() && debugFlattening)
+    errs() << "Entry is function: " << entry->getFunction()->getName() << "\n";
+
+  // Iterate over all SCCs in the module in bottom-up order
+  for( scc_iterator<CallGraph*>
+   si=scc_begin( &CG ), se=scc_end( &CG ); si != se; ++si ) {
+    runOnSCC( *si );
+  }
+
+  //reverse the vector for preorder
+  std::reverse(vectPostOrder.begin(),vectPostOrder.end());
+
+  for(std::vector<Function*>::iterator vit = vectPostOrder.begin(), vitE = vectPostOrder.end();
+      vit!=vitE; ++vit) { 
+    Function *f = *vit;      
+    runOnFunction(*f);    
+  }
+
+  
+  // now we have all the call sites which need to be inlined
+  // inline from the leaves all the way up
+  const TargetData *TD = getAnalysisIfAvailable<TargetData>();
+  InlineFunctionInfo InlineInfo(&CG, TD);  
+
+  std::reverse(inlineCallInsts.begin(),inlineCallInsts.end());
+  for (std::vector<CallInst*>::iterator i = inlineCallInsts.begin(), e = inlineCallInsts.end();
+      i!=e; ++i) {
+    CallInst* CI = *i;
+    bool success = InlineFunction(CI, InlineInfo, false);
+    if(!success) {
+      if (debugFlattening)
+        errs() << "Error: Could not inline callee function " << CI->getCalledFunction()->getName()
+                 << " into caller function " << "\n";
+      continue;
+    }
+    if (debugFlattening)    
+      errs() << "Successfully inlined callee function " << CI->getCalledFunction()->getName()
+                 << "into caller function " << "\n";
+  }  
+  
+  return false;
+}
+
+bool FlattenModule::runOnSCC( const std::vector<CallGraphNode *> &scc ) {
+  for( std::vector<CallGraphNode *>::const_iterator
+   i = scc.begin(), e = scc.end(); i != e; ++i ) {
+    if( *i && (*i)->getFunction() ) {
+      Function & F = *(*i)->getFunction();
+      //runOnFunction( F, *i );
+      vectPostOrder.push_back(&F);
+    }
+  }
+  return false;
+}
+
+bool FlattenModule::runOnFunction( Function & F ) {
+  if (debugFlattening)  
+    errs() << "run on function: " << F.getName() << "\n";
+  // only continue if this function is part of makeLeaf and complete inlining is not toggled on
+  if (FLAT == 0){
+    if (std::find(makeLeaf.begin(), makeLeaf.end(), &F) == makeLeaf.end())
+        return false;
+  }
+  if (debugFlattening)  
+    errs() << "makeLeaf: " << F.getName() << "\n";
+  
+  for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I) {
+    Instruction *pInst = &*I;          
+    if(CallInst *CI = dyn_cast<CallInst>(pInst)) {
+      if (!CI->getCalledFunction()->isIntrinsic() && !CI->getCalledFunction()->isDeclaration()) {
+        makeLeaf.push_back(CI->getCalledFunction());
+        inlineCallInsts.push_back(CI);
+      }
+    }
+  }
+
+  return true;
+}
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/FunctionClone.cpp llvm/lib/Transforms/Scaffold/FunctionClone.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/FunctionClone.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/FunctionClone.cpp	2017-10-12 11:09:31.091119588 +0800
@@ -0,0 +1,400 @@
+//===-------------------------- FunctionClone.cpp ------------------------===//
+// This file implements the Scaffold pass of cloning functions with constant 
+// integer or double arguments.
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "FunctionClone"
+#include <sstream>
+#include <algorithm>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/Transforms/Utils/Cloning.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/ScalarEvolution.h"
+#include "llvm/Analysis/ScalarEvolutionExpressions.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+#include "llvm/Support/CallSite.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/ADT/SCCIterator.h"
+
+#define _MAX_FUNCTION_NAME 32
+#define _MAX_INT_PARAMS 4
+#define _MAX_DOUBLE_PARAMS 4
+
+// DEBUG switch
+bool debugCloning = false;
+
+using namespace llvm;
+
+// An anonymous namespace for the pass. Things declared inside it are
+// only visible to the current file.
+namespace {
+
+  // Derived from ModulePass to work on callgraph
+  struct FunctionClone : public ModulePass {
+    static char ID; // Pass identification
+    FunctionClone() : ModulePass(ID) {}
+
+    Function *CloneFunctionInfo(const Function *F, ValueMap<const Value*, WeakVH> &VMap, Module *M);
+    
+    void insertNewCallSite(CallInst *CI, std::string specializedName, Module *M);
+
+    bool runOnModule (Module &M);
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+        AU.setPreservesAll();  
+        AU.addRequired<CallGraph>();
+    }
+
+  }; // End of struct FunctionClone
+} // End of anonymous namespace
+
+
+char FunctionClone::ID = 0;
+static RegisterPass<FunctionClone> X("FunctionClone", "Function Cloning Pass", false, false);
+
+
+Function *FunctionClone::CloneFunctionInfo(const Function *F, ValueMap<const Value*, WeakVH> &VMap, Module *M) {
+  std::vector<Type*> ArgTypes;
+  // the user might be deleting arguments to the function by specifying them in the VMap.
+  // If so, we need to not add the arguments to the ArgTypes vector
+
+  for (Function::const_arg_iterator I = F->arg_begin(), E = F->arg_end(); I!=E; I++)
+    if (VMap.count(I) == 0) // haven't mapped the argument to anything yet?
+      ArgTypes.push_back(I->getType());
+
+  // create a new funcion type...
+  FunctionType *FTy = FunctionType::get(
+      F->getFunctionType()->getReturnType(), ArgTypes, F->getFunctionType()->isVarArg());
+
+  // Create the new function
+  Function *NewF = Function::Create(FTy, F->getLinkage(), F->getName(), M);
+
+  // Loop over the arguments, copying the names of the mapped arguments over...
+  Function::arg_iterator DestI = NewF->arg_begin();
+  for (Function::const_arg_iterator I = F->arg_begin(), E = F->arg_end(); I!=E; ++I)
+    if (VMap.count(I) == 0) {     // is this argument preserved?
+      DestI->setName(I->getName());   // copy the name over..
+      WeakVH wval(DestI++);
+      VMap[I] = wval;          // add mapping to VMap
+    }
+  return NewF;
+}
+
+void FunctionClone::insertNewCallSite(CallInst *CI, std::string specializedName, Module *M) {
+  CallSite CS = CallSite(CI);
+  std::vector<Value*> Args;
+  Args.reserve(CS.arg_size());
+  CallSite::arg_iterator AI = CS.arg_begin();
+  for (unsigned i = 0, e = CI->getCalledFunction()->getFunctionType()->getNumParams();
+      i!=e; ++i, ++AI) //copy arguments FIXME: delete int args
+    Args.push_back(*AI); 
+
+  ArrayRef<Value*> ArgsRef(Args);
+  
+  CallInst* newCall = CallInst::Create(M->getFunction(specializedName), ArgsRef, "", (Instruction*)CI);
+  newCall -> setCallingConv (CS.getCallingConv());
+  if (CI -> isTailCall())
+    newCall -> setTailCall();
+}
+
+bool FunctionClone::runOnModule (Module &M) {
+
+  // iterate over all functions, and over all instructions in those functions
+  // find call sites that have constant integer or double values.
+  CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+  
+  std::vector<Function*> vectPostOrder;
+  
+  for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode), E = scc_end(rootNode); sccIb != E; ++sccIb) {
+    const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+    for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(), E = nextSCC.end(); nsccI != E; ++nsccI) {
+      Function *f = (*nsccI)->getFunction();	  
+      
+      if(f && !f->isDeclaration())
+        vectPostOrder.push_back(f);
+    }
+  }
+
+  unsigned int initial_vector_size = (unsigned int)(vectPostOrder.size());
+
+  
+  //reverse the vector
+  std::reverse(vectPostOrder.begin(),vectPostOrder.end());
+
+
+  //--- start traversing in reverse order for a pre-order
+
+    
+  // keep track of which functions are cloned
+  // and need not be processed when we reach them
+  std::vector <Function*> funcErase;
+  
+  for(std::vector<Function*>::iterator vit = vectPostOrder.begin(), vitE = vectPostOrder.end();
+      vit!=vitE; ++vit) { 
+    Function *f = *vit;      
+    std::string fname = f->getName();
+
+    if (debugCloning) {
+      errs() << "---------------------------------------------" << "\n";
+      errs() << "Caller: " << fname << "\n";
+    }
+
+    // what instructions (call sites) need to be erased after this function has been processed
+    std::vector <Instruction*> instErase;
+    
+    // in vectPostOrder traversal, when reaching a function that has been marked for deletion...
+    // skip and do not inspect it anymore
+    if (std::find(funcErase.begin(), funcErase.end(), (*vit)) != funcErase.end()) {
+      if (debugCloning)
+        errs() << "Skipping...: " << (*vit)->getName() << "\n";  
+      continue;
+    }      
+
+    for (inst_iterator I = inst_begin(*f), E = inst_end(*f); I != E; ++I) {
+      Instruction *pInst = &*I;             
+      if(CallInst *CI = dyn_cast<CallInst>(pInst)) {
+        bool isQuantumModuleCall = false;         
+        for(unsigned iop=0;iop < CI->getNumArgOperands(); iop++) {
+          if (CI->getArgOperand(iop)->getType()->isPointerTy())
+            if(CI->getArgOperand(iop)->getType()->getPointerElementType()->isIntegerTy(16))
+              isQuantumModuleCall = true;
+          if (CI->getArgOperand(iop)->getType()->isIntegerTy(16))
+            isQuantumModuleCall = true;
+        }        
+        if (!CI->getCalledFunction()->isIntrinsic() && !CI->getCalledFunction()->isDeclaration() && isQuantumModuleCall) {
+          // first, find the argument positions of all integers and doubles (regardless of being contstant or not)
+          std::vector<unsigned> posOfInt;
+          std::vector<unsigned> posOfDouble;
+          for(unsigned iop=0;iop < CI->getNumArgOperands(); iop++) {
+            if(dyn_cast<ConstantInt>(CI->getArgOperand(iop)) || CI->getArgOperand(iop)->getType() == Type::getInt32Ty(CI->getContext()))
+              posOfInt.push_back(iop);
+            if(dyn_cast<ConstantFP>(CI->getArgOperand(iop)) || CI->getArgOperand(iop)->getType() == Type::getDoubleTy(CI->getContext()))
+              posOfDouble.push_back(iop);
+          }
+
+          // second, scan for constant int or double arguments and save the argument position with the constant value
+          std::map<unsigned, int> valueOfInt; 
+          std::map<unsigned, double> valueOfDouble; 
+          for(unsigned iop=0;iop < CI->getNumArgOperands(); iop++) {
+            if(ConstantInt *CInt = dyn_cast<ConstantInt>(CI->getArgOperand(iop)))
+              valueOfInt[iop] = CInt->getZExtValue();
+            if(ConstantFP *CDouble = dyn_cast<ConstantFP>(CI->getArgOperand(iop)))
+              // round to 4 decimanl points
+              valueOfDouble[iop] = floorf(CDouble->getValueAPF().convertToDouble() * 10000 + 0.5)/10000;              
+            }
+
+          // now if there were constant arguments present, clone.
+          if (!valueOfInt.empty() || !valueOfDouble.empty()) {
+            Function *F = CI->getCalledFunction();
+            std::string originalName = F->getName().str();    
+            if(debugCloning)
+              errs() << "\n\toriginalName: " << originalName << "\n";
+       
+            // what's the name without all the parameters?
+            std::string::size_type originalCoreEnd;
+            originalCoreEnd = originalName.find(std::string("_IP"));
+            if (originalCoreEnd == std::string::npos) // maybe it's all doubles?
+              originalCoreEnd = originalName.find(std::string("_DP"));        
+            std::string originalCore = originalName.substr(0, originalCoreEnd);
+            if(debugCloning)
+              errs() << "\t\toriginalCore: " << originalCore << "\n";
+
+            // check to see if this function has itself been cloned before as a result of this same pass
+            // if not, pad with "_IPx", _MAX_INT_PARAMS times / "_DPx", _MAX_DOUBLE_PARAMS times.
+            // (it's like a fence to ensure after this point all to-be-cloned modules got IPx_.._IPx_DPx_.._DPX placeholder in their names)              
+            if (originalName == originalCore){
+                std::stringstream padding;
+                for (unsigned j=0; j<_MAX_INT_PARAMS; j++)
+                  padding<<"_IPx";
+                for (unsigned k=0; k<_MAX_DOUBLE_PARAMS; k++) 
+                  padding<<"_DPx";                
+                originalName = originalCore + padding.str();
+            }
+            
+            // read the current value of integers and doubles from the originalName string
+            std::string::size_type found_pos_begin, found_pos_end, found_pos_begin_new;
+            std::vector<std::string> originalInts; 
+            std::vector<std::string> originalDoubles;
+
+            // for IntParams
+            found_pos_begin = originalName.find(std::string("_IP"));
+            while (found_pos_begin != std::string::npos){
+              //because there might be numbers more than 1 digit long, need to find begin and end
+              found_pos_end = originalName.find_first_not_of("012345679-x",found_pos_begin+3);
+              std::string intString = originalName.substr(found_pos_begin+3, found_pos_end-(found_pos_begin+3));
+              //if(intString!=std::string("x"))
+              //  originalInts.push_back(atoi(intString.c_str()));
+              originalInts.push_back(intString);
+              //next one
+              found_pos_begin_new = originalName.find("_IP",found_pos_end);  
+              found_pos_begin = found_pos_begin_new;
+            }
+
+            // for DoubleParams
+            found_pos_begin = originalName.find(std::string("_DP"));
+            while (found_pos_begin != std::string::npos){
+              //because there might be numbers more than 1 digit long, need to find begin and end
+              found_pos_end = originalName.find_first_not_of("0123456789e.-x",found_pos_begin+3);
+              std::string doubleString = originalName.substr(found_pos_begin+3, found_pos_end-(found_pos_begin+3));
+              //if(doubleString!=std::string("x"))              
+              //  originalDoubles.push_back(atof(doubleString.c_str()));
+              originalDoubles.push_back(doubleString);              
+              //next one
+              found_pos_begin_new = originalName.find("_DP",found_pos_end);  
+              found_pos_begin = found_pos_begin_new;
+            }
+
+            /*if (debugCloning)
+              for (std::map<unsigned, int>::iterator i = valueOfInt.begin(), e = valueOfInt.end(); i!=e; ++i)
+                errs()<<"\t\tConstIntPosition: "<<i->first<<", ConstIntValue: "<<i->second<<"\n";            
+            if (debugCloning)
+              for (std::vector<unsigned>::iterator i = posOfInt.begin(), e = posOfInt.end(); i!=e; ++i)
+                errs()<<"\t\tIntPosition: "<<*i<<"\n";                
+            if (debugCloning)
+              for (std::map<unsigned, double>::iterator i = valueOfDouble.begin(), e = valueOfDouble.end(); i!=e; ++i)
+                errs()<<"\t\tConstDoublePosition: "<<i->first<<", ConstDoubleValue: "<<i->second<<"\n";            
+            if (debugCloning)
+              for (std::vector<unsigned>::iterator i = posOfDouble.begin(), e = posOfDouble.end(); i!=e; ++i)
+                errs()<<"\t\tDoublePosition: "<<*i<<"\n"; */
+
+            // Construct the specializedName string. All the above work was done because this has to preserve the same order of arguments.
+            // Check in posOfInt to see where this constant argument lies (0, 1, 2, .., _MAX_NUM_INTS-1). Add current argument in that place.
+            std::stringstream ss; 
+            
+            // fill in the originalInts and originalDoubles with the new constant values of this call site, at the correct position
+            for (std::map<unsigned, int>::iterator i = valueOfInt.begin(), e = valueOfInt.end(); i!=e; ++i) {
+              unsigned pos = std::find(posOfInt.begin(), posOfInt.end(), i->first) - posOfInt.begin();
+              std::stringstream tmp1;
+              tmp1 << i->second;   // in order to convert int to string
+              originalInts[pos] = tmp1.str();
+            }  
+
+            for (std::map<unsigned, double>::iterator i = valueOfDouble.begin(), e = valueOfDouble.end(); i!=e; ++i) {
+              unsigned pos = std::find(posOfDouble.begin(), posOfDouble.end(), i->first) - posOfDouble.begin();
+              std::stringstream tmp2;
+              tmp2 << i->second;
+              originalDoubles[pos] = tmp2.str(); 
+            }           
+
+            for (std::vector<std::string>::iterator i = originalInts.begin(), e = originalInts.end(); i!=e; ++i)
+              ss << "_IP" << *i;
+            for (std::vector<std::string>::iterator j = originalDoubles.begin(), e = originalDoubles.end(); j!=e; ++j){
+              std::replace( j->begin(), j->end(), '.', '_');
+              std::replace( j->begin(), j->end(), '-', '_');
+              ss << "_DP" << *j; 
+            }
+            
+            std::string specializedName = originalCore + ss.str();
+
+            // process specializedName string to convert dots into underscores (for flat qasm generation purposes)
+            //for (unsigned long i = 0; i < specializedName.length(); ++i)
+            //  if (specializedName[i] == '.' || specializedName[i] == '-')
+            //    specializedName[i] = '_';
+
+            // don't clone if it has been before
+            if (M.getFunction(specializedName)) {
+              if (debugCloning)
+                errs() << "\t\tAlready Cloned: " << specializedName << "\n";
+              insertNewCallSite(CI, specializedName, &M);
+              instErase.push_back((Instruction*)CI);
+              continue;
+            }
+
+            ValueMap<const Value*, WeakVH> VMap;
+            Function *specializedFunction = CloneFunctionInfo(F, VMap, &M); 
+            specializedFunction->setName(specializedName);
+
+            if (debugCloning)
+              errs() << "\t\tCloned Function: " << specializedFunction->getName() << "\n";
+
+            // Iterate over function arguments to apply constants to VMap
+            for (Function::arg_iterator i = F->arg_begin(), ie = F->arg_end(); i!=ie; ++i) {
+              Argument *arg = i;
+              unsigned argNo = arg->getArgNo();
+              if (valueOfInt.count(argNo) == 1) { 
+                // Replace int arg with Const expression                     
+                Value *val;                    
+                val = ConstantInt::get(Type::getInt32Ty(M.getContext()), valueOfInt[argNo]);
+                WeakVH wval(val);
+                VMap[i] = wval;
+              }
+              else if (valueOfDouble.count(argNo) == 1) {
+                // Replace double arg with Const expression
+                Value *val;
+                val = ConstantFP::get(Type::getDoubleTy(M.getContext()), valueOfDouble[argNo]);
+                WeakVH wval(val);
+                VMap[i] = wval;
+              }
+            }
+
+            SmallVector<ReturnInst*,1> Returns; // FIXME: what is the length of this vector?
+            ClonedCodeInfo SpecializedFunctionInfo;
+
+            CloneAndPruneFunctionInto (specializedFunction,   // NewFunc
+                                        F,                    // OldFunc
+                                        VMap,                 // ValueMap
+                                        0,                    // ModuleLevelChanges
+                                        Returns,              // Returns
+                                        ".",                  // NameSuffix
+                                        &SpecializedFunctionInfo,  // CodeInfo
+                                        0);                   // TD            
+
+            // replace CI to call the new cloned function
+            insertNewCallSite(CI, specializedName, &M);
+            instErase.push_back((Instruction*)CI); // queue for erasing
+
+            // once a Function is cloned, it is a candidate for removal from vector
+            // mark for deletion
+            if (std::find(funcErase.begin(), funcErase.end(), F) == funcErase.end())
+              funcErase.push_back(F);
+            
+
+            //insert this new cloned function into the vector
+            std::vector<Function*>::iterator it = std::find(vectPostOrder.begin(), vectPostOrder.end(), F);
+            vectPostOrder.insert(it, specializedFunction);
+
+            // the insertion will invalidate vit - reassign the vector to be safe
+            vit = std::find(vectPostOrder.begin(), vectPostOrder.end(), f);
+      
+            
+          }  
+        }
+      }
+    }
+    
+    // remove instructions (call sites) that called the original (before cloning) function
+    for (std::vector<Instruction*>::iterator i = instErase.begin(), e = instErase.end(); i!=e; ++i)
+      (*i)->eraseFromParent();
+
+
+    // recompute vitE in case of change
+    vitE = vectPostOrder.end();
+
+  }
+
+  unsigned int final_vector_size = (unsigned int)(vectPostOrder.size());
+
+  errs() << "Functions Cloned: " << final_vector_size - initial_vector_size << "\n";
+  // Erase functions that were marked for deletion - FIXME: Gives error. Not necessary now.
+  //for (std::vector<Function*>::iterator i = funcErase.begin(), e = funcErase.end(); i != e; ++i)
+  //  (*i)->eraseFromParent();
+
+  return true;
+
+} // End runOnModule
+
+
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/FunctionDuplicate.cpp llvm/lib/Transforms/Scaffold/FunctionDuplicate.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/FunctionDuplicate.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/FunctionDuplicate.cpp	2017-10-12 11:09:31.091119588 +0800
@@ -0,0 +1,509 @@
+//===-------------------------- FunctionDuplicate.cpp ------------------------===//
+// This file implements the Scaffold pass of duplicating functions to create
+// {fname}_quantum functions.
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "FunctionDuplicate"
+#include <sstream>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/Transforms/Utils/Cloning.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/ScalarEvolution.h"
+#include "llvm/Analysis/ScalarEvolutionExpressions.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+#include "llvm/Support/CallSite.h"
+#include "llvm/LLVMContext.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/ADT/SCCIterator.h"
+
+// DEBUG switch
+bool debugDuplicate = false;
+
+using namespace llvm;
+using namespace std;
+
+// An anonymous namespace for the pass. Things declared inside it are
+// only visible to the current file.
+namespace {
+
+  vector<Instruction*> vInstRemove;
+
+  vector<BasicBlock::iterator> vectSplitInsts;
+
+  vector<BasicBlock::iterator> vectSplitInsts2;  
+
+  vector<BranchInst*> vBranchReplace;
+
+
+
+  // Derived from ModulePass to work on callgraph
+  struct FunctionDuplicate : public ModulePass {
+    static char ID; // Pass identification
+
+    //external instrumentation function
+    Function* qasmResSum; 
+    Function* memoize; 
+    
+    FunctionDuplicate() : ModulePass(ID) {}
+
+    Function *CloneFunctionInfo(const Function *F, ValueMap<const Value*, WeakVH> &VMap, Module *M);
+
+    ArrayRef<Value*> getMemoizeArgs(Function* F, Instruction* I);    
+
+    void visitFunction(Function &F);
+    
+    void insertNewCallSite(CallInst *CI, std::string specializedName, Module *M);
+
+    bool runOnModule (Module &M);
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+        AU.setPreservesAll();  
+        AU.addRequired<CallGraph>();
+    }
+
+  }; // End of struct FunctionDuplicate
+} // End of anonymous namespace
+
+
+char FunctionDuplicate::ID = 0;
+static RegisterPass<FunctionDuplicate> X("FunctionDuplicate", "Function Duplicating Pass", false, false);
+
+
+Function *FunctionDuplicate::CloneFunctionInfo(const Function *F, ValueMap<const Value*, WeakVH> &VMap, Module *M) {
+  std::vector<Type*> ArgTypes;
+  // the user might be deleting arguments to the function by specifying them in the VMap.
+  // If so, we need to not add the arguments to the ArgTypes vector
+
+  for (Function::const_arg_iterator I = F->arg_begin(), E = F->arg_end(); I!=E; I++)
+    if (VMap.count(I) == 0) // haven't mapped the argument to anything yet?
+      ArgTypes.push_back(I->getType());
+
+  // create a new funcion type...
+  FunctionType *FTy = FunctionType::get(
+      F->getFunctionType()->getReturnType(), ArgTypes, F->getFunctionType()->isVarArg());
+
+  // Create the new function
+  Function *NewF = Function::Create(FTy, F->getLinkage(), F->getName(), M);
+
+  // Loop over the arguments, copying the names of the mapped arguments over...
+  Function::arg_iterator DestI = NewF->arg_begin();
+  for (Function::const_arg_iterator I = F->arg_begin(), E = F->arg_end(); I!=E; ++I)
+    if (VMap.count(I) == 0) {     // is this argument preserved?
+      DestI->setName(I->getName());   // copy the name over..
+      WeakVH wval(DestI++);
+      VMap[I] = wval;          // add mapping to VMap
+    }
+  return NewF;
+}
+
+
+ArrayRef<Value*> FunctionDuplicate::getMemoizeArgs(Function* F, Instruction* I) {
+  // int memoize (char *function_name, int *int_params, unsigned num_ints, double *double_params, unsigned num_doubles)          
+  vector <Value*> vectCallArgs;
+  BasicBlock::iterator it(I);
+
+  Constant *StrConstant = ConstantDataArray::getString(I->getContext(), F->getName());           
+  ArrayType* strTy = cast<ArrayType>(StrConstant->getType());
+  AllocaInst* strAlloc = new AllocaInst(strTy,"",&*it);
+  new StoreInst(StrConstant,strAlloc,"",&*it);	  	  
+  Value* Idx[2];	  
+  Idx[0] = Constant::getNullValue(Type::getInt32Ty(I->getContext()));  
+  Idx[1] = ConstantInt::get(Type::getInt32Ty(I->getContext()),0);
+  GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", &*it);
+  
+  Value *intArgPtr;
+  vector<Value*> vIntArgs;
+  unsigned num_ints = 0;
+  Value *doubleArgPtr;
+  vector<Value*> vDoubleArgs;
+  unsigned num_doubles = 0;
+
+  for (Function::arg_iterator FuncArg = F->arg_begin(), E = F->arg_end(); FuncArg != E; ++FuncArg) {
+
+    Value *callArg = (Value*)FuncArg;
+    // Integer Arguments
+    if(ConstantInt *CInt = dyn_cast<ConstantInt>(callArg)){
+      intArgPtr = CInt;
+      num_ints++;
+      vIntArgs.push_back(intArgPtr);          
+    }
+    else if (callArg->getType() == Type::getInt32Ty(I->getContext())){ //FIXME: make sure it's an integer
+      intArgPtr = CastInst::CreateIntegerCast(callArg, Type::getInt32Ty(I->getContext()), false, "", &*it);
+      num_ints++;
+      vIntArgs.push_back(intArgPtr);          
+    }
+
+    // Double Arguments
+    if(ConstantFP *CDouble = dyn_cast<ConstantFP>(callArg)){ 
+      doubleArgPtr = CDouble;
+      vDoubleArgs.push_back(doubleArgPtr);          
+      num_doubles++;
+    }
+    else if (callArg->getType() == Type::getDoubleTy(I->getContext())){ //FIXME: make sure it's an integer
+      doubleArgPtr = CastInst::CreateFPCast(callArg, Type::getDoubleTy(I->getContext()), "", &*it);          
+      num_doubles++;
+      vDoubleArgs.push_back(doubleArgPtr);          
+    }
+  }
+  
+  ArrayType *intArrTy = ArrayType::get(Type::getInt32Ty(I->getContext()), num_ints);
+  AllocaInst *intArrAlloc = new AllocaInst(intArrTy, "", &*it);
+  for (unsigned i=0; i<num_ints; i++) {
+    Value *Int = vIntArgs[i];        
+    Idx[1] = ConstantInt::get(Type::getInt32Ty(I->getContext()),i);        
+    Value *intPtr = GetElementPtrInst::CreateInBounds(intArrAlloc, Idx, "", &*it);        
+    new StoreInst(Int, intPtr, "", &*it);
+  }
+  Idx[1] = ConstantInt::get(Type::getInt32Ty(I->getContext()),0);        
+  GetElementPtrInst* intArrPtr = GetElementPtrInst::CreateInBounds(intArrAlloc, Idx, "", &*it);
+
+  ArrayType *doubleArrTy = ArrayType::get(Type::getDoubleTy(getGlobalContext()), num_doubles);        
+  AllocaInst *doubleArrAlloc = new AllocaInst(doubleArrTy,"", &*it);
+  for (unsigned i=0; i<num_doubles; i++) {
+    Value *Double = vDoubleArgs[i];     
+    Idx[1] = ConstantInt::get(Type::getInt32Ty(getGlobalContext()),i);        
+    Value *doublePtr = GetElementPtrInst::CreateInBounds(doubleArrAlloc, Idx, "", &*it);        
+    new StoreInst(Double, doublePtr, "", &*it);          
+  }
+  GetElementPtrInst* doubleArrPtr = GetElementPtrInst::CreateInBounds(doubleArrAlloc, Idx, "", &*it);
+
+  Constant *IntNumConstant = ConstantInt::get(Type::getInt32Ty(getGlobalContext()) , num_ints, false);       
+  Constant *DoubleNumConstant = ConstantInt::get(Type::getInt32Ty(getGlobalContext()) , num_doubles, false);          
+
+  vectCallArgs.push_back(cast<Value>(strPtr));
+  vectCallArgs.push_back(cast<Value>(intArrPtr));
+  vectCallArgs.push_back(IntNumConstant);          
+  vectCallArgs.push_back(cast<Value>(doubleArrPtr));
+  vectCallArgs.push_back(DoubleNumConstant);          
+
+  ArrayRef<Value*> call_args(vectCallArgs);  
+  return call_args;
+}
+
+void FunctionDuplicate::visitFunction(Function &F) {
+  // insert initialization and termination functions in "main"
+  if(F.getName() == "main"){
+    BasicBlock* BB_last = &(F.back());
+    TerminatorInst *BBTerm = BB_last->getTerminator();
+    CallInst::Create(qasmResSum, "",(Instruction*)BBTerm);	
+    return;
+  }
+}
+
+bool FunctionDuplicate::runOnModule (Module &M) {
+    
+  //void qasm_resource_summary ()
+  qasmResSum = cast<Function>(M.getOrInsertFunction("summary", Type::getVoidTy(M.getContext()), (Type*)0));
+  
+  // int memoize (char*, int*, unsigned, double*, unsigned)
+  vector <Type*> vectParamTypes2;
+  vectParamTypes2.push_back(Type::getInt8Ty(M.getContext())->getPointerTo());      
+  vectParamTypes2.push_back(Type::getInt32Ty(M.getContext())->getPointerTo());
+  vectParamTypes2.push_back(Type::getInt32Ty(M.getContext()));
+  vectParamTypes2.push_back(Type::getDoubleTy(M.getContext())->getPointerTo());
+  vectParamTypes2.push_back(Type::getInt32Ty(M.getContext()));
+  ArrayRef<Type*> Param_Types2(vectParamTypes2);
+  Type* Result_Type2 = Type::getInt32Ty(M.getContext());
+  memoize = cast<Function> (  
+      M.getOrInsertFunction(
+        "memoize",                          /* Name of Function */
+        FunctionType::get(                  /* Type of Function */
+          Result_Type2,                     /* Result */
+          Param_Types2,                     /* Params */
+          false                             /* isVarArg */
+          )
+        )
+      );
+
+  
+  // iterate over all functions, and over all instructions in those functions
+  // find call sites that have constant integer or double values. In Post-Order.
+  CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+  
+  std::vector<Function*> vectPostOrder;
+  
+  for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode), E = scc_end(rootNode); sccIb != E; ++sccIb) {
+    const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+    for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(), E = nextSCC.end(); nsccI != E; ++nsccI) {
+      Function *F = (*nsccI)->getFunction();	  
+      
+      if (F==NULL)
+        continue;
+
+      // is this a call to a quantum module? Only those should be instrumented
+      // quantum modules arguments are either qbit or qbit* type
+      bool isQuantumModuleCall = false;
+      for (Function::arg_iterator FuncArg = F->arg_begin(), E = F->arg_end(); FuncArg != E; ++FuncArg) {
+        if ((&*FuncArg)->getType()->isPointerTy())
+          if((&*FuncArg)->getType()->getPointerElementType()->isIntegerTy(16))
+            isQuantumModuleCall = true;
+        if ((&*FuncArg)->getType()->isIntegerTy(16))
+          isQuantumModuleCall = true;      
+      }
+
+      if((F->getName().find("main")!=string::npos) || (!F->isDeclaration() && isQuantumModuleCall))
+        vectPostOrder.push_back(F);
+    }
+  }
+  
+  //reverse the vector
+  std::reverse(vectPostOrder.begin(),vectPostOrder.end());
+
+  // Start traversing in reverse order for a pre-order
+
+  errs()<<"Functions to be duplicated with _qtm appendix:\n";
+  for(std::vector<Function*>::iterator vit = vectPostOrder.begin(), vitE = vectPostOrder.end();
+      vit!=vitE; ++vit) { 
+    Function *F = *vit;      
+
+    // for each quantum function create one with a _qtm appendix
+    // which does the job of printing out qasm
+    errs()<<F->getName()<<"\n";
+    
+    std::stringstream ss; 
+    ss << "_qtm";
+    std::string specializedName = F->getName().str() + ss.str();
+
+    ValueMap<const Value*, WeakVH> VMap;
+    Function *specializedFunction = CloneFunctionInfo(F, VMap, &M); 
+    specializedFunction->setName(specializedName);
+
+    SmallVector<ReturnInst*,1> Returns; // FIXME: what is the length of this vector?
+    ClonedCodeInfo SpecializedFunctionInfo;
+
+    CloneAndPruneFunctionInto (specializedFunction,   // NewFunc
+                                F,                    // OldFunc
+                                VMap,                 // ValueMap
+                                0,                    // ModuleLevelChanges
+                                Returns,              // Returns
+                                ".",                  // NameSuffix
+                                &SpecializedFunctionInfo,  // CodeInfo
+                                0);                   // TD            
+  
+    // after all "alloca" instructions, insert calls to the "memoize" and {fname}_qtm functions
+    // use exactly the same arguments as those input arguments to the function declaration 
+    inst_iterator instIter = inst_begin(F);
+    while(isa<AllocaInst>(*instIter))
+      ++instIter;
+
+    // int memoize (char *function_name, int *int_params, unsigned num_ints, double *double_params, unsigned num_doubles)                  
+    //---errs() << "1\n";
+    //--CallInst::Create(memoize, getMemoizeArgs(F, &*instIter), "", &*instIter);      
+    //ArrayRef<Value*> FunctionDuplicate::getMemoizeArgs(Function* F, Instruction* I){
+    Instruction* myI = &*instIter;
+
+      // int memoize (char *function_name, int *int_params, unsigned num_ints, double *double_params, unsigned num_doubles)          
+      vector <Value*> vectCallArgs;
+      BasicBlock::iterator it(myI);
+
+      Constant *StrConstant = ConstantDataArray::getString(myI->getContext(), F->getName());           
+      ArrayType* strTy = cast<ArrayType>(StrConstant->getType());
+      AllocaInst* strAlloc = new AllocaInst(strTy,"",&*it);
+      new StoreInst(StrConstant,strAlloc,"",&*it);    
+      Value* Idx[2];  
+      Idx[0] = Constant::getNullValue(Type::getInt32Ty(myI->getContext()));  
+      Idx[1] = ConstantInt::get(Type::getInt32Ty(myI->getContext()),0);
+      GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", &*it);
+  
+      Value *intArgPtr;
+      vector<Value*> vIntArgs;
+      unsigned num_ints = 0;
+      Value *doubleArgPtr;
+      vector<Value*> vDoubleArgs;
+      unsigned num_doubles = 0;
+
+      for (Function::arg_iterator FuncArg = F->arg_begin(), E = F->arg_end(); FuncArg != E; ++FuncArg) {
+
+	Value *callArg = (Value*)FuncArg;
+	// Integer Arguments
+	if(ConstantInt *CInt = dyn_cast<ConstantInt>(callArg)){
+	  intArgPtr = CInt;
+	  num_ints++;
+	  vIntArgs.push_back(intArgPtr);          
+	}
+	else if (callArg->getType() == Type::getInt32Ty(myI->getContext())){ //FIXME: make sure it's an integer
+	  intArgPtr = CastInst::CreateIntegerCast(callArg, Type::getInt32Ty(myI->getContext()), false, "", &*it);
+	  num_ints++;
+	  vIntArgs.push_back(intArgPtr);          
+	}
+
+	// Double Arguments
+	if(ConstantFP *CDouble = dyn_cast<ConstantFP>(callArg)){ 
+	  doubleArgPtr = CDouble;
+	  vDoubleArgs.push_back(doubleArgPtr);          
+	  num_doubles++;
+	}
+	else if (callArg->getType() == Type::getDoubleTy(myI->getContext())){ //FIXME: make sure it's an integer
+	  doubleArgPtr = CastInst::CreateFPCast(callArg, Type::getDoubleTy(myI->getContext()), "", &*it);          
+	  num_doubles++;
+	  vDoubleArgs.push_back(doubleArgPtr);          
+	}
+      }
+  
+      ArrayType *intArrTy = ArrayType::get(Type::getInt32Ty(myI->getContext()), num_ints);
+      AllocaInst *intArrAlloc = new AllocaInst(intArrTy, "", &*it);
+      for (unsigned i=0; i<num_ints; i++) {
+	Value *Int = vIntArgs[i];        
+	Idx[1] = ConstantInt::get(Type::getInt32Ty(myI->getContext()),i);        
+	Value *intPtr = GetElementPtrInst::CreateInBounds(intArrAlloc, Idx, "", &*it);        
+	new StoreInst(Int, intPtr, "", &*it);
+      }
+      Idx[1] = ConstantInt::get(Type::getInt32Ty(myI->getContext()),0);        
+      GetElementPtrInst* intArrPtr = GetElementPtrInst::CreateInBounds(intArrAlloc, Idx, "", &*it);
+
+      ArrayType *doubleArrTy = ArrayType::get(Type::getDoubleTy(getGlobalContext()), num_doubles);        
+      AllocaInst *doubleArrAlloc = new AllocaInst(doubleArrTy,"", &*it);
+      for (unsigned i=0; i<num_doubles; i++) {
+	Value *Double = vDoubleArgs[i];     
+	Idx[1] = ConstantInt::get(Type::getInt32Ty(getGlobalContext()),i);        
+	Value *doublePtr = GetElementPtrInst::CreateInBounds(doubleArrAlloc, Idx, "", &*it);        
+	new StoreInst(Double, doublePtr, "", &*it);          
+      }
+      GetElementPtrInst* doubleArrPtr = GetElementPtrInst::CreateInBounds(doubleArrAlloc, Idx, "", &*it);
+
+      Constant *IntNumConstant = ConstantInt::get(Type::getInt32Ty(getGlobalContext()) , num_ints, false);       
+      Constant *DoubleNumConstant = ConstantInt::get(Type::getInt32Ty(getGlobalContext()) , num_doubles, false);          
+
+      vectCallArgs.push_back(cast<Value>(strPtr));
+      vectCallArgs.push_back(cast<Value>(intArrPtr));
+      vectCallArgs.push_back(IntNumConstant);          
+      vectCallArgs.push_back(cast<Value>(doubleArrPtr));
+      vectCallArgs.push_back(DoubleNumConstant);          
+
+      ArrayRef<Value*> call_args(vectCallArgs);  
+      //return call_args;
+      //}
+      CallInst::Create(memoize, call_args, "", &*instIter); 
+
+      //errs() << "2\n";
+    // void {fname}_qtm (qbit* ..., int* ..., double* ...)
+    std::vector<Value*> Args;
+    for (Function::arg_iterator FuncArg = F->arg_begin(), e = F->arg_end(); FuncArg!=e; ++FuncArg)
+      Args.push_back(cast<Value>(FuncArg));         
+    ArrayRef<Value*> ArgsRef(Args);
+    CallInst::Create(M.getFunction(specializedName), ArgsRef, "", &*instIter);
+
+
+  } // end function iterator
+
+  // iterate a second time to mark places for splitting basic blocks
+  for (Module::iterator F = M.begin(); F != M.end(); ++F) {
+    for (Function::iterator BB = (*F).begin(); BB != (*F).end(); ++BB) {
+      for (BasicBlock::iterator I = (*BB).begin(); I != (*BB).end(); ++I) {
+        if (CallInst *CI = dyn_cast<CallInst>(&*I)) {
+          if (CI->getCalledFunction()->getName().find("memoize")!=string::npos)
+            vectSplitInsts.push_back(++I);
+        }
+      }
+    }
+  }   
+
+  // iterate a third time to mark places for splitting basic blocks
+  for (Module::iterator F = M.begin(); F != M.end(); ++F) {
+    for (Function::iterator BB = (*F).begin(); BB != (*F).end(); ++BB) {
+      for (BasicBlock::iterator I = (*BB).begin(); I != (*BB).end(); ++I) {
+        if (CallInst *CI = dyn_cast<CallInst>(&*I)) {
+          if (CI->getCalledFunction()->getName().find("_qtm")!=string::npos)
+            vectSplitInsts2.push_back(++I);
+        }
+      }
+    }
+  }  
+
+  // split the if.then part
+  if (debugDuplicate)
+    errs()<<"if.then part:\n";
+  for(vector<BasicBlock::iterator>::iterator v = vectSplitInsts.begin(); v != vectSplitInsts.end(); ++v) {
+    Instruction *pInst = &*(*v);
+    if (debugDuplicate)
+      pInst->dump();
+    BasicBlock *BB = pInst->getParent();
+    BB->splitBasicBlock(*v, Twine("memoize.if.then"));
+  }
+
+  // split the if.end part      
+  if (debugDuplicate)      
+    errs()<<"if.end part:\n";
+  for(vector<BasicBlock::iterator>::iterator v = vectSplitInsts2.begin(); v != vectSplitInsts2.end(); ++v) {
+    Instruction *pInst = &*(*v);
+    if (debugDuplicate)
+      pInst->dump();
+    BasicBlock *BB = pInst->getParent();
+    BB->splitBasicBlock(*v, Twine("memoize.if.end"));
+  }
+
+  // second iteration over instructions -- to change branches to conditional branch
+  for (Module::iterator F = M.begin(); F != M.end(); ++F) {
+    for (Function::iterator BB = (*F).begin(); BB != (*F).end(); ++BB) {
+      for (BasicBlock::iterator I = (*BB).begin(); I != (*BB).end(); ++I) {
+        if (BranchInst *BI = dyn_cast<BranchInst>(&*I)) {
+          if (BI->isUnconditional() && BI->getSuccessor(0)->getName().find("memoize.if.then")!=string::npos) {
+            vBranchReplace.push_back(BI);
+                          }
+        }
+      }
+    }
+    visitFunction(*F); // visit function must happen after Basic Block splittings since it creates
+                      // the "exit_scope()" call for all functions, and they must always be at the end        
+  }
+  
+
+  // removing instructions that were marked for deletion
+  for(vector<Instruction*>::iterator iterInst = vInstRemove.begin(); iterInst != vInstRemove.end(); ++iterInst) {
+    if (debugDuplicate)
+      errs() << "removing call to: " << (dyn_cast<CallInst>(*iterInst))->getCalledFunction()->getName() << "\n";
+    (*iterInst)->eraseFromParent();
+  }
+
+  // replacing branches ...
+  for(vector<BranchInst*>::iterator iterInst = vBranchReplace.begin(); iterInst != vBranchReplace.end(); ++iterInst) {
+    BranchInst* BI = (*iterInst);
+    if (debugDuplicate){
+      errs() << "replacing branch: \n";
+      BI->dump();
+    }
+
+    BasicBlock::iterator ii(BI);
+    Instruction *memoizeInstruction = &*(--ii);                              // the call to memoize
+           
+    BasicBlock *currentBlock = BI->getParent();
+    BasicBlock *trueBlock = BI->getSuccessor(0)->getTerminator()->getSuccessor(0);
+    BasicBlock *falseBlock = BI->getSuccessor(0);
+
+    if (debugDuplicate) {
+      errs() << "current block: " << currentBlock->getName() << "\n";
+      errs() << "true block: " << trueBlock->getName() << "\n";
+      errs() << "false block: " << falseBlock->getName() << "\n";
+    }
+    
+    // erasing this currentBlock's unconditional branch instruction
+    currentBlock->getTerminator()->eraseFromParent();
+
+    // inserting ICmpInst at the end of currentBlock
+    ICmpInst *test = new ICmpInst(*currentBlock, CmpInst::ICMP_EQ, 
+        memoizeInstruction, ConstantInt::get(Type::getInt32Ty(M.getContext()), 1), "shadow check");
+          
+    BranchInst::Create (trueBlock, falseBlock, test, currentBlock);
+    
+  }      
+
+  return true;
+
+} // End runOnModule
+
+
+
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GateCount.cpp llvm/lib/Transforms/Scaffold/GateCount.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GateCount.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/GateCount.cpp	2017-10-12 11:09:31.091119588 +0800
@@ -0,0 +1,147 @@
+//===----------------------------- GateCount.cpp -------------------------===//
+// This file implements the Scaffold Pass of counting the number of qbits and
+// gates in a program in callgraph post-order.
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "ResourceCount"
+#include <vector>
+#include <limits>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/ADT/SCCIterator.h"
+
+
+using namespace llvm;
+
+// An anonymous namespace for the pass. Things declared inside it are
+// only visible to the current file.
+namespace {
+
+  // Derived from ModulePass to count qbits in functions
+  struct GateCount : public ModulePass {
+    static char ID; // Pass identification
+    GateCount() : ModulePass(ID) {}
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();  
+      AU.addRequired<CallGraph>();    
+    }
+    
+    void CountFunctionGates (Function *F, std::map <Function*, unsigned long long* > FunctionGates) const {
+      // Traverse instruction by instruction
+      for (inst_iterator I = inst_begin(*F), E = inst_end(*F); I != E; ++I) {
+
+        Instruction *Inst = &*I;                            // Grab pointer to instruction reference
+
+        if (CallInst *CI = dyn_cast<CallInst>(Inst)) {      // Filter Call Instructions
+          Function *callee = CI->getCalledFunction();
+          if (callee->isIntrinsic()) {                      // Intrinsic (Gate) Functions calls
+            if (callee->getName().str() == "llvm.X") 
+              FunctionGates[F][0]++;
+            else if (callee->getName().str() == "llvm.Z") 
+              FunctionGates[F][1]++;
+            else if (callee->getName().str() == "llvm.H") 
+              FunctionGates[F][2]++;
+            else if (callee->getName().str() == "llvm.T") 
+              FunctionGates[F][3]++;
+            else if (callee->getName().str() == "llvm.CNOT")
+              //std::vector<int> x = FunctionGates[F];
+              //x.insert(x.begin(),1);
+              FunctionGates[F][4]++;
+            else if (callee->getName().str() == "llvm.Toffoli") 
+              FunctionGates[F][5]++;
+            else if (callee->getName().str() == "llvm.RZ") 
+              FunctionGates[F][6]++;
+            else if (callee->getName().str() == "llvm.PrepZ") 
+              FunctionGates[F][7]++;
+            else if (callee->getName().str() == "llvm.MeasZ") 
+              FunctionGates[F][8]++;
+          }
+
+          else {                                              // Non-intrinsic Function Calls
+            // Gate numbers must be previously entered
+            // for this call. Look them up and add to this function's numbers.
+            unsigned long long* callee_numbers = FunctionGates.find(callee)->second;
+            for (int l=0; l<9; l++)
+              FunctionGates[F][l] += callee_numbers[l];
+          }
+
+        }
+
+      }
+    }
+
+    virtual bool runOnModule (Module &M) {
+      // Function* ---> X | Z | H | T | CNOT | Toffoli | Rz | PrepZ | MeasZ
+      std::map <Function*, unsigned long long*> FunctionGates;
+
+      // unsigned long long is 18x10^18 digits longs. good enough.
+      // errs() << "LONG LONG LIMIT: " << std::numeric_limits<unsigned long long>::max() << "\n";
+
+      errs() << "\t\tX\t\tZ\t\tH\t\tT\t\tCNOT\t\tToffoli\t\tRz\t\tPrepZ\t\tMeasZ\n";
+
+      // iterate over all functions, and over all instructions in those functions
+      // find call sites that have constant integer values. In Post-Order.
+      CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+      
+      //fill in the gate count bottom-up in the call graph
+      for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode), E = scc_end(rootNode); sccIb != E; ++sccIb) {
+        const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+        //errs() << "\nSCC #" << ++sccNum << " : ";      
+        for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(), E = nextSCC.end(); nsccI != E; ++nsccI) {
+          Function *F = (*nsccI)->getFunction();	  
+
+          // dynamically create array holding gate numbers for this function
+          unsigned long long* GateNumbers = new unsigned long long[9];
+          for (int k=0; k<9; k++)
+            GateNumbers[k] = 0;
+          FunctionGates.insert(std::make_pair(F, GateNumbers));
+
+          // count the gates of this function
+          CountFunctionGates(F, FunctionGates);
+
+        }
+      }
+
+      // print results      
+      for (std::map<Function*, unsigned long long*>::iterator i = FunctionGates.begin(), e = FunctionGates.end(); i!=e; ++i) {
+        errs() << "Function: " << i->first->getName() << "\n";
+        for (int j=0; j<9; j++)
+          errs() << "\t" << (i->second)[j];
+        errs() << "\n";
+      }
+
+      unsigned long long total_gates = 0;
+      for (int j=0; j<9;j++)
+        total_gates += FunctionGates.find(M.getFunction("main"))->second[j];
+      errs() << "\ntotal_gates = " << total_gates << "\n";
+
+      // free memory
+      for (std::map<Function*, unsigned long long*>::iterator i = FunctionGates.begin(), e = FunctionGates.end(); i!=e; ++i)
+        delete [] i->second;
+
+
+      return false;
+    } // End runOnModule
+  }; // End of struct GateCount
+} // End of anonymous namespace
+
+
+
+char GateCount::ID = 0;
+static RegisterPass<GateCount> X("GateCount", "Gate Counter Pass");
+
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GenLPFSSchedule.cpp llvm/lib/Transforms/Scaffold/GenLPFSSchedule.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GenLPFSSchedule.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/GenLPFSSchedule.cpp	2017-10-12 11:09:31.092119597 +0800
@@ -0,0 +1,2257 @@
+//===----------------- GenLPFSSched.cpp ----------------------===//
+// This file implements the Scaffold Pass of counting the number 
+//  of critical timesteps and gate parallelism in program
+//  in callgraph post-order.
+//
+//        This file was created by Scaffold Compiler Working Group
+// Fine-grained list scheduling for leaf modules
+// Coarse-grained scheduling for non-leaf modules
+// Get T gate proportion within schedule length
+// Cleaned up the code
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "GenLPFSSched"
+#include <vector>
+#include <iostream> 
+#include <limits>
+#include <map>
+#include <string>
+#include <sstream>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/ADT/SCCIterator.h"
+#include "llvm/Argument.h"
+#include "llvm/ADT/ilist.h"
+#include "llvm/Constants.h"
+#include "llvm/IntrinsicInst.h"
+#include "llvm/Support/CommandLine.h"
+//#include "llvm/ScheduleDAG.h"
+
+
+using namespace llvm;
+using namespace std;
+
+static cl::opt<unsigned>
+RES_CONSTRAINT("simd-kconstraint-lpfs", cl::init(8), cl::Hidden,
+  cl::desc("k in SIMD-k Resource Constrained Scheduling"));
+
+static cl::opt<unsigned>
+DATA_CONSTRAINT("simd-dconstraint-lpfs", cl::init(1024), cl::Hidden,
+  cl::desc("d in SIMD-d Resource Constrained Scheduling"));
+
+static cl::opt<unsigned>
+SIMD_L("simd_l", cl::init(1), cl::Hidden,
+  cl::desc("l value for longest path first (lpfs)"));
+
+static cl::opt<unsigned>
+REFILL("refill", cl::init(0), cl::Hidden,
+  cl::desc("refill value, whether or not to use refill in lpfs")); 
+
+static cl::opt<unsigned>
+OPP_SIMD("opp_simd", cl::init(1), cl::Hidden,
+  cl::desc("opportunistic scheduling with lpfs")); 
+
+static cl::opt<unsigned>
+LOCAL_MEM("local_mem", cl::init(0), cl::Hidden,
+  cl::desc("local memory scheduling with lpfs"));
+
+static cl::opt<unsigned>
+LOCAL_Q("local_Q", cl::init(INT_MAX), cl::Hidden,
+  cl::desc("Q parameter for local memory depth"));
+
+static cl::opt<unsigned>
+LOCAL_WINDOW("local_W", cl::init(10), cl::Hidden,
+  cl::desc("Look-ahead window parameter for local mem"));
+
+static cl::opt<unsigned>
+METRICS("metrics", cl::init(0), cl::Hidden,
+  cl::desc("Print Metrics"));
+
+static cl::opt<unsigned>
+FULL_SCHED("full_sched", cl::init(0), cl::Hidden,
+  cl::desc("Print Full Schedules"));
+
+static cl::opt<unsigned>
+MOVES_SCHED("moves_sched", cl::init(0), cl::Hidden,
+  cl::desc("Print Schedule of Move Instructions"));
+
+static cl::opt<unsigned>
+LOCAL_MOVES_SCHED("local_moves_sched", cl::init(0), cl::Hidden,
+  cl::desc("Print Schedule of Local Move Instructions"));
+
+
+
+#define MAX_RES_CONSTRAINT 2000 
+#define SSCHED_THRESH 10000000
+
+#define MAX_GATE_ARGS 30
+#define MAX_BT_COUNT 15 //max backtrace allowed - to avoid infinite recursive loops
+#define NUM_QGATES 17
+#define _CNOT 0
+#define _H 1
+#define _S 2
+#define _T 3
+#define _X 4
+#define _Y 5
+#define _Z 6
+#define _MeasX 7
+#define _MeasZ 8
+#define _PrepX 9
+#define _PrepZ 10
+#define _Tdag 11
+#define _Sdag 12
+#define _Rz 13
+#define _Toffoli 14
+#define _Fredkin 15
+#define _All 16
+
+bool debugGenLPFSSched = false; 
+
+namespace {
+
+  typedef pair<Instruction*, uint64_t> InstPri; //instpriority
+  
+  struct CompareInstPriByValue {
+    bool operator() (const InstPri& a, const InstPri& b) const {
+      return a.second < b.second;
+    };
+  };
+
+  struct modularInfo{
+    uint64_t width;
+    uint64_t length;
+    //uint64_t ancilla;
+    uint64_t tgates;
+    uint64_t tgates_ub;
+    uint64_t tgates_par;
+    uint64_t tgates_par_ub;
+    modularInfo(): width(0), length(0), tgates(0), tgates_ub(0), tgates_par(0), tgates_par_ub(0) {}
+  };
+
+
+  struct qGateArg{ //arguments to qgate calls
+    Value* argPtr;
+    int argNum;
+    bool isQbit;
+    bool isCbit;
+    bool isUndef;
+    bool isPtr;
+    int valOrIndex; //Value if not Qbit, Index if Qbit & not a Ptr
+    double angle;
+    qGateArg(): argPtr(NULL), argNum(-1), isQbit(false), isCbit(false), isUndef(false), isPtr(false), valOrIndex(-1), angle(0.0){ }
+  };
+  
+struct qArgInfo{
+  string name;
+  int index;
+  int id;
+  int simd;
+  int loc;
+  int nextTS;
+  Instruction* last_inst;
+  qArgInfo(): name("none"), index(-1), id(-1), simd(0), loc(0), nextTS(-1), last_inst(NULL) { }
+
+  bool operator == (const qArgInfo& a) const{
+    return (name == a.name && index == a.index);
+    }
+};
+
+struct qGate{
+  Function* qFunc;
+  int numArgs;
+  qArgInfo args[MAX_GATE_ARGS];
+  double angle;
+  qGate():qFunc(NULL), numArgs(0), angle(0.0) { }
+};
+
+struct op{
+  qGate name;
+  int id;
+  int ts;
+  int dist;
+  bool followed;
+  int simd;
+  int tag;
+  int path;
+  Instruction* label;
+  vector<Instruction*> in_edges;
+  vector<Instruction*> out_edges;
+  op(): name(),id(-1),ts(-1),dist(-1),followed(0),simd(-1),tag(0),path(0),label(NULL),in_edges(),out_edges() { }
+};
+
+struct qubit{
+  string name;
+  int index;
+  int size;
+  int last_op;
+  vector<op> ops;
+  int simd;
+  int id;
+  qubit():name("none"),index(0),size(1),last_op(-1),ops(),simd(-1),id(-1) { }
+};
+
+struct move{
+  int ts;
+  int src;
+  int dest;
+  qArgInfo arg;
+  move():ts(-1),src(-1),dest(-1),arg() { }
+};
+
+  struct ArrParGates{
+    int typeOfGate[MAX_RES_CONSTRAINT];
+    uint64_t numGates[MAX_RES_CONSTRAINT];
+  };
+
+  struct GenLPFSSched : public ModulePass {
+    static char ID; // Pass identification
+    
+    string gate_name[NUM_QGATES];
+    vector<qGateArg> tmpDepQbit;
+    vector<Value*> vectQbit;
+    
+    int btCount; //backtrace count
+
+    modularInfo totalSched;
+    modularInfo currSched;
+
+    map<string, int> gate_index;    
+
+    map<string, map<int,uint64_t> > funcQbits; //qbits in current function
+    map<Function*, map<unsigned int, map<int,uint64_t> > > tableFuncQbits;
+    map<string, unsigned int> funcArgs;
+
+    vector<op> readyQueue; //ready queue for use with LPFS scheduling
+    vector<pair<Instruction*, op> > funcList; //list of the operations of a function
+
+    
+    vector<ArrParGates> currArrParGates;
+
+    map<Instruction*, qGate> mapInstSet;
+    vector<InstPri> priorityVector;
+
+    map<Instruction*, op> mapCalls; //map of between the instruction label and the operation attributes of each inst
+    vector<Instruction*> longPath;      //longest path to be returned by find_lp
+    vector<Instruction*> callList;  
+    map<int, multimap<int, op> > schedule; //all the instructions in a given simd region
+    int ots; //operating time steps
+    int simds;
+    int tgates_cnt; //tgates
+    multimap<int, move> move_schedule; //all the instructions in a given simd region
+    multimap<int, move> local_move_schedule; //all the instructions in a given simd region
+    int mts; //move time steps
+    map<int, vector<Instruction*> > longestPathList; //all the instructions in a given simd region
+
+    vector<qArgInfo> active_qubits;
+    map<string, qArgInfo> qubitMap;
+    map<int, int> localMemSizeMap;
+    map<int, int> regionSizeMap;
+
+    map<Function*, modularInfo> funcInfo;
+    vector<Function*> isLeaf;
+    bool hasPrimitivesOnly;
+
+    bool isFirstMeas;
+
+    GenLPFSSched() : ModulePass(ID) {}
+    
+    // Get arguments from operation
+    bool backtraceOperand(Value* opd, int opOrIndex);
+    bool analyzeIntrinsicCallInst(Function* F, Instruction* pinst);
+    // 
+    void analyzeAllocInst(Function* F,Instruction* pinst);
+    void analyzeCallInst(Function* F,Instruction* pinst);
+    void getFunctionArguments(Function *F);
+    
+    void saveTableFuncQbits(Function* F);
+    void print_tableFuncQbits();
+    void print_parallelism(Function* F);
+    void print_ArrParGates();
+    void cleanupCurrArrParGates();
+    bool checkIfIntrinsic(Function* CF);
+
+    void find_lp(Function* F, int pathNum);
+    void lpfs(Function* F, int ts, int simd_l, int refill, int opp_simd);
+    void take_path(Instruction* CI, int path);
+    void sched_op(Instruction* currentOp, int timeStep, int simd);
+    bool depsMet(Instruction* currentOp, int currentTime);
+    void update_moves(int moves, int ts );
+
+        
+
+    void print_ready_queue(); 
+    void print_funcList(); 
+    void print_vectQbit(); 
+    void print_mapCalls();
+    void print_mapCallsEdges();
+    void print_priorityVector();
+    void print_longPath();
+    void print_schedule(Function* F, int op_count);
+    void print_moves_schedule(Function* F, int op_count);
+    void print_local_moves_schedule(Function* F, int op_count);
+    void print_schedule_metrics(Function* F, int op_count);
+
+    void init_gate_names(){
+        gate_name[_CNOT] = "CNOT";
+        gate_name[_H] = "H";
+        gate_name[_S] = "S";
+        gate_name[_T] = "T";
+        gate_name[_Toffoli] = "Toffoli";
+        gate_name[_X] = "X";
+        gate_name[_Y] = "Y";
+        gate_name[_Z] = "Z";
+        gate_name[_MeasX] = "MeasX";
+        gate_name[_MeasZ] = "MeasZ";
+        gate_name[_PrepX] = "PrepX";
+        gate_name[_PrepZ] = "PrepZ";
+        gate_name[_Sdag] = "Sdag";
+        gate_name[_Tdag] = "Tdag";
+        gate_name[_Fredkin] = "Fredkin";
+        gate_name[_Rz] = "Rz";
+        gate_name[_All] = "All";                    
+        
+        gate_index["CNOT"] = _CNOT;        
+        gate_index["H"] = _H;
+        gate_index["S"] = _S;
+        gate_index["T"] = _T;
+        gate_index["Toffoli"] = _Toffoli;
+        gate_index["X"] = _X;
+        gate_index["Y"] = _Y;
+        gate_index["Z"] = _Z;
+        gate_index["Sdag"] = _Sdag;
+        gate_index["Tdag"] = _Tdag;
+        gate_index["MeasX"] = _MeasX;
+        gate_index["MeasZ"] = _MeasZ;
+        gate_index["PrepX"] = _PrepX;
+        gate_index["PrepZ"] = _PrepZ;
+        gate_index["Fredkin"] = _Fredkin;
+        gate_index["Rz"] = _Rz;
+        gate_index["All"] = _All;                    
+        }
+
+        
+
+    void init_gates_as_functions();    
+    void init_critical_path_algo(Function* F);
+    void calc_critical_time(Function* F, qGate qg, bool isLeafFunc);        
+    void print_funcQbits();
+    void print_qgate(qGate qg);
+    void print_critical_info(); 
+
+    void print_scheduled_gate(qGate qg, uint64_t ts);
+
+    uint64_t find_max_funcQbits();
+    void memset_funcQbits(uint64_t val);
+    uint64_t get_ts_to_schedule(Function* F, uint64_t ts, Function* funcToSched, uint64_t& first_step);
+    uint64_t get_ts_to_schedule_leaf(Function* F, uint64_t ts, Function* funcToSched, uint64_t& first_step);
+
+    void save_blackbox_info(Function* F);
+    uint64_t calc_critical_time_unbounded(Function* F, qGate qg);        
+
+    void print_qgateArg(qGateArg qg)
+    {
+      errs()<< "Printing QGate Argument:\n";
+      if(qg.argPtr) errs() << "  Name: "<<qg.argPtr->getName()<<"\n";
+      errs() << "  Arg Num: "<<qg.argNum<<"\n"
+             << "  isUndef: "<<qg.isUndef
+             << "  isQbit: "<<qg.isQbit
+             << "  isCbit: "<<qg.isCbit
+             << "  isPtr: "<<qg.isPtr << "\n"
+             << "  Value or Index: "<<qg.valOrIndex<<"\n";
+    }                    
+    
+    uint64_t getNumCritSteps(Function* F){
+      map<Function*, modularInfo>::iterator mf = funcInfo.find(F);
+      assert(mf!=funcInfo.end());
+      return (mf->second.length);
+    }
+
+    bool DetermineLeafFunction (Function *F);
+
+    void CountCriticalFunctionResources (Function *F);
+    
+    bool runOnModule (Module &M);    
+    
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();  
+      AU.addRequired<CallGraph>();
+    }
+    
+  }; // End of struct GenLPFSSched
+} // End of anonymous namespace
+
+
+
+char GenLPFSSched::ID = 0;
+static RegisterPass<GenLPFSSched> X("GenLPFSSchedule", "Generate LPFS Schedule");
+
+//LPFS: Longest Path First Scheduling
+
+vector<Instruction*> longestPathList;
+
+void GenLPFSSched::lpfs(Function* F, int ts, int simd_l, int refill_simd, int opp_simd){
+  //----------------Build Dependency Tree--------------------//
+    int op_count = priorityVector.size();
+    int sched_ops = 0;
+    int moves = 0;
+    int id_to_apply = 0;
+    int qbit_id = 0;
+
+    //Building Dependency Graph
+    
+	for(vector<Instruction*>::iterator fp1 = callList.begin(); fp1 != callList.end(); ++fp1){      //All function instructs
+        bool found_one = false;
+        map<Instruction*, op>::iterator mp1 = mapCalls.find(*fp1);
+//        errs() << "checking op " << (*mp1).second.name.qFunc->getName() << "\n";
+        (*mp1).second.id = id_to_apply++;
+        for(int i=0; i < (*mp1).second.name.numArgs; ++i){                                              //All function args
+            vector<Instruction*>::iterator fp2 = fp1;
+            if((*mp1).second.name.args[i].id == -1) {
+                (*mp1).second.name.args[i].id = qbit_id++;
+                qArgInfo arg = (*mp1).second.name.args[i];
+                stringstream ss;
+                ss << arg.index;
+                string name = arg.name + ss.str();
+                qubitMap.insert(make_pair(name, arg));
+            }
+            if(fp1 != callList.end()) ++fp2;
+            while(fp2 != callList.end()){                                                               //All later instructs
+                map<Instruction*, op>::iterator mp2 = mapCalls.find(*fp2);
+                found_one = false;
+//                errs() << "Checking dependency between: " << (*mp1).first << " and " << (*mp2).first << "\n";
+            	for(int j = 0; j < (*mp2).second.name.numArgs; ++j){                                    //All those inst args
+                    if((*mp1).second.name.args[i].id == -1) {
+                        (*mp1).second.name.args[i].id = qbit_id++;
+                        qArgInfo arg = (*mp1).second.name.args[i];
+                        stringstream ss;
+                        ss << arg.index;
+                        string name = arg.name + ss.str();
+                        qubitMap.insert(make_pair(name, arg));
+                    }
+                	if((*mp1).second.name.args[i] == (*mp2).second.name.args[j]){
+//                        errs() << "Checking args between: " << (*mp1).second.name.args[i].name << (*mp1).second.name.args[i].index << " and " << (*mp2).second.name.args[j].name << (*mp2).second.name.args[j].index << "\n";
+//                           errs() << "\t Found Dependency between " << (*mp1).first << " and " << (*mp2).first << "\n";
+                        	(*mp1).second.out_edges.push_back((*mp2).first);
+                       		(*mp2).second.in_edges.push_back((*mp1).first);
+							found_one = true;
+               		}
+                }
+                if(found_one){ 
+//                    errs() << "found dep " << "\n";
+                    break;
+                }
+                ++fp2; 
+            }
+		}
+	}
+
+//   errs() << "Finished Building Dependency Graph" << "\n";
+
+    //-----Find the longest paths required for the simd_l constraint-----//
+    longestPathList.clear();
+    for(int i = 1; i <= simd_l; i++){
+        find_lp(F,i);
+        longestPathList[i] = longPath;
+        longPath.clear();
+//        errs() << "found long path" << "\n";
+    } 
+
+//    errs() << "Finished Finding Longest Path(s)" << "\n";    
+
+    //-------Assign the longest paths-------//
+        for(map<int, vector<Instruction*> >::iterator pathNumber = longestPathList.begin(); pathNumber != longestPathList.end(); pathNumber++){
+            for(vector<Instruction*>::reverse_iterator inst = (*pathNumber).second.rbegin(); inst != (*pathNumber).second.rend(); inst++){
+                Instruction* myInst = (*inst);
+                if(((*mapCalls.find(myInst)).second.simd) == -1)
+                    sched_op(myInst, ts++, (*pathNumber).first);
+                    sched_ops++;
+            }   
+        }
+        ts = 0;
+//        errs() << "sched op = " << sched_ops << " op count = " << op_count << "\n";
+        while(sched_ops < op_count){ 
+//            errs() << "sched op = " << sched_ops << " op count = " << op_count << "\n";
+            for(vector<InstPri>::reverse_iterator vit = priorityVector.rbegin(); vit!=priorityVector.rend(); ++vit){
+                Instruction* myInst = (*vit).first;
+                op myOp = (*mapCalls.find(myInst)).second;
+//                errs() << "scheduling op " << myOp.name.qFunc->getName() << "\n";
+//                errs() << "myOp has args: " << myOp.name.numArgs << "\n";
+                bool scheduled = false;
+//                errs() << "ts = " << ts << " Checking op: " << myOp.id << " ";
+//                print_qgate(myOp.name);
+                while((*mapCalls.find(myInst)).second.simd == -1){
+                    int simdToSched = 1;
+                    if(depsMet(myInst, ts)){
+                        if(opp_simd == 1){
+                            while(simdToSched <= (int) RES_CONSTRAINT){   
+                                map<int, multimap<int, op> >::iterator it = schedule.find(simdToSched);
+                                if(!(it == schedule.end())){
+                                    multimap<int, op> map = (*it).second;
+                                    multimap<int, op>::iterator mit = map.find(ts);
+                                    if(mit != map.end()){
+                                        op curOp = (*mit).second;
+/*------Add Data Constraint---*/        if(myOp.name.qFunc == curOp.name.qFunc){//&& regionSizeMap[simdToSched] < (int) DATA_CONSTRAINT){
+                                            sched_op(myInst, ts, simdToSched);
+                                            scheduled = true;
+                                            sched_ops++;
+                                            break;
+                                        }
+                                    }
+                                }
+                                simdToSched++;
+                            }
+                           if(!scheduled){
+                                int lowTS = std::numeric_limits<int>::max();
+                                int lowSD = 0;
+                                for(simdToSched = (int) RES_CONSTRAINT; simdToSched > 0; simdToSched--){
+                                    int tempTS = ts;
+                                    while(schedule[simdToSched].count(tempTS)) {
+                                        tempTS++;
+                                    }
+
+                                    if(tempTS <= lowTS){
+                                        lowTS = tempTS;
+                                        lowSD = simdToSched;
+                                    }
+                                }
+                                sched_op(myInst, lowTS, lowSD);
+                                scheduled = true;
+                                sched_ops++;  
+                            }
+                        }
+                        else{
+                            while(!schedule[simdToSched].count(ts)) ts++;
+                            sched_op(myInst, ts, simdToSched);
+                            scheduled = true;
+                            sched_ops++;
+                            break;
+                        }
+                    }
+                    ts++;
+                }
+
+                ts = 0;
+            }
+        }
+        while(schedule[1].count(ts)){
+            update_moves(moves, ts++);   
+        }
+        ots = ts;
+    
+}
+
+void GenLPFSSched::update_moves(int moves, int ts ){
+
+    vector<qArgInfo> current;
+    vector<qArgInfo> next; 
+    map<int, int> simd_active;
+    bool added_move = false;
+
+       //----Get Current Qubits-----//
+    for(int simd = 1; simd <= (int) RES_CONSTRAINT; simd++){
+
+        map<int, multimap<int, op> >::iterator it = schedule.find(simd);
+        simd_active[simd] = 0;
+        if(it != schedule.end()){
+            multimap<int, op>::iterator mit = schedule[simd].find(ts);
+            if(mit != (*it).second.end()) {
+                simd_active[simd] = 1;
+                simds = max(simds, simd); 
+            }
+            while(mit != (*it).second.end() && (*mit).first == ts){
+                op myOp = (*mit).second;
+                for(int i = 0; i < myOp.name.numArgs; i++){
+                    stringstream ss;
+                    ss << myOp.name.args[i].index;
+                    string name = myOp.name.args[i].name + ss.str();
+                    qArgInfo arg = (*qubitMap.find(name)).second; 
+                    arg.simd = myOp.simd;
+                    arg.last_inst = myOp.label;
+                    vector<qArgInfo>::iterator vit = current.begin();
+                    while(vit != current.end()) { 
+                        if((*vit) == arg){
+                            break;
+                        }
+                        vit++;
+                    }
+                    if(vit == current.end()) {
+                        current.push_back(arg);
+                        (*qubitMap.find(name)).second.simd = arg.simd;
+                        (*qubitMap.find(name)).second.last_inst = arg.last_inst;
+                    }
+                }  
+                mit++;
+            }
+        }
+    }
+
+//    errs() << "# AT TIMESTEP: " << ts << "\n";
+    for(vector<qArgInfo>::iterator mapit = active_qubits.begin(); mapit != active_qubits.end(); mapit++){
+//        errs() << "Currently examining: " << (*mapit).name << (*mapit).index << "\n";
+        stringstream ss;
+        ss << (*mapit).index;
+        string name = (*mapit).name + ss.str();
+        qArgInfo thisQbit = (*qubitMap.find(name)).second;
+        int src = thisQbit.loc;         
+        int dest = 0; 
+        vector<qArgInfo>::iterator qit = current.begin();
+        while(qit != current.end()){
+            stringstream ss;
+            ss << (*qit).index;
+            string name2 = (*qit).name + ss.str();
+            qArgInfo currQbit = (*qubitMap.find(name)).second;
+            if((name == name2)&& (thisQbit.loc % 10 != 0)){       //If qubit is in current and active and not in memory
+                dest = (*qit).simd;
+                (*qubitMap.find(name)).second.simd = dest;
+                next.push_back((*qubitMap.find(name)).second);
+                current.erase(qit);
+                break;
+            }
+            qit++;
+        }
+    
+        if(!(simd_active[src] ) && !(dest) ){ //Qbit doesn't need to move
+            next.push_back((*qubitMap.find(name)).second);
+        }
+        else if(!LOCAL_MEM){
+            if(((dest) && (dest != src)) || ((dest == 0) && (simd_active[src]))){
+                 //Moved into new location
+
+                move newMove;
+                newMove.src = src;
+                newMove.dest = dest;
+                newMove.arg = (*qubitMap.find(name)).second;
+                move_schedule.insert(make_pair(ts,newMove));
+                (*qubitMap.find(name)).second.loc = dest;
+//                regionSizeMap[src]--;
+//                regionSizeMap[dest]++;
+                added_move = true;
+            }
+        }
+        else if(LOCAL_MEM){
+            if((dest) && (dest != src)){
+                move newMove;
+                newMove.src = src;
+                newMove.dest = dest;
+                newMove.arg = (*qubitMap.find(name)).second;
+                move_schedule.insert(make_pair(ts,newMove));
+//                regionSizeMap[src]--;
+//                regionSizeMap[dest]++;
+                (*qubitMap.find(name)).second.loc = dest; 
+                added_move = true;
+            }
+            if(!(dest) && (simd_active[src])){
+                int lowNextTS = std::numeric_limits<int>::max();
+                int nextOpLoc = -1;
+                op myOp = (*mapCalls.find(thisQbit.last_inst)).second;
+                if(!myOp.out_edges.empty()){
+                    for(int i = 0; i < (int) myOp.out_edges.size(); i++){
+                        op nextOp = (*mapCalls.find(myOp.out_edges[i])).second;
+                        for(int j = 0; j < nextOp.name.numArgs; j++){
+                            qArgInfo arg = nextOp.name.args[j];
+                            if(arg == thisQbit){
+                                lowNextTS = nextOp.ts;
+                                nextOpLoc = nextOp.simd;
+                            }
+                        }
+                    }
+                }
+                (*qubitMap.find(name)).second.nextTS = lowNextTS;
+                if((lowNextTS <= ts + (int) LOCAL_WINDOW) && (myOp.ts != ts) && (nextOpLoc == myOp.simd)  && ((*qubitMap.find(name)).second.loc % 10 != 0)){
+                    if( (src) && (localMemSizeMap[src*10] >= (int) LOCAL_Q)){
+                        int maxTS = 0;
+                        string maxName;
+                        qArgInfo victim;
+                        for(map<string,qArgInfo>::iterator mit = qubitMap.begin(); mit != qubitMap.end(); mit++){
+                            if((*mit).second.loc == src*10){
+                                if(maxTS <= (*mit).second.nextTS){
+                                    maxTS = (*mit).second.nextTS;
+                                    maxName = (*mit).first;
+                                    victim = (*mit).second;
+                                }
+                            }
+                        }
+                        move newTMove;
+                        newTMove.src = src*10;
+                        newTMove.dest = 0;
+                        newTMove.arg = victim;
+                        stringstream ss;
+                        ss << victim.index;
+                        maxName = victim.name + ss.str();
+                        (*qubitMap.find(maxName)).second.loc = 0;
+                        move_schedule.insert(make_pair(ts, newTMove));
+                        added_move = true;
+                        localMemSizeMap[src*10]--;
+                    }
+                    move newMove;
+                    newMove.src = src;
+                    newMove.dest = src * 10;
+                    newMove.arg = (*qubitMap.find(name)).second;
+                    (*qubitMap.find(name)).second.loc = newMove.dest;
+                    next.push_back((*qubitMap.find(name)).second);
+                    local_move_schedule.insert(make_pair(ts,newMove));
+//                    regionSizeMap[src]--;
+                    localMemSizeMap[newMove.dest]++;
+//                    errs() << "TS: " << ts << " Added local mem: " << name <<" : " << (*qubitMap.find(name)).second.loc << "\n";
+                }
+                else if(myOp.ts != ts) {
+                    move newMove;
+                    newMove.src = src;
+                    newMove.dest = dest;
+                    newMove.arg = (*qubitMap.find(name)).second;
+                    (*qubitMap.find(name)).second.loc = newMove.dest;
+                    move_schedule.insert(make_pair(ts,newMove));
+//                    regionSizeMap[src]--;
+                    added_move = true;
+                }
+            }
+        }
+    }
+ 
+   
+ /*  
+   errs() << "Current qubits after deletion: " << current.size() << "TIME: " << ts <<  "\n";
+    for(vector<qArgInfo>::iterator mit = current.begin(); mit != current.end(); mit++){
+        errs() << (*mit).name << (*mit).index << " DEST: " << (*mit).simd << " ID: " << (*mit).id <<  "\n";
+    }
+*/
+
+  
+    for(vector<qArgInfo>::iterator mapit = current.begin(); mapit != current.end(); mapit++){
+        stringstream ss;
+        ss << (*mapit).index;
+        string name = (*mapit).name + ss.str();
+        
+        qArgInfo curQbit = (*qubitMap.find(name)).second; 
+        int dest = curQbit.simd;    //Region where qubit is needed for operation at current timestep
+        next.push_back(curQbit);
+
+        if(curQbit.loc == 0 || !LOCAL_MEM){   //Memory location qubit is stored in
+            move newMove;
+            newMove.src = 0;
+            newMove.dest = dest;
+            newMove.arg = curQbit;
+            (*qubitMap.find(name)).second.loc = dest;
+            move_schedule.insert(make_pair(ts,newMove));
+            added_move = true;
+        }
+        else{
+            move newMove;
+            newMove.src = curQbit.loc;
+            newMove.dest = dest;
+            newMove.arg = curQbit;
+            (*qubitMap.find(name)).second.loc = dest;
+            local_move_schedule.insert(make_pair(ts,newMove));
+            localMemSizeMap[curQbit.loc]--;
+//            errs() << "TS: " << ts << " Grabbed from local: " << name << " : " << curQbit.loc << "\n";
+        }
+    }
+    active_qubits = next;
+
+
+
+}
+
+
+bool GenLPFSSched::depsMet(Instruction* currentOp, int currentTime){
+    op myOp = (*mapCalls.find(currentOp)).second;
+    bool answer = true;
+    if(!(myOp.in_edges.empty())){
+        for(vector<Instruction*>::iterator parent = myOp.in_edges.begin(); parent != myOp.in_edges.end(); parent++){
+            if(((*mapCalls.find(*parent))).second.simd == -1) answer = false;
+            if(((*mapCalls.find(*parent))).second.ts >= currentTime) answer = false;
+//            errs() << "Current timestep: " << currentTime << " Parent's timestep: " << ((*mapCalls.find(*parent))).second.ts << "\n"; 
+        }
+    }
+    return answer;
+}
+
+void GenLPFSSched::sched_op(Instruction* currentOp, int timeStep, int simd){
+//    errs() << "trying to schedule \n";
+    if((*mapCalls.find(currentOp)).second.simd == -1){
+        (*mapCalls.find(currentOp)).second.ts = timeStep;
+        (*mapCalls.find(currentOp)).second.simd = simd;
+        (*mapCalls.find(currentOp)).second.followed = 1;
+        (*mapCalls.find(currentOp)).second.label = currentOp;
+        schedule[simd].insert(make_pair(timeStep, ((*mapCalls.find(currentOp)).second)));
+        regionSizeMap[simd]++;
+        if(((*mapCalls.find(currentOp)).second.name.qFunc->getName() == "llvm.T")||((*mapCalls.find(currentOp)).second.name.qFunc->getName() == "llvm.Tdag" )) { 
+            tgates_cnt++;
+        }
+
+//        errs() << "scheduled! \n";
+//        errs() << "Added to path " << currentOp << " at timestep " << timeStep << " in region " << simd << " || " << (*mapCalls.find(currentOp)).second.simd << "\n";
+    }
+}
+
+//Helper Functions
+
+void GenLPFSSched::find_lp(Function* F, int pathNum){
+  //----------------Find Longest Path----------------------------//
+    longPath.push_back(*callList.begin());
+
+	for(map<Instruction*, op>::iterator mp1 = mapCalls.begin(); mp1 != (--mapCalls.end()); ++mp1){
+        if(!(*mp1).second.followed) (*mp1).second.dist = 1;
+    }
+//	for(map<Instruction*, op>::iterator mp1 = mapCalls.begin(); mp1 != (--mapCalls.end()); ++mp1){
+	for(vector<Instruction*>::iterator fp1 = callList.begin(); fp1 != (--callList.end()); ++fp1){
+        map<Instruction*, op>:: iterator mp1 = mapCalls.find(*fp1);
+        if((*mp1).second.followed){
+            (*mp1).second.dist = 0;
+        }
+        else{ 
+            op thisOp = (*mp1).second;
+
+            if(!(thisOp.out_edges.empty())){
+                for(vector<Instruction*>::iterator child = thisOp.out_edges.begin(); child != thisOp.out_edges.end(); child++){
+                    op childOp = (*mapCalls.find(*child)).second;
+                    childOp.dist = max(childOp.dist, thisOp.dist + 1);
+                    mapCalls[*child] = childOp; 
+                }
+            }
+            if((!thisOp.followed) && (!(longPath.empty()))){
+                if(thisOp.dist >= (*mapCalls.find(longPath[0])).second.dist){
+                    longPath[0] = (*mp1).first;
+                }
+            }
+        }
+//        errs() << "INST: " << (*mp1).first << " Dist: " << (*mp1).second.dist << "\n";
+    }
+
+   if(!(longPath.empty())){ 
+//        for(int i = 0; i < (int)longPath.size(); i++){ 
+        while((*mapCalls.find(longPath[longPath.size() - 1])).second.dist > 1){ 
+            op botOp = (*mapCalls.find(longPath[longPath.size()-1])).second;
+            int currDist = botOp.dist - 1;
+            take_path(longPath[longPath.size() - 1], pathNum); 
+            for(vector<Instruction*>::iterator parent = botOp.in_edges.begin(); parent != botOp.in_edges.end(); ++parent){
+                if(((*mapCalls.find(*parent)).second.dist == currDist) && (!(*mapCalls.find(*parent)).second.followed)){
+                    longPath.push_back(*parent); //next operation is appended to the path, so path vector is in reverse
+                    break;
+                } 
+            }
+        }
+    }
+}                         
+		   
+void GenLPFSSched::take_path(Instruction* CI, int path){
+    op currentOp = (*mapCalls.find(CI)).second;
+//    print_qgate(currentOp.name);
+    currentOp.dist = 0;
+    currentOp.path = path;
+//    currentOp.simd = path;
+    currentOp.followed = 1;
+    mapCalls[CI] = currentOp; 
+}
+
+
+void GenLPFSSched::getFunctionArguments(Function* F)
+{
+  for(Function::arg_iterator ait=F->arg_begin();ait!=F->arg_end();++ait)
+    {    
+      //if(ait) errs() << "Argument: "<<ait->getName()<< " ";
+
+      string argName = (ait->getName()).str();
+      Type* argType = ait->getType();
+      unsigned int argNum=ait->getArgNo();         
+
+      qGateArg tmpQArg;
+      tmpQArg.argPtr = ait;
+      tmpQArg.argNum = argNum;
+
+      if(argType->isPointerTy()){
+        tmpQArg.isPtr = true;
+
+        Type *elementType = argType->getPointerElementType();
+        if (elementType->isIntegerTy(16)){ //qbit*
+          tmpQArg.isQbit = true;
+          vectQbit.push_back(ait);
+          
+          map<int,uint64_t> tmpMap;
+          tmpMap[-1] = 0; //add entry for entire array
+          tmpMap[-2] = 0; //add entry for max     
+          funcQbits[argName]=tmpMap;      
+          funcArgs[argName] = argNum;
+        }
+        else if (elementType->isIntegerTy(1)){ //cbit*
+          tmpQArg.isCbit = true;
+          vectQbit.push_back(ait);
+          funcArgs[argName] = argNum;
+        }
+      }
+      else if (argType->isIntegerTy(16)){ //qbit
+        tmpQArg.isQbit = true;
+        vectQbit.push_back(ait);
+
+          map<int,uint64_t> tmpMap;
+          tmpMap[-1] = 0; //add entry for entire array
+          tmpMap[-2] = 0; //add entry for max
+          funcQbits[argName]=tmpMap;
+          funcArgs[argName] = argNum;
+      }
+      else if (argType->isIntegerTy(1)){ //cbit
+        tmpQArg.isCbit = true;
+        vectQbit.push_back(ait);
+          funcArgs[argName] = argNum;
+      }
+      
+    }
+}
+
+bool GenLPFSSched::backtraceOperand(Value* opd, int opOrIndex)
+{
+  if(opOrIndex == 0) //backtrace for operand
+    {
+      //search for opd in qbit/cbit vector
+      vector<Value*>::iterator vIter=find(vectQbit.begin(),vectQbit.end(),opd);
+      if(vIter != vectQbit.end()){
+        tmpDepQbit[0].argPtr = opd;
+        
+        return true;
+      }
+      
+      if(btCount>MAX_BT_COUNT)
+        return false;
+      
+      if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(opd))
+        {
+
+          if(GEPI->hasAllConstantIndices()){
+            Instruction* pInst = dyn_cast<Instruction>(opd);
+            unsigned numOps = pInst->getNumOperands();
+
+            backtraceOperand(pInst->getOperand(0),0);
+            
+            //NOTE: getelemptr instruction can have multiple indices. Currently considering last operand as desired index for qubit. Check this reasoning. 
+            if(ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(numOps-1))){
+              if(tmpDepQbit.size()==1){
+                tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+              }
+            }
+          }
+          
+          else if(GEPI->hasIndices()){
+            
+            Instruction* pInst = dyn_cast<Instruction>(opd);
+            unsigned numOps = pInst->getNumOperands();
+            backtraceOperand(pInst->getOperand(0),0);
+
+            if(tmpDepQbit[0].isQbit && !(tmpDepQbit[0].isPtr)){     
+              //NOTE: getelemptr instruction can have multiple indices. consider last operand as desired index for qubit. Check if this is true for all.
+              backtraceOperand(pInst->getOperand(numOps-1),1);
+              
+            }
+          }
+          else{     
+            Instruction* pInst = dyn_cast<Instruction>(opd);
+            unsigned numOps = pInst->getNumOperands();
+            for(unsigned iop=0;iop<numOps;iop++){
+              backtraceOperand(pInst->getOperand(iop),0);
+            }
+          }
+          return true;
+        }
+      
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+        unsigned numOps = pInst->getNumOperands();
+        for(unsigned iop=0;iop<numOps;iop++){
+          btCount++;
+          backtraceOperand(pInst->getOperand(iop),0);
+          btCount--;
+        }
+        return true;
+      }
+      else{
+        return true;
+      }
+    }
+  else if(opOrIndex == 0){ //opOrIndex == 1; i.e. Backtracing for Index    
+    if(btCount>MAX_BT_COUNT) //prevent infinite backtracing
+      return true;
+
+    if(ConstantInt *CI = dyn_cast<ConstantInt>(opd)){
+      tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+      return true;
+    }      
+
+    if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+      unsigned numOps = pInst->getNumOperands();
+      for(unsigned iop=0;iop<numOps;iop++){
+        btCount++;
+        backtraceOperand(pInst->getOperand(iop),1);
+        btCount--;
+      }
+    }
+
+  }
+  else{ //opOrIndex == 2: backtracing to call inst MeasZ
+    if(CallInst *endCI = dyn_cast<CallInst>(opd)){
+      if(endCI->getCalledFunction()->getName().find("llvm.Meas") != string::npos){
+        tmpDepQbit[0].argPtr = opd;
+
+        return true;
+      }
+      else{
+        if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+          unsigned numOps = pInst->getNumOperands();
+          bool foundOne=false;
+          for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+            btCount++;
+            foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+            btCount--;
+          }
+          return foundOne;
+        }
+      }
+    }
+    else{
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+        unsigned numOps = pInst->getNumOperands();
+        bool foundOne=false;
+        for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+          btCount++;
+          foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+          btCount--;
+        }
+        return foundOne;
+      }
+    }
+  }
+  return false;
+}
+
+
+void GenLPFSSched::analyzeAllocInst(Function* F, Instruction* pInst){
+  if (AllocaInst *AI = dyn_cast<AllocaInst>(pInst)) {
+    Type *allocatedType = AI->getAllocatedType();
+    
+    if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+      qGateArg tmpQArg;
+      Type *elementType = arrayType->getElementType();
+      uint64_t arraySize = arrayType->getNumElements();
+      if (elementType->isIntegerTy(16)){
+        vectQbit.push_back(AI);
+        tmpQArg.isQbit = true;
+        tmpQArg.argPtr = AI;
+        tmpQArg.valOrIndex = arraySize;
+
+        map<int,uint64_t> tmpMap; //add qbit to funcQbits
+        tmpMap[-1] = 0; //entry for entire array ops
+        tmpMap[-2] = 0; //entry for max
+        funcQbits[AI->getName()]=tmpMap;
+      }
+      if (elementType->isIntegerTy(1)){
+        vectQbit.push_back(AI); //Cbit added here
+        tmpQArg.isCbit = true;
+        tmpQArg.argPtr = AI;
+        tmpQArg.valOrIndex = arraySize;
+      }
+    }
+  }
+}
+
+
+void GenLPFSSched::init_critical_path_algo(Function* F){
+
+  currSched.width = 0;
+  currSched.length = 0;
+  currSched.tgates = 0;
+  currSched.tgates_ub = 0;
+  currSched.tgates_par = 0;
+  currSched.tgates_par_ub = 0;
+
+  totalSched.width = 0;
+  totalSched.length = 0;
+  totalSched.tgates = 0;
+  totalSched.tgates_ub = 0;
+  totalSched.tgates_par = 0;
+  totalSched.tgates_par_ub = 0;
+
+  isFirstMeas = true;
+
+  hasPrimitivesOnly = true;
+}
+
+void GenLPFSSched::print_funcQbits(){
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbits.begin(); mIter!=funcQbits.end(); ++mIter){
+    errs() << "Var "<< (*mIter).first << " ---> ";
+    for(map<int,uint64_t>::iterator indexIter  = (*mIter).second.begin(); indexIter!=(*mIter).second.end(); ++indexIter){
+      errs() << (*indexIter).first << ":"<<(*indexIter).second<< "  ";
+    }
+    errs() << "\n";
+  }
+}
+
+void GenLPFSSched::print_ArrParGates(){
+  errs() << "Printing ArrParGate Vector \n";
+    int j = 0;
+    for(vector<ArrParGates>::iterator vit = currArrParGates.begin(); vit!=currArrParGates.end(); ++vit, j++){
+      errs() << j << " -- ";
+      for(unsigned int i=0;i<RES_CONSTRAINT;i++)
+        errs() << (*vit).typeOfGate[i] << " : " << (*vit).numGates[i] << " ; ";
+      errs() << "\n";
+    }
+  
+}
+
+void GenLPFSSched::print_qgate(qGate qg){
+  errs() << qg.qFunc->getName() << " : ";
+  for(int i=0;i<qg.numArgs;i++){
+    errs() << qg.args[i].name << qg.args[i].index << ", "  ;
+  }
+  errs() << "\n";
+}
+
+uint64_t GenLPFSSched::get_ts_to_schedule(Function* F, uint64_t ts, Function* funcToSched, uint64_t& first_step){
+  //F is non-leaf. Treat all incoming function as blackboxes
+
+  //errs() << "\n funcTOSched = " << funcToSched->getName() << "\n";
+
+  //print_funcQbits();
+  //print_ArrParGates();
+
+  uint64_t Win = 0;
+  uint64_t Lin = 0;
+  uint64_t Tin = 0;
+  uint64_t TinUB = 0;
+  uint64_t TinPar = 0;
+  uint64_t TinParUB = 0;
+
+  if(checkIfIntrinsic(funcToSched)){
+    Win = 1;
+    Lin = 1;
+
+    if(funcToSched->getIntrinsicID() == Intrinsic::T
+       || funcToSched->getIntrinsicID() == Intrinsic::Tdag){
+      //errs() << "Found T or Tdag \n";
+      Lin = 100; //cost of T gate
+      Tin = 1;
+      TinUB = 1;
+      TinPar = 1;
+      TinParUB = 1;
+    }
+    else{
+      Tin = 0;
+      TinUB = 0;
+      TinPar = 0;
+      TinParUB = 0;
+    }
+  }
+  
+  else{
+    map<Function*, modularInfo>::iterator fin = funcInfo.find(funcToSched);
+    assert(fin!=funcInfo.end() && "Func not found in funcInfo");
+        
+    Win = (*fin).second.width; //width for incoming func
+    Lin = (*fin).second.length; //length for incoming func 
+    Tin = (*fin).second.tgates; //tgates for incoming func  
+    TinUB = (*fin).second.tgates_ub; //tgates for incoming func  
+    TinPar = (*fin).second.tgates_par; //tgates for incoming func  
+    TinParUB = (*fin).second.tgates_par_ub;
+  }
+
+  //errs() << "Curr Width = " << currSched.width << " Curr Length = " << currSched.length << " CurrTgates = " << currSched.tgates << "\n";
+  //errs() << "Func Width = " << Win << " Func Length = " << Lin <<  " Func Tgates = " << Tin << "\n";
+  //errs() << "Total Width = " << currSched.width << " Total Length = " << totalSched.length << "TS = " << ts  << " TotalTgates = " << totalSched.tgates <<"\n";
+
+
+  if(ts < totalSched.length+currSched.length){ //might be able to parallelize  
+    if((Win + currSched.width) <= RES_CONSTRAINT) //Hooray, can be parallelized
+      {
+        //first_step = totalSched.length; //where the func got scheduled
+        first_step = max(ts,totalSched.length); //where the func got scheduled
+        currSched.width += Win;
+        //currSched.length = max(Lin, currSched.length);
+        currSched.length = max(first_step - totalSched.length + Lin, currSched.length);
+        currSched.tgates = max(Tin, currSched.tgates);
+        currSched.tgates_ub = min(TinUB+currSched.tgates_ub, currSched.length);
+        currSched.tgates_par = max(TinPar, currSched.tgates_par);
+        currSched.tgates_par_ub = min(TinParUB+currSched.tgates_par_ub, currSched.width);
+        //errs() << "Parallel. New Width = " << currSched.width << " New Length = " << currSched.length << " New Tgates = " << currSched.tgates << " Tpar= " << currSched.tgates_par << " TparUB=" << currSched.tgates_par_ub << "\n";
+         }
+    else // must be serialized due to SIMD-k constraint
+      {
+
+        first_step = totalSched.length+currSched.length; //where the func got scheduled
+
+        totalSched.width = max(totalSched.width,currSched.width);
+        totalSched.length += currSched.length;
+        totalSched.tgates += currSched.tgates;
+        totalSched.tgates_ub += currSched.tgates_ub;
+        totalSched.tgates_par = max(totalSched.tgates_par,currSched.tgates_par);
+        totalSched.tgates_par_ub = max(totalSched.tgates_par_ub,currSched.tgates_par_ub);
+        
+
+        currSched.length = Lin; //create new
+        currSched.width = Win; //create new W
+        currSched.tgates = Tin; //create new W
+        currSched.tgates_ub = TinUB; //create new W
+        currSched.tgates_par = TinPar; //create new W
+        currSched.tgates_par_ub = TinParUB; //create new W
+        //errs() << "Serial(SIMD-k). New Width = " << currSched.width << " New Length = " << currSched.length << " New Tgates= " << currSched.tgates<< " New TgatesUB= " << currSched.tgates_ub<< " New TgatesPar= " << currSched.tgates_par<< " TparUB=" << currSched.tgates_par_ub << "\n";
+      }
+  }
+
+  else //cannot parallelize due to data dependency
+    {
+      //first_step = currSched.length; //where the func got scheduled
+      first_step = totalSched.length+currSched.length; //where the func got scheduled
+      totalSched.width = max(totalSched.width,currSched.width);
+      totalSched.length += currSched.length;
+      totalSched.tgates += currSched.tgates;
+      totalSched.tgates_ub += currSched.tgates_ub;
+      totalSched.tgates_par = max(totalSched.tgates_par,currSched.tgates_par);
+      totalSched.tgates_par_ub = max(totalSched.tgates_par_ub,currSched.tgates_par_ub);
+
+      currSched.length = Lin; //create new L
+      currSched.width = Win; //create new W
+      currSched.tgates = Tin; //create new T
+      currSched.tgates_ub = TinUB; //create new W
+      currSched.tgates_par = TinPar; //create new W
+      currSched.tgates_par_ub = TinParUB; //create new W
+
+      //errs() << "Serial(Dependency). New Width = " << currSched.width << " New Length = " << currSched.length << " TotalW=" << totalSched.width << " TotalL=" << totalSched.length << " TotalT=" << totalSched.tgates << " TotalT_UB=" << totalSched.tgates_ub << " TotalTPar=" << totalSched.tgates_par << " TotalTParUB=" << totalSched.tgates_par_ub << "\n";
+    }
+
+  return (totalSched.length+currSched.length)-1; //where the last dependency should be recorded
+  //return (currSched.length)-1; //where the last dependency should be recorded
+}
+
+
+uint64_t GenLPFSSched::get_ts_to_schedule_leaf(Function* F, uint64_t ts, Function* funcToSched, uint64_t& first_step){
+
+  //errs() << " funcTOSched = " << funcToSched->getName() << "\n";
+  //errs() << " Size of currSched = " << currArrParGates.size() << "\n";
+
+  //F is leaf. Treat all incoming functions with respect  
+  int funcIndex = -1;
+
+  assert(funcToSched->getName().str().find("llvm.")!=string::npos &&  "Non-Intrinsic Func Found in Leaf Function"); 
+  
+  map<string, int>::iterator gidx = gate_index.find(funcToSched->getName().str().substr(5));
+  assert(gidx!=gate_index.end() && "No Gate Index Found for this Intrinsic Function");
+  funcIndex = (*gidx).second;
+
+  //schedule intrinsic function
+
+  uint64_t retVal = 0;
+  bool FirstEntrySched = false;
+
+  int costOfGate = 1;
+
+  /*if(funcIndex == _T || funcIndex == _Tdag)
+    costOfGate = 10;*/
+
+  for(int c = 0; c<costOfGate; c++){
+    bool foundEntry = false;
+  
+    int searchFuncIndex = funcIndex+c*20;
+  
+    for(uint64_t i = ts; (i<currArrParGates.size() && !foundEntry); i++){
+      for(unsigned int j = 0; (j<RES_CONSTRAINT && !foundEntry); j++){
+        //if((currArrParGates[i].typeOfGate[j] == searchFuncIndex) && (currArrParGates[i].numGates[j] < DATA_CONSTRAINT)){
+        if((currArrParGates[i].typeOfGate[j] == searchFuncIndex) && ((searchFuncIndex == _CNOT && 2*currArrParGates[i].numGates[j] < DATA_CONSTRAINT)
+                                || (searchFuncIndex != _CNOT && currArrParGates[i].numGates[j]< DATA_CONSTRAINT))){
+          currArrParGates[i].numGates[j] += 1;
+          if(!FirstEntrySched){
+            first_step = i;
+            FirstEntrySched = true;
+          }
+          
+          if((c==0) && (funcIndex == _T || funcIndex == _Tdag)){
+            if(currArrParGates[i].numGates[j] > currSched.tgates_par){
+              currSched.tgates_par = currArrParGates[i].numGates[j];
+              currSched.tgates_par_ub = currArrParGates[i].numGates[j];
+              //errs() << "Incr tgate_par \n";
+            }
+          }
+
+          //errs() << "GateType Parallelism. TS = " << i << " K-factor=" << j << " Tpar=" << currSched.tgates_par << " TparUB=" << currSched.tgates_par_ub <<"\n";
+          foundEntry = true;
+          retVal = i;
+          ts = i+1; //update value of ts to start with in next iteration
+          //return i;
+        }
+        else if(currArrParGates[i].typeOfGate[j] == -1){
+          currArrParGates[i].typeOfGate[j] = searchFuncIndex;
+          currArrParGates[i].numGates[j] = 1;
+          if(!FirstEntrySched){
+            first_step = i;
+            FirstEntrySched = true;
+          }
+          if(j >= currSched.width) //update currSched.width
+            currSched.width = j+1;
+          
+          //Add to T gate count if T or Tdag gate
+          if((c==0) && (funcIndex == _T || funcIndex == _Tdag)){
+            //errs() << "Found T or Tdag \n";
+            
+            bool prevTgateFound = false;
+            for(unsigned int jcheck=0; jcheck<RES_CONSTRAINT; jcheck++){
+              if(currArrParGates[i].typeOfGate[jcheck] == _T
+                 || currArrParGates[i].typeOfGate[jcheck] == _Tdag)
+                prevTgateFound = true;
+            }
+            if(!prevTgateFound){
+              currSched.tgates++;
+              currSched.tgates_ub++;
+              if(currSched.tgates_par == 0){
+                currSched.tgates_par = 1;
+                currSched.tgates_par_ub = 1;
+                }
+              //errs() << "--Incr tgate \n";
+            }
+          }
+          
+          //errs() << "Unscheduled. New Width = " << currSched.width << " New Length = " << currSched.length << " Tgates=" << currSched.tgates << " TgatesUB=" << currSched.tgates_ub << " TgatesPar=" << currSched.tgates_par << " TgatesParUB=" << currSched.tgates_par_ub <<" K-factor=" << j <<"\n";
+          foundEntry = true;
+          retVal = i;
+          ts = i+1;
+          //return i;
+        }
+      }
+    }
+  
+    if(!foundEntry){
+      //suitable ts not found, create a new ts for this type of gate
+      //add entry to vectArrParGates
+      
+      ArrParGates tmpArrPar; //initialize
+      for(unsigned int k=0;k<RES_CONSTRAINT; k++){
+        tmpArrPar.typeOfGate[k] = -1;
+        tmpArrPar.numGates[k] = 0;
+      }
+  
+      tmpArrPar.typeOfGate[0] = searchFuncIndex;
+      tmpArrPar.numGates[0] = 1;
+      currArrParGates.push_back(tmpArrPar);
+      if(!FirstEntrySched){
+        first_step = currArrParGates.size()-1;
+        FirstEntrySched = true;
+      }
+
+      if((c==0) && (funcIndex == _T || funcIndex == _Tdag)){
+        currSched.tgates++;
+        currSched.tgates_ub++;
+        //errs() << "Incr tgates \n";
+        if(currSched.tgates_par == 0){
+          currSched.tgates_par = 1;
+          currSched.tgates_par_ub = 1;
+          }
+      }
+      
+      if(currSched.width == 0) //update currSched.width
+        currSched.width = 1;
+      currSched.length++;
+      
+      //errs() << "NEW TS. New Width = " << currSched.width << " New Length = " << currSched.length << " T gates = " << currSched.tgates << " TgatesUB=" << currSched.tgates_ub << " TgatesPar=" << currSched.tgates_par << " TgatesParUB=" << currSched.tgates_par_ub<< "\n";
+      
+      retVal = currArrParGates.size()-1;
+      ts = currArrParGates.size();
+
+      //return currArrParGates.size()-1;
+    } 
+  } // cost Of Gate
+  
+  //print_ArrParGates();
+  return retVal;
+    
+}
+
+void GenLPFSSched::cleanupCurrArrParGates(){
+    currArrParGates.clear();    
+}
+
+/*bool GenLPFSSched::checkTgatePar(Function* F, uint64_t par){
+  //is function leaf?
+  vector<Function*>::iterator vit = find(isLeaf.begin(), isLeaf.end(), F);
+  if(vit==isLeaf.end()) //not a leaf
+    return true;
+  //is Leaf
+  //iterate over currArrParGates and check for 
+  }*/
+
+void GenLPFSSched::save_blackbox_info(Function* F){
+  //save black box info
+  modularInfo tmpMod;
+
+  tmpMod.width = max(totalSched.width,currSched.width);
+  tmpMod.length = totalSched.length + currSched.length;
+  tmpMod.tgates = totalSched.tgates + currSched.tgates;
+  tmpMod.tgates_ub = totalSched.tgates_ub + currSched.tgates_ub;
+
+  //check if leaf function
+  //if leaf go thru currArrParGates vector and find T parallelism
+
+  //if not leaf function
+  tmpMod.tgates_par = max(totalSched.tgates_par,currSched.tgates_par);
+  tmpMod.tgates_par_ub = max(totalSched.tgates_par_ub,currSched.tgates_par_ub);
+
+  //bool checkTgatePar = checkTgatePar(F,tmpMod.tgates_par);
+
+  funcInfo[F] = tmpMod;
+
+  bool funcIsLeaf = true;
+  vector<Function*>::iterator vit = find(isLeaf.begin(), isLeaf.end(), F);
+  if(vit==isLeaf.end()) //not a leaf
+    funcIsLeaf=false;
+  
+  //errs() << "SIMD k="<<RES_CONSTRAINT<<" d=" << DATA_CONSTRAINT << " " << F->getName() << " " << tmpMod.width << " " << tmpMod.length << " " <<tmpMod.tgates << " " << tmpMod.tgates_ub << " " << tmpMod.tgates_par<< " " << tmpMod.tgates_par_ub << " leaf=" << funcIsLeaf << "\n";
+
+}
+
+
+void GenLPFSSched::print_critical_info(){
+    errs() << "Timesteps = " << currArrParGates.size() << "\n";
+    for(unsigned int i = 0; i<currArrParGates.size(); i++){
+        errs() << i << " :";
+        for(unsigned int k=0;k<RES_CONSTRAINT;k++){      
+          errs() << currArrParGates[i].typeOfGate[k] << " : " << currArrParGates[i].numGates[k] << " / ";
+        }
+        errs() << "\n";
+    }
+}
+
+void GenLPFSSched::print_parallelism(Function* F){
+  uint64_t maxGates[NUM_QGATES];
+  for(int k = 0; k<NUM_QGATES; k++)
+    maxGates[k] = 0;
+
+  for(vector<ArrParGates>::iterator vit = currArrParGates.begin(); vit!=currArrParGates.end(); ++vit){
+    for(unsigned int i = 0; i<RES_CONSTRAINT; i++)
+      if((*vit).numGates[i] > maxGates[(*vit).typeOfGate[i]])
+        maxGates[(*vit).typeOfGate[i]] = (*vit).numGates[i];
+  }
+
+  errs() << "\nMax Parallelism Factors: \n";
+  for(int k = 0; k<NUM_QGATES-1; k++){ //do not print 'All'
+    errs() << gate_name[k] << " : " << maxGates[k] << "\n";
+  }  
+}
+
+uint64_t GenLPFSSched::find_max_funcQbits(){
+  uint64_t max_timesteps = 0;
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbits.begin(); mIter!=funcQbits.end(); ++mIter){
+    map<int,uint64_t>::iterator arrIter = (*mIter).second.find(-2); //max ts is in -2 entry
+    if((*arrIter).second > max_timesteps)
+      max_timesteps = (*arrIter).second;
+  }
+
+  //print_funcQbits();
+  //errs() << "Max timestep = " << max_timesteps << "\n";
+  return max_timesteps;
+
+}
+
+void GenLPFSSched::memset_funcQbits(uint64_t val){
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbits.begin(); mIter!=funcQbits.end(); ++mIter){
+    for(map<int,uint64_t>::iterator arrIter = (*mIter).second.begin(); arrIter!=(*mIter).second.end();++arrIter)
+      (*arrIter).second = val;
+  }
+}
+
+void GenLPFSSched::print_scheduled_gate(qGate qg, uint64_t ts){
+  string tmpGateName = qg.qFunc->getName();
+  if(tmpGateName.find("llvm.")!=string::npos)
+    tmpGateName = tmpGateName.substr(5);
+  errs() << ts << " " << tmpGateName;
+  for(int i = 0; i<qg.numArgs; i++){
+    errs() << " " << qg.args[i].name;
+    if(qg.args[i].index != -1)
+      errs() << qg.args[i].index;
+  }
+
+  /*
+  if(tmpGateName == "PrepX" || tmpGateName == "PrepZ"){
+    if(qg.angle > 0)
+      errs() << " 1";
+    else
+      errs() << " 0";
+  }
+  else if(tmpGateName == "Rz" || tmpGateName == "Ry" || tmpGateName == "Rx")
+    errs() << " "<<qg.angle;
+  */
+
+  errs() << "\n";
+}
+
+void GenLPFSSched::print_tableFuncQbits(){
+  for(map<Function*, map<unsigned int, map<int, uint64_t> > >::iterator m1 = tableFuncQbits.begin(); m1!=tableFuncQbits.end(); ++m1){
+    errs() << "Function " << (*m1).first->getName() << " \n  ";
+    for(map<unsigned int, map<int, uint64_t> >::iterator m2 = (*m1).second.begin(); m2!=(*m1).second.end(); ++m2){
+      errs() << "\tArg# "<< (*m2).first << " -- ";
+      for(map<int, uint64_t>::iterator m3 = (*m2).second.begin(); m3!=(*m2).second.end(); ++m3){
+        errs() << " ; " << (*m3).first << " : " << (*m3).second;
+      }
+      errs() << "\n";
+    }
+  }
+}
+
+/*
+void GenLPFSSched::print_ready_queue(){
+  for(vector<op>::iterator r1 = readyQueue.begin(); r1!=readyQueue.end(); ++r1){
+    errs() << "READY QUEUE ENTRY " << (*r1).name.qFunc->getName() << "\n";
+  }
+}
+*/
+void GenLPFSSched::print_funcList(){
+    if(!(funcList.empty())){
+        for(vector<pair<Instruction*, op > >::iterator f1 = funcList.begin(); f1 != funcList.end(); ++f1){
+            errs() << "\n #Function List Entry: " << (*f1).first; 
+            print_qgate((*f1).second.name); 
+        }      
+    }
+} 
+/*
+void GenLPFSSched::print_vectQbit(){
+  for(vector<Value*>::iterator vq1 = vectQbit.begin(); vq1!=vectQbit.end(); ++vq1){
+    errs() << "#Vector Qubit Entry: " << (*vq1) << "\n";
+  }
+}  
+*/
+void GenLPFSSched::print_mapCalls(){
+  for(map<Instruction*, op>::iterator mp = mapCalls.begin(); mp!=mapCalls.end(); ++mp){
+    errs() << "INSTRUCTION: " << (*mp).first << " timestep " << mapCalls[(*mp).first].ts << " Dist: " << mapCalls[(*mp).first].dist << " | Followed: " << mapCalls[(*mp).first].followed << " qGate: ";
+    print_qgate(mapCalls[(*mp).first].name);
+//    errs() << " Followed? " << (*mp).second.followed << "\n"; 
+  }
+}
+
+void GenLPFSSched::print_mapCallsEdges(){
+  for(map<Instruction*, op>::iterator mp = mapCalls.begin(); mp!=mapCalls.end(); ++mp){
+    errs() << "INST_LABEL: " << (*mp).first << "\n In_Edges: ";
+    for(int i = 0; i < (int)(*mp).second.in_edges.size(); ++i)
+        errs() <<  (*mp).second.in_edges[i] << " ";
+    errs() << "\n Out_Edges: ";
+    for(int i = 0; i < (int)(*mp).second.out_edges.size(); ++i)
+        errs() << (*mp).second.out_edges[i] << " ";
+	errs() << "\n";
+  }
+}
+
+
+
+void GenLPFSSched::print_priorityVector(){
+  for(vector<InstPri>::iterator pvit = priorityVector.begin(); pvit != priorityVector.end(); ++pvit) 
+//    errs() << "#PRIORITY VECTOR ENTRY: " << (*pvit).second << " " << (*pvit).second << "\n";
+    errs() << "#PRIORITY VECTOR ENTRY: " << (*mapCalls.find((*pvit).first)).second.name.qFunc->getName() << "\n";
+}
+
+void GenLPFSSched::print_longPath(){
+    errs() << "\n Longest Path: \n";
+    int i = 1;
+    for(vector<Instruction*>::reverse_iterator rlp = longPath.rbegin(); rlp != longPath.rend(); ++rlp){
+        errs() << i++ << " - " << (*mapCalls.find(*rlp)).second.id << " "; 
+        print_qgate((*mapCalls.find(*rlp)).second.name);
+
+    }
+}
+
+void GenLPFSSched::print_schedule(Function* F, int op_count){
+    int ts = 0;
+    while(ts < op_count){
+        multimap<int, move>::iterator moveOper = move_schedule.find(ts); 
+        multimap<int, move>::iterator bmoveOper = local_move_schedule.find(ts); 
+        while((moveOper != move_schedule.end()) && ((*moveOper).first == ts)){
+            errs() << (*moveOper).first << ",0 TMOV " << (*moveOper).second.dest << " " << (*moveOper).second.src << " " <<  (*moveOper).second.arg.name << (*moveOper).second.arg.index << "\n";
+            moveOper++;
+        }
+        while((bmoveOper != local_move_schedule.end()) && ((*bmoveOper).first == ts)){
+            errs() << (*bmoveOper).first << ",0 BMOV " << (*bmoveOper).second.dest << " " << (*bmoveOper).second.src << " " <<  (*bmoveOper).second.arg.name << (*bmoveOper).second.arg.index << "\n";
+            bmoveOper++;
+        }
+        for(map<int, multimap<int, op> >::iterator pit = schedule.begin(); pit != schedule.end(); pit++){
+            if(!(*pit).second.empty()){
+                multimap<int, op>::iterator oper = (*pit).second.find(ts);
+                while(oper != (*pit).second.end() && (*oper).first == ts){
+                    errs() << (*oper).first << "," << (*oper).second.simd << " ";
+                    string tmpName = (*oper).second.name.qFunc->getName();
+                    if( tmpName.find("llvm.") != string::npos) {
+                      unsigned firstDotPos = tmpName.find('.');
+                      unsigned secondDotPos = tmpName.find('.', firstDotPos+1);
+                      if (firstDotPos == secondDotPos)
+                        errs() << tmpName.substr(firstDotPos+1, string::npos);
+                      else
+                        errs() << tmpName.substr(firstDotPos+1, secondDotPos-firstDotPos-1);
+                    }
+                    else 
+                      errs() << tmpName;
+//                    errs() << "Args of this function: " << (*oper).second.name.numArgs << "\n";
+                    for(int i = 0; i<(*oper).second.name.numArgs; i++){
+                        errs() << " " << (*oper).second.name.args[i].name;
+                        if((*oper).second.name.args[i].index != -1) errs() << (*oper).second.name.args[i].index;
+                    }
+//                    errs() << " : Path = " << (*oper).second.path << " : ID = " << (*oper).second.id;
+                    errs() << "\n";
+                    oper++; 
+
+                }
+            }
+        }
+        ts++;
+    }
+}
+
+void GenLPFSSched::print_moves_schedule(Function* F, int op_count){
+    int ts = 0;
+    errs() << "MOVE LIST SIZE: " << move_schedule.size() << "\n";
+    for(multimap<int, move>::iterator mit = move_schedule.begin(); mit != move_schedule.end(); mit++){
+        while((*mit).first == ts){
+            errs() << (*mit).first << ",0 TMOV " << (*mit).second.dest << " " << (*mit).second.src << " " << (*mit).second.arg.name << (*mit).second.arg.index << "\n";
+            mit++;
+        }
+        ts++;
+    }
+}
+
+
+void GenLPFSSched::print_local_moves_schedule(Function* F, int op_count){
+    int ts = 0;
+    multimap<int, move>::iterator mit;
+    for(mit = local_move_schedule.begin(); mit != local_move_schedule.end(); mit++){
+        while((*mit).first == ts){
+            errs() << (*mit).first << ",0 BMOV " << (*mit).second.dest << " " << (*mit).second.src << " " << (*mit).second.arg.name << (*mit).second.arg.index << "\n";
+            mit++;
+        }
+        ts++;
+    }
+}
+
+void GenLPFSSched::print_schedule_metrics(Function* F, int op_count){
+    int moves_count = move_schedule.size();
+    int bmoves_count = local_move_schedule.size();
+    for(multimap<int, move>::iterator mit = move_schedule.begin(); mit != move_schedule.end(); mit = move_schedule.upper_bound(mit->first)){
+        mts++;
+    }
+
+    errs() << "ops = " << op_count << "\n";
+    errs() << "tmoves = " << moves_count << "\n";
+    errs() << "bmoves = " << bmoves_count << "\n";
+    errs() << "ots = " << ots << "\n";
+    errs() << "mts = " << mts << "\n";
+    errs() << "ts = " << (ots - mts) + (mts * 5) << "\n";
+    errs() << "SIMDs = " << simds << "\n";
+    errs() << "tgates = " << tgates_cnt << "\n";
+     
+}
+
+void GenLPFSSched::calc_critical_time(Function* F, qGate qg, bool isLeafFunc){
+  string fname = qg.qFunc->getName();
+
+  //print_qgate(qg);
+  uint64_t max_ts_of_all_args = 0;
+
+  uint64_t first_step = 0;
+
+  if(isFirstMeas && (fname == "llvm.MeasX" || fname == "llvm.MeasZ")){
+    uint64_t maxFQ = find_max_funcQbits();
+    uint64_t max_ts_sched; 
+
+    //errs() << "First Meas && Before Scheduled \n";
+    //print_funcQbits();
+
+    if(isLeafFunc)
+      max_ts_sched = get_ts_to_schedule_leaf(F,maxFQ, qg.qFunc, first_step);
+    else
+      max_ts_sched = get_ts_to_schedule(F,maxFQ, qg.qFunc, first_step);
+
+    memset_funcQbits(max_ts_sched);
+
+    //set this Meas in this max_ts_sched+1
+    map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[0].name);
+    assert(mIter != funcQbits.end() && "Meas Gate Var not found in funcQbits");
+
+    int argIndex = qg.args[0].index; //must have only one argument
+    assert(argIndex != -1 && "Meas gate has array argument");
+
+    //update the timestep number for that argument
+    map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+    (*indexIter).second =  max_ts_sched + 1;
+    
+    //update -2 entry for the array, i.e. max ts over all indices
+    indexIter = (*mIter).second.find(-2);
+    (*indexIter).second = max_ts_sched + 1;
+    
+    //errs() << "Scheduled in "<< max_ts_sched+1 << "\n";
+    //print_funcQbits();
+
+    isFirstMeas = false; 
+//    print_scheduled_gate(qg,max_ts_sched+1);
+    return;    
+  }
+  else{
+    //find last timestep for all arguments of qgate
+    for(int i=0;i<qg.numArgs; i++){
+      map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+      assert(mIter!=funcQbits.end()); //should already have an entry for the name of the qbit
+      
+      int argIndex = qg.args[i].index;
+      
+      //find the index of argument in the map<int,int>
+      if(argIndex == -1) //operation on entire array
+        {
+          //find max for the array        
+          map<int,uint64_t>::iterator indexIter = (*mIter).second.find(-2);
+          if((*indexIter).second > max_ts_of_all_args)
+            max_ts_of_all_args = (*indexIter).second;     
+        }
+      else
+        {
+          map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+          if(indexIter!=(*mIter).second.end()){
+            if((*indexIter).second > max_ts_of_all_args)
+              max_ts_of_all_args = (*indexIter).second;
+          }
+          else{
+            //find the value for entire array
+            map<int,uint64_t>::iterator fullArrayIndexIter = (*mIter).second.find(-1);  
+            ((*mIter).second)[argIndex] = (*fullArrayIndexIter).second;
+            //((*mIter).second)[argIndex] = 0;
+            if((*fullArrayIndexIter).second > max_ts_of_all_args)
+              max_ts_of_all_args = (*fullArrayIndexIter).second;
+          }
+        }
+    }
+    
+    if(debugGenLPFSSched){
+      errs() << "Before Scheduling: \n";
+      print_funcQbits();
+    }
+    
+    //errs() << "Max timestep for all args = " << max_ts_of_all_args << "\n";
+    
+    //find timestep from max_ts_of_all_args where type of gate is same as this gate or no gate has been scheduled.
+    uint64_t ts_sched;
+
+      if(isLeafFunc)
+        ts_sched = get_ts_to_schedule_leaf(F,max_ts_of_all_args, qg.qFunc, first_step);
+      else
+        ts_sched = get_ts_to_schedule(F,max_ts_of_all_args, qg.qFunc, first_step);
+
+      //errs() << "ts_sched = " << ts_sched << " FirstStep = " << first_step << "\n";
+      
+      //schedule gate in max_ts_of_all_args + 1th timestep = ts_sched+1
+      
+  
+//      print_scheduled_gate(qg,first_step+1);
+      
+
+      //if(currArrParGates.size() != 0){
+      
+      //update last timestep for all arguments of qgate
+      for(int i=0;i<qg.numArgs; i++){
+        map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+        
+        int argIndex = qg.args[i].index;
+        
+        if(argIndex == -1){
+          for(map<int,uint64_t>::iterator entryIter = (*mIter).second.begin(); entryIter!=(*mIter).second.end();++entryIter){
+            (*entryIter).second = ts_sched + 1;
+          }
+          
+        }
+        else{
+          //update the timestep number for that argument
+          map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+          (*indexIter).second =  ts_sched + 1;
+          
+          //update -2 entry for the array, i.e. max ts over all indices
+          indexIter = (*mIter).second.find(-2);
+          if((*indexIter).second < ts_sched + 1)
+            (*indexIter).second = ts_sched + 1;
+        }  
+      }
+      //}
+      } // not first MeasX gate
+  
+  if(debugGenLPFSSched){   
+    errs() << "\nAfter Scheduling: \n";
+    print_funcQbits();
+    print_critical_info();
+    errs() << "\n";
+  }
+  
+}
+
+uint64_t GenLPFSSched::calc_critical_time_unbounded(Function* F, qGate qg){
+  string fname = qg.qFunc->getName();
+
+  if(debugGenLPFSSched){   
+    print_qgate(qg);    
+    print_tableFuncQbits();
+  }
+
+  uint64_t max_ts_of_all_args = 0;
+  
+  //find last timestep for all arguments of qgate
+  for(int i=0;i<qg.numArgs; i++){
+    map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+    assert(mIter!=funcQbits.end()); //should already have an entry for the name of the qbit
+    
+    int argIndex = qg.args[i].index;
+    
+    //find the index of argument in the map<int,int>
+    if(argIndex == -1) //operation on entire array
+      {
+        //find max for the array          
+        map<int,uint64_t>::iterator indexIter = (*mIter).second.find(-2);
+        if((*indexIter).second > max_ts_of_all_args)
+          max_ts_of_all_args = (*indexIter).second;       
+      }
+    else
+      {
+        map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+        if(indexIter!=(*mIter).second.end()){
+          if((*indexIter).second > max_ts_of_all_args)
+            max_ts_of_all_args = (*indexIter).second;
+        }
+        else{
+          //find the value for entire array
+          map<int,uint64_t>::iterator fullArrayIndexIter = (*mIter).second.find(-1);      
+          ((*mIter).second)[argIndex] = (*fullArrayIndexIter).second;
+          if((*fullArrayIndexIter).second > max_ts_of_all_args)
+            max_ts_of_all_args = (*fullArrayIndexIter).second;
+        }
+      }
+    }
+    
+    if(debugGenLPFSSched){
+      errs() << "Before Scheduling: \n";
+      print_funcQbits();
+      }
+    
+    //errs() << "Max timestep for all args = " << max_ts_of_all_args << "\n";
+      
+      //schedule gate in max_ts_of_all_args + 1th timestep
+      //--print_scheduled_gate(qg,max_ts_of_all_args+1);
+      
+      //update last timestep for all arguments of qgate
+      for(int i=0;i<qg.numArgs; i++){
+        map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+        
+        int argIndex = qg.args[i].index;
+        
+        if(argIndex == -1){
+          for(map<int,uint64_t>::iterator entryIter = (*mIter).second.begin(); entryIter!=(*mIter).second.end();++entryIter){
+            (*entryIter).second = max_ts_of_all_args + 1;
+          }
+          
+        }
+        else{
+          //update the timestep number for that argument
+          map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+          (*indexIter).second =  max_ts_of_all_args + 1;
+          
+          //update -2 entry for the array, i.e. max ts over all indices
+          indexIter = (*mIter).second.find(-2);
+          if((*indexIter).second < max_ts_of_all_args + 1)
+            (*indexIter).second = max_ts_of_all_args + 1;
+        }  
+      }
+
+  
+  if(debugGenLPFSSched)
+  {   
+    errs() << "\nAfter Scheduling: \n";
+    print_funcQbits();
+    errs() << "\n";
+  }
+
+  return max_ts_of_all_args+1;
+  
+} //calc_critical_time_unbounded
+
+
+bool GenLPFSSched::checkIfIntrinsic(Function* CF){
+  if(CF->isIntrinsic()){
+    if((CF->getIntrinsicID() == Intrinsic::CNOT)
+       || (CF->getIntrinsicID() == Intrinsic::Fredkin)
+       || (CF->getIntrinsicID() == Intrinsic::H)
+       || (CF->getIntrinsicID() == Intrinsic::MeasX)
+       || (CF->getIntrinsicID() == Intrinsic::MeasZ)
+       || (CF->getIntrinsicID() == Intrinsic::PrepX)
+       || (CF->getIntrinsicID() == Intrinsic::PrepZ)
+       || (CF->getIntrinsicID() == Intrinsic::Rz)
+       || (CF->getIntrinsicID() == Intrinsic::S)
+       || (CF->getIntrinsicID() == Intrinsic::T)
+       || (CF->getIntrinsicID() == Intrinsic::Sdag)
+       || (CF->getIntrinsicID() == Intrinsic::Tdag)
+       || (CF->getIntrinsicID() == Intrinsic::Toffoli)
+       || (CF->getIntrinsicID() == Intrinsic::X)
+       || (CF->getIntrinsicID() == Intrinsic::Y)
+       || (CF->getIntrinsicID() == Intrinsic::Z)){
+      return true;
+    }
+  }
+  return false;
+}
+
+
+void GenLPFSSched::analyzeCallInst(Function* F, Instruction* pInst){
+  if(CallInst *CI = dyn_cast<CallInst>(pInst))
+    {      
+      if(debugGenLPFSSched)
+        errs() << "Call inst: " << CI->getCalledFunction()->getName() << "\n";
+
+      if(CI->getCalledFunction()->getName() == "store_cbit"){   //trace return values
+        return;
+      }      
+
+      vector<qGateArg> allDepQbit;                                  
+      
+      bool tracked_all_operands = true;
+
+      int myPrepState = -1;
+      double myRotationAngle = 0.0;
+      
+      for(unsigned iop=0;iop<CI->getNumArgOperands();iop++){
+        tmpDepQbit.clear();
+        
+        qGateArg tmpQGateArg;
+        btCount=0;
+        
+        tmpQGateArg.argNum = iop;
+        
+       
+        if(isa<UndefValue>(CI->getArgOperand(iop))){
+          errs() << "WARNING: LLVM IR code has UNDEF values. \n";
+          tmpQGateArg.isUndef = true;   
+          //exit(1);
+        }
+        
+//        errs() << "Checking Inst Types \n";
+        Type* argType = CI->getArgOperand(iop)->getType();
+        if(argType->isPointerTy()){
+          tmpQGateArg.isPtr = true;
+          Type *argElemType = argType->getPointerElementType();
+          if(argElemType->isIntegerTy(16))
+            tmpQGateArg.isQbit = true;
+          if(argElemType->isIntegerTy(1))
+            tmpQGateArg.isCbit = true;
+        }
+        else if(argType->isIntegerTy(16)){
+          tmpQGateArg.isQbit = true;
+          tmpQGateArg.valOrIndex = 0;    
+        }               
+        else if(argType->isIntegerTy(1)){
+          tmpQGateArg.isCbit = true;
+          tmpQGateArg.valOrIndex = 0;    
+        }
+
+
+        //check if argument is constant int
+        if(ConstantInt *CInt = dyn_cast<ConstantInt>(CI->getArgOperand(iop))){
+          myPrepState = CInt->getZExtValue();     
+        }
+        
+        //check if argument is constant float
+        if(ConstantFP *CFP = dyn_cast<ConstantFP>(CI->getArgOperand(iop))){
+          myRotationAngle = CFP->getValueAPF().convertToDouble();
+        }               
+        
+        //if(tmpQGateArg.isQbit || tmpQGateArg.isCbit){
+        if(tmpQGateArg.isQbit){
+            tmpDepQbit.push_back(tmpQGateArg);  
+            tracked_all_operands &= backtraceOperand(CI->getArgOperand(iop),0);
+        }
+
+        if(tmpDepQbit.size()>0){          
+          allDepQbit.push_back(tmpDepQbit[0]);
+          assert(tmpDepQbit.size() == 1 && "tmpDepQbit SIZE GT 1");
+          tmpDepQbit.clear();
+        }
+        
+      }
+      
+      if(allDepQbit.size() > 0){
+        if(debugGenLPFSSched)
+        {
+            errs() << "\nCall inst: " << CI->getCalledFunction()->getName();        
+            errs() << ": Found all arguments: ";       
+            for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+              if(allDepQbit[vb].argPtr)
+                errs() << allDepQbit[vb].argPtr->getName() <<" Index: ";
+                                
+              //else
+                errs() << allDepQbit[vb].valOrIndex <<" ";
+            }
+            errs()<<"\n";
+            
+        }
+
+
+        //check if Intrinsic
+        bool thisFuncIsIntrinsic = checkIfIntrinsic(CI->getCalledFunction());
+        if(!thisFuncIsIntrinsic) {
+            hasPrimitivesOnly = false;
+//            string gname = CI->getCalledFunction()->getName();
+//            errs() << "Non-Instric Func is: " << gname << "\n";
+        }
+          
+       string fname =  CI->getCalledFunction()->getName();  
+       qGate thisGate;
+       thisGate.qFunc =  CI->getCalledFunction();
+
+       if(myPrepState!=-1) thisGate.angle = (float)myPrepState;
+       if(myRotationAngle!=0.0) thisGate.angle = myRotationAngle;
+
+       for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+            if(allDepQbit[vb].argPtr){
+              //errs() << allDepQbit[vb].argPtr->getName() <<" Index: ";
+              //errs() << allDepQbit[vb].valOrIndex <<"\n";
+                qGateArg param =  allDepQbit[vb];       
+                thisGate.args[thisGate.numArgs].name = param.argPtr->getName();
+                if(!param.isPtr)
+                  thisGate.args[thisGate.numArgs].index = param.valOrIndex;
+                thisGate.numArgs++;
+            }
+       }
+
+//       errs() << "Calc Crit Times\n";
+       uint64_t thisTS = calc_critical_time_unbounded(F,thisGate);       
+       //update priorityVector
+       priorityVector.push_back(make_pair(pInst,thisTS));
+
+
+       //add to mapInstSet
+       mapCalls[pInst].name = thisGate;
+
+       op newOp;
+       newOp.name = thisGate;
+       //funcList.push_back(make_pair(pInst,newOp));
+
+
+      }    
+      allDepQbit.erase(allDepQbit.begin(),allDepQbit.end());
+    }
+}
+
+
+void GenLPFSSched::saveTableFuncQbits(Function* F){
+  map<unsigned int, map<int, uint64_t> > tmpFuncQbitsMap;
+  for(map<string, map<int, uint64_t> >::iterator mapIt = funcQbits.begin(); mapIt!=funcQbits.end(); ++mapIt){
+    map<string, unsigned int>::iterator argIt = funcArgs.find((*mapIt).first);
+    if(argIt!=funcArgs.end()){
+      unsigned int argNum = (*argIt).second;
+      tmpFuncQbitsMap[argNum] = (*mapIt).second;
+    }
+  }
+  tableFuncQbits[F] = tmpFuncQbitsMap;
+}
+
+
+bool GenLPFSSched::analyzeIntrinsicCallInst(Function *F, Instruction *Inst){
+    if(CallInst *CI = dyn_cast<CallInst>(Inst)){
+        bool thisFuncIsIntrinsic = checkIfIntrinsic(CI->getCalledFunction());
+        if(!thisFuncIsIntrinsic) {
+            return false;
+        }
+    }
+    return true;
+}
+
+bool GenLPFSSched::DetermineLeafFunction (Function *F) {
+    bool isALeaf = false;
+    vector<Instruction*> InstList;
+    for (inst_iterator I = inst_begin(*F), E = inst_end(*F); I != E; ++I) {
+        Instruction *Inst = &*I;
+        if(CallInst *CI = dyn_cast<CallInst>(Inst)){
+            op newOp;
+            string called_func_name = CI->getCalledFunction()->getName();
+            InstList.push_back(Inst);
+        }
+    } 
+    for(vector<Instruction*>::reverse_iterator rit = InstList.rbegin(); rit!=InstList.rend(); ++rit){
+        isALeaf = analyzeIntrinsicCallInst(F,(*rit));  
+        if (!isALeaf) {
+            if( dyn_cast<CallInst>((*rit))->getCalledFunction()->getName() != "store_cbit" )
+                return false;
+        }
+  }
+  if(isALeaf) {
+    isLeaf.push_back(F);
+    return true;
+  }
+  return false;
+}
+
+
+void GenLPFSSched::CountCriticalFunctionResources (Function *F) {
+      // Traverse instruction by instruction
+  init_critical_path_algo(F);
+  
+
+  //get qbits in function
+  for (inst_iterator I = inst_begin(*F), E = inst_end(*F); I != E; ++I) {
+    Instruction *Inst = &*I;                            // Grab pointer to instruction reference
+    analyzeAllocInst(F,Inst);          
+    if(!isa<AllocaInst>(Inst))
+      break;
+  }
+
+//  errs() << "Finding priorities--- \n";
+  //find priorities for instructions
+  for (inst_iterator I = inst_begin(*F), E = inst_end(*F); I != E; ++I) {
+    Instruction *Inst = &*I;
+    if(CallInst *CI = dyn_cast<CallInst>(Inst)){
+      op newOp;
+      string called_func_name = CI->getCalledFunction()->getName();
+      mapCalls.insert(make_pair(Inst, newOp));
+      callList.push_back(Inst);
+//      errs() << "Added instruction: " << Inst << ": " << called_func_name << "\n";
+      if(F->getName() == "measure") {
+//          errs() << "Added Inst " << called_func_name << " : " << Inst << " to call list for measure \n";
+      }
+    }
+  } 
+
+  //traverse in reverse sequence
+//  errs() << "Beginning analysis" << "\n";
+  for(vector<Instruction*>::reverse_iterator rit = callList.rbegin(); rit!=callList.rend(); ++rit){
+//        errs() << "Analyzing: " << mapCalls.find(*rit)->second.name.qFunc->getName() << "\n";
+//        errs() << "Analyzing: " << dyn_cast<CallInst>(*rit)->getCalledFunction()->getName() << "\n";
+        analyzeCallInst(F,(*rit));  
+  }
+//  errs() << "Finished Analyzing" << "\n";
+  //is function leaf or not?
+//  if(hasPrimitivesOnly) isLeaf.push_back(F);
+
+  //sort vector
+  sort(priorityVector.begin(), priorityVector.end(), CompareInstPriByValue());
+
+  //reset funcQbits vector in preparation for scheduling
+  memset_funcQbits(0);
+
+  //errs() << "Finding Schedule--- \n";
+
+  for(vector<InstPri>::reverse_iterator vit = priorityVector.rbegin(); vit!=priorityVector.rend(); ++vit){
+    //get qgate
+//    errs() << "priority scheduling..." << "\n";
+    map<Instruction*, op>::iterator mit = mapCalls.find((*vit).first);
+    assert(mit!=mapCalls.end() && "Instruction Not Found in MapInstSet.");
+    
+
+
+    qGate thisGate = (*mit).second.name;
+//    if(!(F->getName() == "main")) { 
+//        errs() << "CHECK: " << thisGate.qFunc->getName() << "\n";
+//      if(hasPrimitivesOnly)
+//        calc_critical_time(F,thisGate,true);
+//      else
+//        calc_critical_time(F,thisGate,false);
+//    }
+  }
+
+
+
+
+}
+
+
+void GenLPFSSched::init_gates_as_functions(){
+    
+    //add blackbox entry for each of these ??
+    
+  for(int  i =0; i< NUM_QGATES ; i++){
+    string gName = gate_name[i];
+    string fName = "llvm.";
+    fName.append(gName);
+    
+  }
+
+}
+
+
+bool GenLPFSSched::runOnModule (Module &M) {
+  init_gate_names();
+  init_gates_as_functions();
+  int timeStep = 0; 
+  errs() << "M: $::SIMD_K=" << RES_CONSTRAINT <<"; $::SIMD_D=" << DATA_CONSTRAINT << "; $::SIMD_L=" << SIMD_L << "\n"; 
+ 
+  
+  // iterate over all functions, and over all instructions in those functions
+  CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+  //Post-order
+  for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode), E = scc_end(rootNode); sccIb != E; ++sccIb) {
+    const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+    for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(), E = nextSCC.end(); nsccI != E; ++nsccI) {
+      Function *F = (*nsccI)->getFunction();      
+      if(F && !F->isDeclaration()){
+
+        funcQbits.clear();
+        funcArgs.clear();
+        mapCalls.clear();
+        funcList.clear();
+        mapInstSet.clear();
+        priorityVector.clear();
+        longPath.clear();
+        callList.clear();
+        qubitMap.clear();
+        localMemSizeMap.clear();
+        regionSizeMap.clear();
+        mts = 0;    
+        ots = 0;    
+        simds = 0; 
+        tgates_cnt = 0;   
+
+        getFunctionArguments(F);
+
+        for(int k = 1; k <= (int) RES_CONSTRAINT; k++){
+            localMemSizeMap.insert(make_pair(k*10, 0));
+            regionSizeMap.insert(make_pair(k, 0));
+        }
+
+        // count the critical resources for this function
+       if (DetermineLeafFunction(F)){
+          CountCriticalFunctionResources(F);
+        }
+
+
+       vector<Function*>::iterator vit = find(isLeaf.begin(), isLeaf.end(), F);
+       if(vit != isLeaf.end()){
+            errs() << "\nLPFS:\n";
+            errs() << "Function: " << F->getName() << " (sched: lpfs, k: " << RES_CONSTRAINT << ", d: " << DATA_CONSTRAINT << " l: " << SIMD_L << ", opp: " << OPP_SIMD << ", refill: " << REFILL << ") \n"; 
+            errs() << "==================================================================\n";
+            lpfs(F, timeStep, SIMD_L, REFILL, OPP_SIMD);
+        }
+
+
+            int op_count = callList.size();
+            if(!(schedule.empty())) {
+                if(METRICS)
+                    print_schedule_metrics(F,op_count);
+                 if(FULL_SCHED)
+                    print_schedule(F,op_count);
+                 if(MOVES_SCHED)
+                    print_moves_schedule(F,op_count);
+                 if(LOCAL_MOVES_SCHED)
+                    print_local_moves_schedule(F, op_count);
+            }
+            schedule.clear();
+            move_schedule.clear();
+            local_move_schedule.clear();
+            active_qubits.clear();
+
+            cleanupCurrArrParGates();
+ 
+      }
+      else  {
+            if(debugGenLPFSSched)
+              errs() << "WARNING: Ignoring external node or dummy function.\n";
+      }
+    }
+  }
+
+  return false;
+} // End runOnModule
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GenQASM.cpp llvm/lib/Transforms/Scaffold/GenQASM.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GenQASM.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/GenQASM.cpp	2017-10-12 11:09:31.092119597 +0800
@@ -0,0 +1,1266 @@
+//===- GenQASM.cpp - Generate qasm output -------------------===//
+//
+//                     The LLVM Scaffold Compiler Infrastructure
+//
+// This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#include <sstream>
+#include <algorithm>
+#include <string>
+#include "llvm/Argument.h"
+#include "llvm/Pass.h"
+#include "llvm/Module.h"
+#include "llvm/Function.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/SCCIterator.h"
+#include "llvm/ADT/ilist.h"
+#include "llvm/Constants.h"
+#include "llvm/Analysis/DebugInfo.h"
+#include "llvm/IntrinsicInst.h"
+
+using namespace llvm;
+using namespace std;
+
+#define MAX_BT_COUNT 15 //max backtrace allowed - to avoid infinite recursive loops
+#define MAX_QBIT_ARR_DIM 5 //max dimensions allowed for qbit arrays
+
+bool debugGenQASM = false;
+
+namespace {
+
+  struct qGateArg{ //arguments to qgate calls
+    Value* argPtr;
+    int argNum;
+    bool isQbit;
+    bool isAbit;
+    bool isCbit;
+    bool isParam;
+    bool isUndef;
+    bool isPtr;
+    bool isDouble;
+    int numDim; //number of dimensions of qbit array
+    int dimSize[MAX_QBIT_ARR_DIM]; //sizes of dimensions of array for qbit declarations OR indices of specific qbit for gate arguments
+    int valOrIndex; //Value if not Qbit, Index if Qbit & not a Ptr
+    double val;
+    //Note: valOrIndex is of type integer. Assumes that quantities will be int in the program.
+    qGateArg(): argPtr(NULL), argNum(-1), isQbit(false), isAbit(false), isCbit(false), isParam(false), isUndef(false), isPtr(false), isDouble(false), numDim(0), valOrIndex(-1), val(0.0){ }
+  };
+  
+  struct FnCall{ //datapath sequence
+    Function* func;
+    Value* instPtr;
+    std::vector<qGateArg> qArgs;
+  };    
+
+  struct GenQASM : public ModulePass {
+    static char ID;  // Pass identification, replacement for typeid
+    std::vector<Value*> vectQbit;
+
+    std::vector<qGateArg> tmpDepQbit;
+    std::vector<qGateArg> allDepQbit;
+
+
+    map<Function*, vector<qGateArg> > mapQbitsInit;
+    map<Function*, vector<qGateArg> > mapFuncArgs;
+    map<Function*, vector<FnCall> > mapMapFunc;
+
+
+    vector<qGateArg> qbitsInFunc; //qbits in function
+    vector<qGateArg> qbitsInFuncShort; //qbits in function
+    vector<qGateArg> qbitsInitInFunc; //new qbits declared in function
+    vector<qGateArg> funcArgList; //function arguments
+    vector<FnCall> mapFunction; //trace sequence of qgate calls
+    map<Value*, qGateArg> mapInstRtn;    //traces return cbits for Meas Inst
+
+    int btCount; //backtrace count
+
+
+    GenQASM() : ModulePass(ID) {  }
+
+    bool getQbitArrDim(Type* instType, qGateArg* qa);
+    bool backtraceOperand(Value* opd, int opOrIndex);
+    void analyzeAllocInst(Function* F,Instruction* pinst);
+    void analyzeAllocInstShort(Function* F,Instruction* pinst);
+    void analyzeCallInst(Function* F,Instruction* pinst);
+    void analyzeInst(Function* F,Instruction* pinst);
+
+    // run - Print out SCCs in the call graph for the specified module.
+    bool runOnModule(Module &M);
+
+    void printFuncHeader(Function* F, bool lastFunc);
+
+	string to_string(int var);
+
+    string printVarName(StringRef s)
+    {
+      std::string sName = s.str();
+      std::replace(sName.begin(), sName.end(), '.', '_');
+
+      unsigned pos = sName.rfind("..");
+
+      if(pos == sName.length()-2){
+	std::string s1 = sName.substr(0,pos);
+	return s1;
+      }
+      else{
+	unsigned pos1 = sName.rfind(".");
+	
+	if(pos1 == sName.length()-1){
+	  std::string s1 = sName.substr(0,pos1);
+	  return s1;
+	}
+	else{
+	  pos = sName.find(".addr");
+	  std::string s1 = sName.substr(0,pos);     
+	  return s1;
+	}
+      }
+    }
+    
+
+    void print_qgateArg(qGateArg qg)
+    {
+      errs()<< "Printing QGate Argument:\n";
+      if(qg.argPtr) errs() << "  Name: "<<qg.argPtr->getName()<<"\n";
+      errs() << "  Arg Num: "<<qg.argNum<<"\n"
+	     << "  isUndef: "<<qg.isUndef
+	     << "  isQbit: "<<qg.isQbit
+	     << "  isAbit: "<<qg.isAbit
+	     << "  isCbit: "<<qg.isCbit
+	     << "  isPtr: "<<qg.isPtr << "\n"
+	     << "  Value or Index: "<<qg.valOrIndex<<"\n"
+	     << "  Num of Dim: "<<qg.numDim<<"\n";
+      for(int i = 0; i<qg.numDim; i++)
+	errs() << "     dimSize ["<<i<<"] = "<<qg.dimSize[i] << "\n";
+    }
+
+    void genQASM(Function* F);
+    void getFunctionArguments(Function* F);
+    bool DetermineQFunc(Function* F);
+    
+    void print(raw_ostream &O, const Module* = 0) const { 
+      errs() << "Qbits found: ";
+      for(unsigned int vb=0; vb<vectQbit.size(); vb++){
+	errs() << vectQbit[vb]->getName() <<" ";
+      }
+      errs()<<"\n";      
+    }
+  
+
+    // getAnalysisUsage - This pass requires the CallGraph.
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();
+      AU.addRequired<CallGraph>();
+    }
+  };
+}
+
+char GenQASM::ID = 0;
+static RegisterPass<GenQASM>
+X("gen-qasm", "Generate QASM output code"); //spatil: should be Z or X??
+
+bool GenQASM::backtraceOperand(Value* opd, int opOrIndex)
+{
+
+  if(opOrIndex == 0) //backtrace for operand
+  {
+    //search for opd in qbit/cbit vector
+    std::vector<Value*>::iterator vIter=std::find(vectQbit.begin(),vectQbit.end(),opd);
+    if(vIter != vectQbit.end()){
+      if(debugGenQASM)
+        errs()<<"Found qubit associated: "<< opd->getName() << "\n";
+
+      tmpDepQbit[0].argPtr = opd;
+
+      return true;
+    }
+
+    if(btCount>MAX_BT_COUNT)
+      return false;
+
+    if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(opd))
+	{
+	  if(debugGenQASM)
+	  {
+	      errs() << "Get Elem Ptr Inst Found: " << *GEPI <<"\n";
+	      errs() << GEPI->getPointerOperand()->getName();
+	      errs() << " has index = " << GEPI->hasIndices();
+	      errs() << " has all constant index = " << GEPI->hasAllConstantIndices() << "\n";
+	  }
+
+	  if(GEPI->hasAllConstantIndices()){
+	    Instruction* pInst = dyn_cast<Instruction>(opd);
+	    unsigned numOps = pInst->getNumOperands();
+	    if(debugGenQASM)
+	      errs() << " Has constant index. Num Operands: " << numOps << ": ";
+
+	    
+	    bool foundOne = backtraceOperand(pInst->getOperand(0),0);
+
+	    if(numOps>2){ //set the dimensionality of the qbit
+	      tmpDepQbit[0].numDim = numOps-2;
+	    
+	    for(unsigned arrIter=2; arrIter < numOps; arrIter++)
+	      {
+		ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(arrIter));
+		//errs() << "Arr[ "<<arrIter<<" ] = "<<CI->getZExtValue()<<"\n";
+		if(tmpDepQbit.size()==1){
+		  tmpDepQbit[0].dimSize[arrIter-2] = CI->getZExtValue();  
+		}
+	      }
+	    }
+	    else if(numOps==2){
+	      tmpDepQbit[0].numDim = 1;
+	      ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(numOps-1));
+	      if(tmpDepQbit.size()==1){
+		tmpDepQbit[0].dimSize[0] = CI->getZExtValue();
+		if(debugGenQASM)
+		  errs()<<" Found constant index = "<<CI->getValue()<<"\n";
+	      }
+	    }
+
+	    //NOTE: getelemptr instruction can have multiple indices. Currently considering last operand as desired index for qubit. Check this reasoning. 
+	    ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(numOps-1));
+	    if(tmpDepQbit.size()==1){
+	      tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+	      if(debugGenQASM)
+		errs()<<" Found constant index = "<<CI->getValue()<<"\n";
+	    }
+	    return foundOne;
+	  }
+	  
+	  else if(GEPI->hasIndices()){ //NOTE: Edit this function for multiple indices, some of which are constant, others are not.
+	  
+	    errs() << "Oh no! I don't know how to handle this case..ABORT ABORT..\n";
+	    Instruction* pInst = dyn_cast<Instruction>(opd);
+	    unsigned numOps = pInst->getNumOperands();
+	    if(debugGenQASM)
+	      errs() << " Has non-constant index. Num Operands: " << numOps << ": ";		
+	    bool foundOne = backtraceOperand(pInst->getOperand(0),0);
+
+	    if(tmpDepQbit[0].isQbit && !(tmpDepQbit[0].isPtr)){     
+	      //NOTE: getelemptr instruction can have multiple indices. consider last operand as desired index for qubit. Check if this is true for all.
+	      backtraceOperand(pInst->getOperand(numOps-1),1);
+	      
+	    }
+		else if(tmpDepQbit[0].isAbit && !(tmpDepQbit[0].isPtr)){
+			backtraceOperand(pInst->getOperand(numOps-1),1);
+		}
+	    return foundOne;
+	  }	  
+	  else{	    
+	    Instruction* pInst = dyn_cast<Instruction>(opd);
+	    unsigned numOps = pInst->getNumOperands();
+	    bool foundOne = false;
+	    for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	      foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),0);
+	    }
+	    return foundOne;
+	  }
+	}
+      
+      if(isa<LoadInst>(opd)){
+	if(tmpDepQbit[0].isQbit && !tmpDepQbit[0].isPtr){
+	  tmpDepQbit[0].numDim = 1;
+	  tmpDepQbit[0].dimSize[0] = 0;
+	  if(debugGenQASM)
+	    errs()<<" Added default dim to qbit & not ptr variable.\n";
+	}
+	else if(tmpDepQbit[0].isAbit && !tmpDepQbit[0].isPtr){
+		tmpDepQbit[0].numDim = 1;
+		tmpDepQbit[0].dimSize[0] = 0;
+	}
+
+      }
+
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	unsigned numOps = pInst->getNumOperands();
+	bool foundOne = false;
+	for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	  btCount++;
+	  foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),0);
+	  btCount--;
+	}
+	return foundOne;
+      }
+      else{
+	if(debugGenQASM)
+	  errs() << "Ending Recursion\n";
+	return false;
+      }
+    }
+  else if(opOrIndex == 0){ //opOrIndex == 1; i.e. Backtracing for Index    
+    if(btCount>MAX_BT_COUNT) //prevent infinite backtracing
+      return true;
+
+    if(ConstantInt *CI = dyn_cast<ConstantInt>(opd)){
+      tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+      if(debugGenQASM)
+	errs()<<" Found constant index = "<<CI->getValue()<<"\n";
+
+      return true;
+    }      
+
+    if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+      unsigned numOps = pInst->getNumOperands();
+      bool foundOne = false;
+      for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	btCount++;
+	foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),1);
+	btCount--;
+      }
+      return foundOne;
+    }
+
+  }
+  else{ //opOrIndex == 2: backtracing to call inst MeasZ
+    if(debugGenQASM)
+      errs()<<"backtracing for call inst: "<<*opd<<"\n";
+    if(CallInst *endCI = dyn_cast<CallInst>(opd)){
+      if(endCI->getCalledFunction()->getName().find("llvm.Meas") != string::npos){
+	tmpDepQbit[0].argPtr = opd;
+
+	if(debugGenQASM)
+	  errs()<<" Found call inst = "<<*endCI<<"\n";
+	return true;
+      }
+      else{
+	if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	  unsigned numOps = pInst->getNumOperands();
+	  bool foundOne=false;
+	  for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	    btCount++;
+	    foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+	    btCount--;
+	  }
+	  return foundOne;
+	}
+      }
+    }
+    else{
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	unsigned numOps = pInst->getNumOperands();
+	bool foundOne=false;
+	for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	  btCount++;
+	  foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+	  btCount--;
+	}
+	return foundOne;
+      }
+    }
+  }
+  return false;
+}
+
+bool GenQASM::getQbitArrDim(Type *instType, qGateArg* qa)
+{
+  bool myRet = false;
+
+  errs() << "In get_all_dimensions \n";
+
+  if(ArrayType *arrayType = dyn_cast<ArrayType>(instType)) {
+    Type *elementType = arrayType->getElementType();
+    uint64_t arraySize = arrayType->getNumElements();
+    errs() << "Array Size = "<<arraySize << "\n";
+    qa->dimSize[qa->numDim] = arraySize;
+    qa->numDim++;
+
+    if (elementType->isIntegerTy(16)){
+      myRet = true;
+      qa->isQbit = true;
+    }
+    else if (elementType->isIntegerTy(1)){
+      myRet = true;
+      qa->isCbit = true;
+    }
+	else if(elementType->isIntegerTy(8)){
+		myRet = true;
+		qa->isAbit = true;
+	}
+    else if (elementType->isArrayTy()){
+      myRet |= getQbitArrDim(elementType,qa);
+    }
+    else myRet = false;
+  }
+
+  return myRet;
+
+}
+
+void GenQASM::analyzeAllocInstShort(Function* F, Instruction* pInst){
+
+  if (AllocaInst *AI = dyn_cast<AllocaInst>(pInst)) {
+    Type *allocatedType = AI->getAllocatedType();
+    
+    if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+      qGateArg tmpQArg;
+
+      Type *elementType = arrayType->getElementType();
+      uint64_t arraySize = arrayType->getNumElements();
+      if (elementType->isIntegerTy(16)){
+	if(debugGenQASM)
+	  errs() << "New QBit Allocation Found: " << AI->getName() <<"\n";
+	qbitsInFuncShort.push_back(tmpQArg);
+      }
+      
+      else if (elementType->isIntegerTy(1)){
+	if(debugGenQASM)
+	  errs() << "New CBit Allocation Found: " << AI->getName() <<"\n";
+	qbitsInFuncShort.push_back(tmpQArg);
+      }
+
+	  else if (elementType->isIntegerTy(8)){
+		qbitsInFuncShort.push_back(tmpQArg);
+	  }
+
+    }
+    else if(allocatedType->isIntegerTy(16)){
+        qGateArg tmpQArg;
+        qbitsInFuncShort.push_back(tmpQArg);
+    }
+	else if(allocatedType->isIntegerTy(8)){
+		qGateArg tmpQArg;
+		qbitsInFuncShort.push_back(tmpQArg);
+	}
+	//find argName2 in funcArgList - avoid printing out qbit declaration twice
+	//std::map<Function*, vector<qGateArg> >::iterator mIter = funcArgList.find(F);
+	//if(mIter != funcArgList.end()){
+    return;
+  }
+
+}
+
+
+void GenQASM::analyzeAllocInst(Function* F, Instruction* pInst){
+  if (AllocaInst *AI = dyn_cast<AllocaInst>(pInst)) {
+    Type *allocatedType = AI->getAllocatedType();
+    
+    if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+      qGateArg tmpQArg;
+	  
+	  Type *elementType = arrayType->getElementType();
+      uint64_t arraySize = arrayType->getNumElements();
+      if (elementType->isIntegerTy(16)){
+	if(debugGenQASM)
+	  errs() << "New QBit Allocation Found: " << AI->getName() <<"\n";
+	vectQbit.push_back(AI);
+	tmpQArg.isQbit = true;
+	tmpQArg.argPtr = AI;
+	tmpQArg.numDim = 1;
+	tmpQArg.dimSize[0] = arraySize;
+	tmpQArg.valOrIndex = arraySize;
+	//(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	qbitsInFunc.push_back(tmpQArg);
+	//(qbitsInitInFunc.find(F))->second.push_back(tmpQArg);	
+	qbitsInitInFunc.push_back(tmpQArg);	
+      }
+      
+      else if (elementType->isIntegerTy(1)){
+	if(debugGenQASM)
+	  errs() << "New CBit Allocation Found: " << AI->getName() <<"\n";
+	vectQbit.push_back(AI); //Cbit added here
+	tmpQArg.isCbit = true;
+	tmpQArg.argPtr = AI;
+	tmpQArg.numDim = 1;
+	tmpQArg.dimSize[0] = arraySize;
+	tmpQArg.valOrIndex = arraySize;
+	//(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	qbitsInFunc.push_back(tmpQArg);
+	//(qbitsInitInFunc.find(F))->second.push_back(tmpQArg);	
+	qbitsInitInFunc.push_back(tmpQArg);	
+      }
+
+	  else if (elementType->isIntegerTy(8)){
+		vectQbit.push_back(AI); //Cbit added here
+		tmpQArg.isCbit = false;
+		tmpQArg.isAbit = true;
+		tmpQArg.argPtr = AI;
+		tmpQArg.numDim = 1;
+		tmpQArg.dimSize[0] = arraySize;
+		tmpQArg.valOrIndex = arraySize;
+		//(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+		qbitsInFunc.push_back(tmpQArg);
+		//(qbitsInitInFunc.find(F))->second.push_back(tmpQArg);	
+		qbitsInitInFunc.push_back(tmpQArg);	
+	  }
+
+      else if(elementType->isArrayTy()){
+	  errs() << "Multidimensional array\n";
+
+	  tmpQArg.dimSize[0] = arraySize;
+	  tmpQArg.numDim++;
+	  tmpQArg.valOrIndex = arraySize;
+
+	  //recurse on multi-dimensional array
+	  bool isQAlloc = getQbitArrDim(elementType,&tmpQArg);
+
+	  if(isQAlloc){
+	    vectQbit.push_back(AI);
+	    tmpQArg.argPtr = AI;
+	    //(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	    qbitsInFunc.push_back(tmpQArg);
+	    //(qbitsInitInFunc.find(F))->second.push_back(tmpQArg);
+	    qbitsInitInFunc.push_back(tmpQArg);
+
+	    if(debugGenQASM)
+	      print_qgateArg(tmpQArg);
+	  }	  
+      }
+
+    }
+    else if(allocatedType->isIntegerTy(16)){
+        qGateArg tmpQArg;
+        if(debugGenQASM) errs() << "Found New Qbit Allocation \n";
+        vectQbit.push_back(AI);
+        tmpQArg.isQbit = true;
+        tmpQArg.argPtr = AI;
+        tmpQArg.numDim = 1;
+//        tmpQArg.dimSize[0] = 1;
+        tmpQArg.dimSize[0] = cast<ConstantInt>(AI->getArraySize())->getSExtValue();
+        tmpQArg.valOrIndex = 1;
+        qbitsInFunc.push_back(tmpQArg);
+        qbitsInitInFunc.push_back(tmpQArg);
+    }
+
+    else if(allocatedType->isPointerTy()){
+      
+      /*Note: this is necessary if -mem2reg is not run on LLVM IR before.
+	Eg without -mem2reg
+	module(i8* %q){
+	%q.addr = alloca i8*, align 8
+	...
+	}
+	qbit q.addr must be mapped to argument q. Hence the following code.
+	If it is known that -O1 will be run, then this can be removed.
+      */
+      
+      Type *elementType = allocatedType->getPointerElementType();
+      if (elementType->isIntegerTy(16)){
+	vectQbit.push_back(AI);
+	
+	qGateArg tmpQArg;
+	tmpQArg.isPtr = true;
+	tmpQArg.isQbit = true;
+	tmpQArg.argPtr = AI;
+	
+	//(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	qbitsInFunc.push_back(tmpQArg);
+	
+	std::string argName = AI->getName();
+	unsigned pos = argName.find(".addr");
+	std::string argName2 = argName.substr(0,pos);
+
+	//find argName2 in funcArgList - avoid printing out qbit declaration twice
+	//std::map<Function*, vector<qGateArg> >::iterator mIter = funcArgList.find(F);
+	//if(mIter != funcArgList.end()){
+	  bool foundit = false;
+	  for(vector<qGateArg>::iterator vParamIter = funcArgList.begin();(vParamIter!=funcArgList.end() && !foundit);++vParamIter){
+	    if((*vParamIter).argPtr->getName() == argName2){ 
+	      foundit = true;
+	    }
+	  }
+	  if(!foundit) //do not add duplicate declaration	    
+	    qbitsInitInFunc.push_back(tmpQArg);
+	  //}
+      }
+	  else if (elementType->isIntegerTy(8)){
+		vectQbit.push_back(AI);
+		qGateArg tmpQArg;
+		tmpQArg.isPtr = true;
+		tmpQArg.isAbit = true;
+		tmpQArg.argPtr = AI;
+
+		qbitsInFunc.push_back(tmpQArg);
+
+		std::string argName = AI->getName();
+		unsigned pos = argName.find(".addr");
+		std::string argName2 = argName.substr(0,pos);
+		bool foundit = false;
+		for(vector<qGateArg>::iterator vParamIter = funcArgList.begin();(vParamIter!=funcArgList.end() && !foundit);++vParamIter){
+	    	if((*vParamIter).argPtr->getName() == argName2) foundit = true;
+	  	}
+		if(!foundit) qbitsInitInFunc.push_back(tmpQArg);
+	  }
+	}
+    return;
+  }
+
+}
+
+void GenQASM::analyzeCallInst(Function* F, Instruction* pInst){
+  if(CallInst *CI = dyn_cast<CallInst>(pInst))
+    {
+      if(debugGenQASM)      
+	errs() << "Call inst: " << CI->getCalledFunction()->getName() << "\n";
+
+      if(CI->getCalledFunction()->getName() == "store_cbit"){	//trace return values
+	qGateArg tmpQGateArg1;
+	tmpQGateArg1.isCbit = true;
+	tmpDepQbit.push_back(tmpQGateArg1);
+	backtraceOperand(CI->getArgOperand(0),2); //value Operand
+	Value* rtnVal = tmpDepQbit[0].argPtr;
+	tmpDepQbit.clear();
+
+	qGateArg tmpQGateArg2;
+	tmpQGateArg2.isCbit = true;
+	tmpQGateArg2.isPtr = true;
+	tmpDepQbit.push_back(tmpQGateArg2);	
+	backtraceOperand(CI->getArgOperand(1),0); //pointer Operand
+
+	//insert info in map here
+	mapInstRtn[rtnVal] = tmpDepQbit[0];
+
+	tmpDepQbit.clear();
+	return;
+      }
+      
+      bool tracked_all_operands = true;
+      
+      for(unsigned iop=0;iop<CI->getNumArgOperands();iop++){
+	tmpDepQbit.clear();
+	
+	qGateArg tmpQGateArg;
+	btCount=0;
+	
+	if(debugGenQASM)
+	  errs() << "Call inst operand num: " << iop << "\n";
+	
+	tmpQGateArg.argNum = iop;
+	
+	
+	if(isa<UndefValue>(CI->getArgOperand(iop))){
+	  //errs() << "WARNING: LLVM IR code has UNDEF values. \n";
+	  tmpQGateArg.isUndef = true;	
+	  //exit(1);
+	  //assert(0 && "LLVM IR code has UNDEF values. Aborting...");
+	}
+	
+	Type* argType = CI->getArgOperand(iop)->getType();
+	if(argType->isPointerTy()){
+	  tmpQGateArg.isPtr = true;
+	  Type *argElemType = argType->getPointerElementType();
+	  if(argElemType->isIntegerTy(16))
+	    tmpQGateArg.isQbit = true;
+	  if(argElemType->isIntegerTy(1))
+	    tmpQGateArg.isCbit = true;
+	  if(argElemType->isIntegerTy(8))
+		tmpQGateArg.isAbit = true;
+	}
+	else if(argType->isIntegerTy(16)){
+	  tmpQGateArg.isQbit = true;
+	  tmpQGateArg.valOrIndex = 0;	 
+	}	  	
+	else if(argType->isIntegerTy(32)){
+	  if(ConstantInt *CInt = dyn_cast<ConstantInt>(CI->getArgOperand(iop))){
+	  	tmpQGateArg.isParam = true;
+	  	tmpQGateArg.valOrIndex = CInt->getZExtValue();
+	  }
+	}
+	else if(argType->isIntegerTy(8)){
+		tmpQGateArg.isAbit = true;
+		tmpQGateArg.valOrIndex = 0;
+	}
+	else if(argType->isIntegerTy(1)){
+	  tmpQGateArg.isCbit = true;
+	  tmpQGateArg.valOrIndex = 0;	 
+	}	  	
+	
+	//check if argument is constant int	
+	if(ConstantInt *CInt = dyn_cast<ConstantInt>(CI->getArgOperand(iop))){
+	  tmpQGateArg.valOrIndex = CInt->getZExtValue();
+	  if(debugGenQASM){
+	    errs()<<" Found constant argument = "<<CInt->getValue()<<"\n";
+	  }
+	}
+	
+
+	//check if argument is constant float	
+	if(ConstantFP *CFP = dyn_cast<ConstantFP>(CI->getArgOperand(iop))){
+	  tmpQGateArg.val = CFP->getValueAPF().convertToDouble();
+	  tmpQGateArg.isDouble = true;
+	  if(debugGenQASM){
+	    errs()<<" Call Inst = "<<*CI<<"\n";
+	    errs()<<" Found constant double argument = "<<tmpQGateArg.val<<"\n";
+	  }
+	}
+
+
+	tmpDepQbit.push_back(tmpQGateArg);
+	
+	tracked_all_operands &= backtraceOperand(CI->getArgOperand(iop),0);
+	
+	if(tmpDepQbit.size()>0){
+	  if(debugGenQASM)
+	    print_qgateArg(tmpDepQbit[0]);
+	  
+	  allDepQbit.push_back(tmpDepQbit[0]);
+	  assert(tmpDepQbit.size() == 1 && "tmpDepQbit SIZE GT 1");
+	  tmpDepQbit.clear();
+	}
+	
+      }
+                  
+      //form info packet
+      FnCall qInfo;
+      qInfo.func = CI->getCalledFunction();
+      qInfo.instPtr = CI;
+      
+      if(allDepQbit.size() > 0){
+	if(debugGenQASM)
+	  {
+	    errs() << "\nCall inst: " << CI->getCalledFunction()->getName();	    
+	    errs() << ": Found all arguments: ";       
+	    for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+	      if(allDepQbit[vb].argPtr)
+		errs() << allDepQbit[vb].argPtr->getName() <<" ";
+	      else
+		errs() << allDepQbit[vb].valOrIndex <<" ";
+	    }
+	    errs()<<"\n";
+	  }
+	
+	//populate vector of passed qubit arguments
+	for(unsigned int vb=0; vb<allDepQbit.size(); vb++)
+	  qInfo.qArgs.push_back(allDepQbit[vb]);
+	
+      }
+      
+      //map<Function*, vector<FnCall> >::iterator mvdpit = mapFunction.find(F);	
+      //(*mvdpit).second.push_back(qInfo);      
+      mapFunction.push_back(qInfo);
+
+      return;      
+    }
+}
+
+
+void GenQASM::analyzeInst(Function* F, Instruction* pInst){
+  if(debugGenQASM)
+    errs() << "--Processing Inst: "<<*pInst << '\n';
+
+  //analyzeAllocInst(F,pInst);
+  analyzeCallInst(F,pInst);
+    
+  if(debugGenQASM)
+    {
+      errs() << "Opcode: "<<pInst->getOpcodeName() << "\n";
+      
+      unsigned numOps = pInst->getNumOperands();
+      errs() << "Num Operands: " << numOps << ": ";
+      
+      for(unsigned iop=0;iop<numOps;iop++){
+	errs() << pInst->getOperand(iop)->getName() << "; ";
+      }
+      errs() << "\n";		
+      return;
+    }
+    
+  return;
+}
+
+std::string GenQASM::to_string(int var){
+	stringstream ss;
+	ss << var;
+	return ss.str();
+}
+
+void GenQASM::printFuncHeader(Function* F, bool lastFunc)
+{
+
+  //map<Function*, vector<qGateArg> >::iterator mpItr;
+  //map<Function*, vector<qGateArg> >::iterator mpItr2;
+  //map<Function*, vector<qGateArg> >::iterator mvpItr;
+
+  //mpItr = qbitsInFunc.find(F);
+
+  //print name of function
+
+  funcArgList = mapFuncArgs.find(F)->second;
+  qbitsInitInFunc = mapQbitsInit.find(F)->second;
+
+  std::string newName = F->getName();
+  std::replace(newName.begin(), newName.end(), '.','_');
+  std::replace(newName.begin(), newName.end(), '-','_');
+
+  if(lastFunc) errs() << "\nmodule main";
+  else errs()<<"\nmodule "<< newName;
+  
+  //print arguments of function
+  //mpItr2=funcArgList.find(F);    
+  errs()<<" ( ";    
+  unsigned tmp_num_elem = funcArgList.size();
+  
+  if(tmp_num_elem > 0){
+    for(unsigned tmp_i=0;tmp_i<tmp_num_elem - 1;tmp_i++){
+      
+      qGateArg tmpQA = funcArgList[tmp_i];
+      
+      if(debugGenQASM)
+	print_qgateArg(tmpQA);
+      
+      if(tmpQA.isQbit)
+	errs()<<"qbit";
+      else if(tmpQA.isCbit)
+	errs()<<"cbit";
+	  else if(tmpQA.isAbit)
+		errs() << "qbit";
+      else{
+	Type* argTy = tmpQA.argPtr->getType();
+	if(argTy->isDoubleTy()) errs() << "double";
+	else if(argTy->isFloatTy()) errs() << "float";
+	else if(argTy->isIntegerTy(32)){
+		string var = to_string(tmpQA.valOrIndex);
+		errs() << var;
+	}
+	else
+	  errs()<<"UNRECOGNIZED "<<argTy<<" ";
+      }
+      
+      if(tmpQA.isPtr)
+	errs()<<"*";	  
+      
+      std::string tmpQAName = tmpQA.argPtr->getName();
+      std::replace(tmpQAName.begin(), tmpQAName.end(), '.','_');
+      errs()<<" "<<printVarName(tmpQAName)<<" , ";
+    }
+    
+    if(debugGenQASM)
+      print_qgateArg(funcArgList[tmp_num_elem-1]);
+    
+    
+    if((funcArgList[tmp_num_elem-1]).isQbit)
+      errs()<<"qbit";
+    else if((funcArgList[tmp_num_elem-1]).isCbit)
+      errs()<<"cbit";
+	else if((funcArgList[tmp_num_elem-1]).isAbit)
+	  errs() << "qbit";
+    else{
+      Type* argTy = (funcArgList[tmp_num_elem-1]).argPtr->getType();
+      if(argTy->isDoubleTy()) errs() << "double";
+      else if(argTy->isFloatTy()) errs() << "float";
+	  else if(argTy->isIntegerTy(32)){
+			string var = to_string(funcArgList[tmp_num_elem-1].valOrIndex); 
+//			errs() << var; 
+			errs() << "int size"; 
+	  }
+	else
+	errs()<<"UNRECOGNIZED "<<argTy<<" ";
+    }
+    
+    if((funcArgList[tmp_num_elem-1]).isPtr)
+      errs()<<"*";
+
+      std::string qbName = (funcArgList[tmp_num_elem-1]).argPtr->getName();
+      std::replace(qbName.begin(), qbName.end(), '.','_');
+      errs()<<" "<<printVarName(qbName)<<" , ";
+   
+//    errs() <<" "<<printVarName((funcArgList[tmp_num_elem-1]).argPtr->getName());
+  }
+  
+  errs()<<" ) {\n ";   
+  
+  //print qbits declared in function
+  //mvpItr=qbitsInitInFunc.find(F);	    
+  for(vector<qGateArg>::iterator vvit=qbitsInitInFunc.begin(),vvitE=qbitsInitInFunc.end();vvit!=vvitE;++vvit)
+    {	
+      std::string qName = (*vvit).argPtr->getName();
+      std::replace(qName.begin(), qName.end(), '.','_');
+      if((*vvit).isQbit)
+	errs()<<"\tqbit "<<printVarName(qName);
+      if((*vvit).isCbit)
+	errs()<<"\tcbit "<<printVarName(qName);
+	  if((*vvit).isAbit)
+	errs() << "\tqbit "<<printVarName(qName);
+
+      //if only single-dimensional qbit arrays expected
+      //errs()<<"["<<(*vvit).valOrIndex<<"];\n ";
+
+      //if n-dimensional qbit arrays expected 
+      for(int ndim = 0; ndim < (*vvit).numDim; ndim++)
+        errs()<<"["<<(*vvit).dimSize[ndim]<<"]";
+        errs() << ";\n";
+    }
+  //errs() << "//--//-- Fn: " << F->getName() << " --//--//\n";
+}
+  
+void GenQASM::genQASM(Function* F)
+{
+  //map<Function*, vector<qGateArg> >::iterator mpItr;
+  //map<Function*, vector<qGateArg> >::iterator mpItr2;
+  //map<Function*, vector<qGateArg> >::iterator mvpItr;
+  
+  //mpItr = qbitsInFunc.find(F);
+//  if(qbitsInFunc.size()>0){
+    
+    mapFunction = mapMapFunc.find(F)->second; 
+    //print gates in function
+    //map<Function*, vector<FnCall> >::iterator mfvIt = mapFunction.find(F);
+    for(unsigned mIndex=0;mIndex<mapFunction.size();mIndex++){
+      if(mapFunction[mIndex].qArgs.size()>0)
+      {
+
+	string fToPrint = mapFunction[mIndex].func->getName();
+	if(fToPrint.find("llvm.") != string::npos)
+	  fToPrint = fToPrint.substr(5);
+	errs()<<"\t";
+
+	//print return operand before printing MeasZ
+	if(fToPrint.find("Meas") != string::npos){
+	  //get inst ptr
+	  Value* thisInstPtr = mapFunction[mIndex].instPtr;
+	  //find inst in mapInstRtn
+	  map<Value*, qGateArg>::iterator mvq = mapInstRtn.find(thisInstPtr);
+	  if(mvq!=mapInstRtn.end()){
+	    errs()<<printVarName(((*mvq).second).argPtr->getName());
+	    if(((*mvq).second).isPtr)
+	      errs()<<"["<<((*mvq).second).valOrIndex<<"]";
+	    errs()<<" = ";
+	  }	  
+	}
+	// Intrinsic Conversion
+	if(fToPrint.find("CNOT") != string::npos) fToPrint = "CNOT";
+	else if(fToPrint.find("Toffoli.") != string::npos) fToPrint = "Toffoli";
+	else if(fToPrint.find("MeasX") != string::npos) fToPrint = "MeasX";
+	else if(fToPrint.find("MeasZ") != string::npos) fToPrint = "MeasZ";
+	else if(fToPrint.find("H.i") != string::npos) fToPrint = "H";
+	else if(fToPrint.find("Fredkin") != string::npos) fToPrint = "Fredkin";
+	else if(fToPrint.find("PrepX") != string::npos) fToPrint = "PrepX";
+	else if(fToPrint.find("PrepZ") != string::npos) fToPrint = "PrepZ";
+	else if(fToPrint.substr(0,2) == "Rz") fToPrint = "Rz";
+	else if(fToPrint.find("S.") != string::npos) fToPrint = "S";
+	else if(fToPrint.find("T.") != string::npos) fToPrint = "T";
+	else if(fToPrint.find("Sdag") != string::npos) fToPrint = "Sdag";
+	else if(fToPrint.find("Tdag") != string::npos) fToPrint = "Tdag";
+	else if(fToPrint.find("X.") != string::npos) fToPrint = "X";
+	else if(fToPrint.find("Z.") != string::npos) fToPrint = "Z";
+
+	std::replace(fToPrint.begin(), fToPrint.end(), '.', '_');
+	std::replace(fToPrint.begin(), fToPrint.end(), '-', '_');
+	errs()<<fToPrint<<" ( ";
+
+	//print all but last argument
+	for(vector<qGateArg>::iterator vpIt=mapFunction[mIndex].qArgs.begin(), vpItE=mapFunction[mIndex].qArgs.end();vpIt!=vpItE-1;++vpIt)
+	  {
+	    if((*vpIt).isUndef)
+	      errs() << " UNDEF ";
+	    else{
+	      if((*vpIt).isQbit || (*vpIt).isCbit || (*vpIt).isAbit ){
+		errs()<<printVarName((*vpIt).argPtr->getName());
+		if(!((*vpIt).isPtr)){		  
+		  //if only single-dimensional qbit arrays expected
+		  //--if((*vpIt).numDim == 0)
+		  //errs()<<"["<<(*vpIt).valOrIndex<<"]";
+		  //--else
+		    //if n-dimensional qbit arrays expected 
+		    for(int ndim = 0; ndim < (*vpIt).numDim; ndim++)
+		      errs()<<"["<<(*vpIt).dimSize[ndim]<<"]";
+		}
+	      }
+		  else if((*vpIt).isParam){
+			errs() << (*vpIt).valOrIndex;
+		  }
+	      else{
+		//assert(!(*vpIt).isPtr); 
+		if((*vpIt).isPtr) //NOTE: not expecting non-quantum pointer variables as arguments to quantum functions. If they exist, then print out name of variable
+		  errs() << " UNRECOGNIZED ";
+		else if((*vpIt).isDouble)
+		  errs() << (*vpIt).val;
+		else
+		  errs()<<(*vpIt).valOrIndex;	      
+	      }
+	    }	    	    
+	    errs()<<" , ";
+	  }
+
+	//print last element	
+	qGateArg tmpQA = mapFunction[mIndex].qArgs.back();
+
+	if(tmpQA.isUndef)
+	  errs() << " UNDEF ";
+	else{
+	  if(tmpQA.isQbit || tmpQA.isCbit || tmpQA.isAbit){
+	    errs()<<printVarName(tmpQA.argPtr->getName());
+	    if(!(tmpQA.isPtr)){
+	      //if only single-dimensional qbit arrays expected
+	      //--if(tmpQA.numDim == 0)
+	      //errs()<<"["<<tmpQA.valOrIndex<<"]";
+	      //--else
+		//if n-dimensional qbit arrays expected 
+		for(int ndim = 0; ndim < tmpQA.numDim; ndim++)
+		  errs()<<"["<<tmpQA.dimSize[ndim]<<"]";	      	      	      
+	    }
+	  }
+	  else{
+	    //assert(!tmpQA.isPtr); //NOTE: not expecting non-quantum pointer variables as arguments to quantum functions. If they exist, then print out name of variable
+	    if(tmpQA.isPtr)
+	      errs() << " UNRECOGNIZED ";
+	    else if(tmpQA.isDouble) 
+	      errs() << tmpQA.val;
+	    else
+	      errs()<<tmpQA.valOrIndex;	    
+	  }
+	  
+	}
+	errs()<<" );\n ";	      
+      }
+    }
+
+    //errs() << "//--//-- End Fn: " << F->getName() << " --//--// \n";
+    errs()<<"}\n";
+//  }
+}
+
+
+bool GenQASM::DetermineQFunc(Function* F)
+{
+    for(inst_iterator instIb = inst_begin(F),instIe=inst_end(F); instIb!=instIe;++instIb){
+        Instruction *pInst = &*instIb; // Grab pointer to instruction reference	      
+	    analyzeAllocInstShort(F,pInst);
+	}
+    if(qbitsInFuncShort.size() > 0) return true;
+    qbitsInFuncShort.clear();
+    return false;
+}
+
+void GenQASM::getFunctionArguments(Function* F)
+{
+  //std::vector<unsigned> qGateArgs;  
+
+  for(Function::arg_iterator ait=F->arg_begin();ait!=F->arg_end();++ait)
+    {    
+      std::string argName = (ait->getName()).str();
+      Type* argType = ait->getType();
+      unsigned int argNum=ait->getArgNo();         
+
+      qGateArg tmpQArg;
+      tmpQArg.argPtr = ait;
+      tmpQArg.argNum = argNum;
+
+      if(argType->isPointerTy()){
+	if(debugGenQASM)
+	  errs()<<"Argument Type: " << *argType <<"\n";
+
+	tmpQArg.isPtr = true;
+
+	Type *elementType = argType->getPointerElementType();
+	if (elementType->isIntegerTy(16)){
+	  tmpQArg.isQbit = true;
+	  vectQbit.push_back(ait);
+	  qbitsInFunc.push_back(tmpQArg);
+	  funcArgList.push_back(tmpQArg);
+	}
+	else if (elementType->isIntegerTy(1)){
+	  tmpQArg.isCbit = true;
+	  vectQbit.push_back(ait);
+	  qbitsInFunc.push_back(tmpQArg);
+	  funcArgList.push_back(tmpQArg);
+	}
+	else if(elementType->isIntegerTy(8)){
+	  tmpQArg.isAbit = true;
+	  vectQbit.push_back(ait);
+	  qbitsInFunc.push_back(tmpQArg);
+	  funcArgList.push_back(tmpQArg);
+	}
+      }
+      else if (argType->isIntegerTy(16)){
+	tmpQArg.isQbit = true;
+	vectQbit.push_back(ait);
+	qbitsInFunc.push_back(tmpQArg);
+	funcArgList.push_back(tmpQArg);
+      }
+      else if (argType->isIntegerTy(32)){
+	tmpQArg.isParam = true;
+	vectQbit.push_back(ait);
+	funcArgList.push_back(tmpQArg);
+      }
+      else if (argType->isIntegerTy(1)){
+	tmpQArg.isCbit = true;
+	vectQbit.push_back(ait);
+	qbitsInFunc.push_back(tmpQArg);
+	funcArgList.push_back(tmpQArg);
+      }
+	  else if(argType->isIntegerTy(8)){
+		tmpQArg.isAbit = true;
+		vectQbit.push_back(ait);
+		qbitsInFunc.push_back(tmpQArg);
+		funcArgList.push_back(tmpQArg);
+	  }
+      else if(argType->isDoubleTy())     
+	funcArgList.push_back(tmpQArg);
+
+      if(debugGenQASM)
+	print_qgateArg(tmpQArg);
+    }
+}
+
+// run - Find datapaths for qubits
+bool GenQASM::runOnModule(Module &M) {
+  vector<Function*> qFuncs;
+
+  CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+  unsigned sccNum = 0;
+
+//  for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode),
+//         E = scc_end(rootNode); sccIb != E; ++sccIb)
+//    {
+//      const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+//
+//      if(debugGenQASM)
+//	errs() << "\nSCC #" << ++sccNum << " : ";      
+//
+//      for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(),
+//	     E = nextSCC.end(); nsccI != E; ++nsccI)
+//	{
+//	  Function *F=(*nsccI)->getFunction();	  
+//	  
+//	  if(F && !F->isDeclaration()){
+//        if(DetermineQFunc(F)){
+//            qFuncs.push_back(F);
+//        }
+//      }
+//    }
+//  }
+//
+//  bool hasMain = false;
+//  for( vector<Function*>::iterator it = qFuncs.begin(); it!=qFuncs.end(); it++)
+//  {
+//    if ((*it)->getName() == "main") hasMain = true;
+//  }
+//  if(!hasMain){
+//    vector<Function*>::iterator it = qFuncs.end();
+//    it--;
+//    (*it)->setName("main");
+//  }
+
+   
+  errs() << "-------QASM Generation Pass:\n";
+  CallGraphNode* rootNode1 = getAnalysis<CallGraph>().getRoot();
+
+  sccNum = 0;
+
+  for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode1),
+         E = scc_end(rootNode1); sccIb != E; ++sccIb)
+    {
+      const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+
+      if(debugGenQASM)
+	errs() << "\nSCC #" << ++sccNum << " : ";      
+
+      for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(),
+	     E = nextSCC.end(); nsccI != E; ++nsccI)
+	{
+	  Function *F=(*nsccI)->getFunction();	  
+	  
+	  if(F && !F->isDeclaration()){
+	    if(debugGenQASM)
+	    errs() << "Processing Function:" << F->getName() <<" \n ";
+
+	    //initialize map structures for this function
+	    //vector<qGateArg> myQIFVec, myQIFVec1, myQIFVec2;
+	    qbitsInFunc.clear();
+	    qbitsInitInFunc.clear();
+	    funcArgList.clear();
+
+	    //std::vector<FnCall> myFuncMapVec;
+	    mapFunction.clear();
+
+	    getFunctionArguments(F);
+
+	    //visit Alloc Insts in func and find if function is quantum or classical function
+
+	    for(inst_iterator instIb = inst_begin(F),instIe=inst_end(F); instIb!=instIe;++instIb){
+
+	      Instruction *pInst = &*instIb; // Grab pointer to instruction reference	      
+
+	      if(debugGenQASM)
+		errs() << "\n Processing Inst: "<<*pInst << "\n";
+
+	      analyzeAllocInst(F,pInst);
+	    }
+
+	    //map<Function*, vector<qGateArg> >::iterator mpItr = qbitsInFunc.find(F);
+	    if(qbitsInFunc.size()>0){ //Is Quantum Function
+          mapQbitsInit.insert( make_pair( F, qbitsInitInFunc ) );
+          mapFuncArgs.insert( make_pair( F, funcArgList ) );
+          qFuncs.push_back(F);
+	    
+	      for(inst_iterator instIb = inst_begin(F),instIe=inst_end(F); instIb!=instIe;++instIb){
+
+		Instruction *pInst = &*instIb; // Grab pointer to instruction reference	      
+		allDepQbit.clear();
+		
+		if(debugGenQASM)
+		  errs() << "\n Processing Inst: "<<*pInst << "\n";
+		
+		analyzeInst(F,pInst); //spatil: need a bool return type?
+
+	      }
+          mapMapFunc.insert( make_pair( F, mapFunction ) );
+	    }
+
+	    
+	  }
+	  else{
+	    if(debugGenQASM)
+	      errs() << "WARNING: Ignoring external node or dummy function.";
+	  }
+	  
+	}
+      if (nextSCC.size() == 1 && sccIb.hasLoop())
+	errs() << " (Has self-loop).";
+    }
+
+    bool hasMain = false;
+    for( vector<Function*>::iterator it = qFuncs.begin(); it!=qFuncs.end(); it++)
+    {
+      if ((*it)->getName() == "main") hasMain = true;
+    }
+
+    vector<Function*>::iterator lastItPos;
+    if(!hasMain){
+        lastItPos = qFuncs.end();
+        lastItPos--;
+    }
+
+    for( vector<Function*>::iterator it = qFuncs.begin(); it != qFuncs.end(); it++){
+		std::string newName = (*it)->getName();
+		if(newName.find("CNOT") != string::npos) newName = "CNOT";
+		else if(newName.find("NOT.") != string::npos) newName = "X";
+		else if(newName.find("Toffoli.") != string::npos) newName = "Toffoli";
+		else if(newName.find("MeasX") != string::npos) newName = "MeasX";
+		else if(newName.find("MeasZ") != string::npos) newName = "MeasZ";
+		else if(newName.find("H.i") != string::npos) newName = "H";
+		else if(newName.find("Fredkin") != string::npos) newName = "Fredkin";
+		else if(newName.find("PrepX") != string::npos) newName = "PrepX";
+		else if(newName.find("PrepZ") != string::npos) newName = "PrepZ";
+		else if(newName.substr(0,2) == "Rz") newName = "Rz";
+		else if(newName.find("S.") != string::npos) newName = "S";
+		else if(newName.find("T.") != string::npos) newName = "T";
+		else if(newName.find("Sdag") != string::npos) newName = "Sdag";
+		else if(newName.find("Tdag") != string::npos) newName = "Tdag";
+		else if(newName.find("X.") != string::npos) newName = "X";
+		else if(newName.find("Z.") != string::npos) newName = "Z";
+
+		std::replace(newName.begin(), newName.end(), '.', '_');
+
+		(*it)->setName(newName);
+        if(it == lastItPos) printFuncHeader((*it), true);
+        else printFuncHeader((*it), false);
+        genQASM((*it));
+    }
+
+  errs()<<"\n--------End of QASM generation";
+  errs() << "\n";
+  
+  return false;
+}
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GenQASMLoops.cpp llvm/lib/Transforms/Scaffold/GenQASMLoops.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GenQASMLoops.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/GenQASMLoops.cpp	2017-10-12 11:09:31.093119606 +0800
@@ -0,0 +1,1005 @@
+//===- GenQASMLoops.cpp - Generate qasm output with loops -------------------===//
+//
+//                     The LLVM Scaffold Compiler Infrastructure
+//
+// This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#include <sstream>
+#include "llvm/Argument.h"
+#include "llvm/Pass.h"
+#include "llvm/Module.h"
+#include "llvm/Function.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/SCCIterator.h"
+#include "llvm/ADT/ilist.h"
+#include "llvm/Constants.h"
+#include "llvm/Analysis/DebugInfo.h"
+#include "llvm/IntrinsicInst.h"
+
+using namespace llvm;
+using namespace std;
+
+#define MAX_BT_COUNT 15 //max backtrace allowed - to avoid infinite recursive loops
+#define MAX_QBIT_ARR_DIM 5 //max dimensions allowed for qbit arrays
+
+bool debugGenQASMLoops = false;
+
+namespace {
+
+  struct qGateArg{ //arguments to qgate calls
+    Value* argPtr;
+    int argNum;
+    bool isQbit;
+    bool isCbit;
+    bool isUndef;
+    bool isPtr;
+    bool isDouble;
+    int numDim; //number of dimensions of qbit array  
+    int dimSize[MAX_QBIT_ARR_DIM]; //sizes of dimensions of array for qbit declarations OR indices of specific qbit for gate arguments
+    int valOrIndex; //Value if not Qbit, Index if Qbit & not a Ptr
+    double val;
+    //Note: valOrIndex is of type integer. Assumes that quantities will be int in the program.
+    qGateArg(): argPtr(NULL), argNum(-1), isQbit(false), isCbit(false), isUndef(false), isPtr(false), isDouble(false), numDim(0), valOrIndex(-1), val(0.0){ }
+  };
+  
+  struct FnCall{ //datapath sequence
+    Function* func;
+    Value* instPtr;
+    std::vector<qGateArg> qArgs;
+  };  
+
+  struct GenQASMLoops : public ModulePass {
+    static char ID;  // Pass identification, replacement for typeid
+    std::vector<Value*> vectQbit;
+
+    std::vector<qGateArg> tmpDepQbit;
+    std::vector<qGateArg> allDepQbit;
+
+    std::map<Function*, vector<qGateArg> > qbitsInFunc; //qbits in function
+    std::map<Function*, vector<qGateArg> > qbitsInitInFunc; //new qbits declared in function
+    std::map<Function*, vector<qGateArg> > funcArgList; //function arguments
+
+    std::map<Function*, std::vector<FnCall> > mapFunction; //trace sequence of qgate calls
+    std::map<Value*, qGateArg> mapInstRtn;    //traces return cbits for Meas Inst
+
+    vector<Instruction*> vRemoveInst;
+    
+    int btCount; //backtrace count
+    string forallStr;
+
+
+    GenQASMLoops() : ModulePass(ID) {  }
+
+    bool getQbitArrDim(Type* instType, qGateArg* qa);
+    bool backtraceOperand(Value* opd, int opOrIndex);
+    void analyzeAllocInst(Function* F,Instruction* pinst);
+    void analyzeCallInst(Function* F,Instruction* pinst);
+    void analyzeInst(Function* F,Instruction* pinst);
+
+    // run - Print out SCCs in the call graph for the specified module.
+    bool runOnModule(Module &M);
+
+    void printFuncHeader(Function* F);
+
+    string printVarName(StringRef s)
+    {
+      std::string sName = s.str();
+
+      unsigned pos = sName.rfind("..");
+
+      if(pos == sName.length()-2){
+	std::string s1 = sName.substr(0,pos);
+	return s1;
+      }
+      else{
+	unsigned pos1 = sName.rfind(".");
+	
+	if(pos1 == sName.length()-1){
+	  std::string s1 = sName.substr(0,pos1);
+	  return s1;
+	}
+	else{
+	  pos = sName.find(".addr");
+	  std::string s1 = sName.substr(0,pos);     
+	  return s1;
+	}
+      }
+    }
+    
+
+    void print_qgateArg(qGateArg qg)
+    {
+      errs()<< "Printing QGate Argument:\n";
+      if(qg.argPtr) errs() << "  Name: "<<qg.argPtr->getName()<<"\n";
+      errs() << "  Arg Num: "<<qg.argNum<<"\n"
+	     << "  isUndef: "<<qg.isUndef
+	     << "  isQbit: "<<qg.isQbit
+	     << "  isCbit: "<<qg.isCbit
+	     << "  isPtr: "<<qg.isPtr << "\n"
+	     << "  Value or Index: "<<qg.valOrIndex<<"\n"
+	     << "  Num of Dim: "<<qg.numDim<<"\n";
+      for(int i = 0; i<qg.numDim; i++)
+	errs() << "     dimSize ["<<i<<"] = "<<qg.dimSize[i] << "\n";
+    }
+
+    void genQASM(Function* F);
+    void getFunctionArguments(Function* F);
+    
+    void print(raw_ostream &O, const Module* = 0) const { 
+      errs() << "Qbits found: ";
+      for(unsigned int vb=0; vb<vectQbit.size(); vb++){
+	errs() << vectQbit[vb]->getName() <<" ";
+      }
+      errs()<<"\n";      
+    }
+  
+
+    // getAnalysisUsage - This pass requires the CallGraph.
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();
+      AU.addRequired<CallGraph>();
+    }
+  };
+}
+
+char GenQASMLoops::ID = 0;
+static RegisterPass<GenQASMLoops>
+X("gen-qasm-with-loops", "Generate QASM output code with repeat statements"); //spatil: should be Z or X??
+
+bool GenQASMLoops::backtraceOperand(Value* opd, int opOrIndex)
+{
+
+  if(opOrIndex == 0) //backtrace for operand
+    {
+      //search for opd in qbit/cbit vector
+      std::vector<Value*>::iterator vIter=std::find(vectQbit.begin(),vectQbit.end(),opd);
+      if(vIter != vectQbit.end()){
+	if(debugGenQASMLoops)
+	  errs()<<"Found qubit associated: "<< opd->getName() << "\n";
+	
+	tmpDepQbit[0].argPtr = opd;
+	
+	return true;
+      }
+      
+      if(btCount>MAX_BT_COUNT)
+	return false;
+      
+      if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(opd))
+	{
+	  if(debugGenQASMLoops)
+	  {
+	      errs() << "Get Elem Ptr Inst Found: " << *GEPI <<"\n";
+	      errs() << GEPI->getPointerOperand()->getName();
+	      errs() << " has index = " << GEPI->hasIndices();
+	      errs() << " has all constant index = " << GEPI->hasAllConstantIndices() << "\n";
+	  }
+
+	  if(GEPI->hasAllConstantIndices()){
+	    Instruction* pInst = dyn_cast<Instruction>(opd);
+	    unsigned numOps = pInst->getNumOperands();
+	    if(debugGenQASMLoops)
+	      errs() << " Has constant index. Num Operands: " << numOps << ": ";
+
+	    
+	    bool foundOne = backtraceOperand(pInst->getOperand(0),0);
+
+	    if(numOps>2){ //set the dimensionality of the qbit
+	      tmpDepQbit[0].numDim = numOps-2;
+	    
+	    for(unsigned arrIter=2; arrIter < numOps; arrIter++)
+	      {
+		ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(arrIter));
+		//errs() << "Arr[ "<<arrIter<<" ] = "<<CI->getZExtValue()<<"\n";
+		if(tmpDepQbit.size()==1){
+		  tmpDepQbit[0].dimSize[arrIter-2] = CI->getZExtValue();  
+		}
+	      }
+	    }
+	    else if(numOps==2){
+	      tmpDepQbit[0].numDim = 1;
+	      ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(numOps-1));
+	      if(tmpDepQbit.size()==1){
+		tmpDepQbit[0].dimSize[0] = CI->getZExtValue();
+		if(debugGenQASMLoops)
+		  errs()<<" Found constant index = "<<CI->getValue()<<"\n";
+	      }
+	    }
+
+	    //NOTE: getelemptr instruction can have multiple indices. Currently considering last operand as desired index for qubit. Check this reasoning. 
+	    ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(numOps-1));
+	    if(tmpDepQbit.size()==1){
+	      tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+	      if(debugGenQASMLoops)
+		errs()<<" Found constant index = "<<CI->getValue()<<"\n";
+	    }
+	    return foundOne;
+	  }
+	  
+	  else if(GEPI->hasIndices()){ //NOTE: Edit this function for multiple indices, some of which are constant, others are not.
+	  
+	    errs() << "Oh no! I don't know how to handle this case..ABORT ABORT..\n";
+	    Instruction* pInst = dyn_cast<Instruction>(opd);
+	    unsigned numOps = pInst->getNumOperands();
+	    if(debugGenQASMLoops)
+	      errs() << " Has non-constant index. Num Operands: " << numOps << ": ";		
+	    bool foundOne = backtraceOperand(pInst->getOperand(0),0);
+
+	    if(tmpDepQbit[0].isQbit && !(tmpDepQbit[0].isPtr)){     
+	      //NOTE: getelemptr instruction can have multiple indices. consider last operand as desired index for qubit. Check if this is true for all.
+	      backtraceOperand(pInst->getOperand(numOps-1),1);
+	      
+	    }
+	    return foundOne;
+	  }	  
+	  else{	    
+	    Instruction* pInst = dyn_cast<Instruction>(opd);
+	    unsigned numOps = pInst->getNumOperands();
+	    bool foundOne = false;
+	    for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	      foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),0);
+	    }
+	    return foundOne;
+	  }
+	}
+      
+      if(isa<LoadInst>(opd)){
+	if(tmpDepQbit[0].isQbit && !tmpDepQbit[0].isPtr){
+	  tmpDepQbit[0].numDim = 1;
+	  tmpDepQbit[0].dimSize[0] = 0;
+	  if(debugGenQASMLoops)
+	    errs()<<" Added default dim to qbit & not ptr variable.\n";
+	}
+      }
+
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	unsigned numOps = pInst->getNumOperands();
+	bool foundOne = false;
+	for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	  btCount++;
+	  foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),0);
+	  btCount--;
+	}
+	return foundOne;
+      }
+      else{
+	if(debugGenQASMLoops)
+	  errs() << "Ending Recursion\n";
+	return false;
+      }
+    }
+  else if(opOrIndex == 0){ //opOrIndex == 1; i.e. Backtracing for Index    
+    if(btCount>MAX_BT_COUNT) //prevent infinite backtracing
+      return true;
+
+    if(ConstantInt *CI = dyn_cast<ConstantInt>(opd)){
+      tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+      if(debugGenQASMLoops)
+	errs()<<" Found constant index = "<<CI->getValue()<<"\n";
+
+      return true;
+    }      
+
+    if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+      unsigned numOps = pInst->getNumOperands();
+      bool foundOne = false;
+      for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	btCount++;
+	foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),1);
+	btCount--;
+      }
+      return foundOne;
+    }
+
+  }
+  else{ //opOrIndex == 2: backtracing to call inst MeasZ
+    if(debugGenQASMLoops)
+      errs()<<"backtracing for call inst: "<<*opd<<"\n";
+    if(CallInst *endCI = dyn_cast<CallInst>(opd)){
+      if(endCI->getCalledFunction()->getName().find("llvm.Meas") != string::npos){
+	tmpDepQbit[0].argPtr = opd;
+
+	if(debugGenQASMLoops)
+	  errs()<<" Found call inst = "<<*endCI<<"\n";
+	return true;
+      }
+      else{
+	if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	  unsigned numOps = pInst->getNumOperands();
+	  bool foundOne=false;
+	  for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	    btCount++;
+	    foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+	    btCount--;
+	  }
+	  return foundOne;
+	}
+      }
+    }
+    else{
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	unsigned numOps = pInst->getNumOperands();
+	bool foundOne=false;
+	for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	  btCount++;
+	  foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+	  btCount--;
+	}
+	return foundOne;
+      }
+    }
+  }
+  return false;
+}
+
+bool GenQASMLoops::getQbitArrDim(Type *instType, qGateArg* qa)
+{
+  bool myRet = false;
+
+  errs() << "In get_all_dimensions \n";
+
+  if(ArrayType *arrayType = dyn_cast<ArrayType>(instType)) {
+    Type *elementType = arrayType->getElementType();
+    uint64_t arraySize = arrayType->getNumElements();
+    errs() << "Array Size = "<<arraySize << "\n";
+    qa->dimSize[qa->numDim] = arraySize;
+    qa->numDim++;
+
+    if (elementType->isIntegerTy(16)){
+      myRet = true;
+      qa->isQbit = true;
+    }
+    else if (elementType->isIntegerTy(1)){
+      myRet = true;
+      qa->isCbit = true;
+    }
+    else if (elementType->isArrayTy()){
+      myRet |= getQbitArrDim(elementType,qa);
+    }
+    else myRet = false;
+  }
+
+  return myRet;
+
+}
+
+
+void GenQASMLoops::analyzeAllocInst(Function* F, Instruction* pInst){
+  if (AllocaInst *AI = dyn_cast<AllocaInst>(pInst)) {
+    Type *allocatedType = AI->getAllocatedType();
+    
+    if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+      qGateArg tmpQArg;
+
+      Type *elementType = arrayType->getElementType();
+      uint64_t arraySize = arrayType->getNumElements();
+      if (elementType->isIntegerTy(16)){
+	if(debugGenQASMLoops)
+	  errs() << "New QBit Allocation Found: " << AI->getName() <<"\n";
+	vectQbit.push_back(AI);
+	tmpQArg.isQbit = true;
+	tmpQArg.argPtr = AI;
+	tmpQArg.numDim = 1;
+	tmpQArg.dimSize[0] = arraySize;
+	tmpQArg.valOrIndex = arraySize;
+	(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	(qbitsInitInFunc.find(F))->second.push_back(tmpQArg);	
+      }
+      
+      else if (elementType->isIntegerTy(1)){
+	if(debugGenQASMLoops)
+	  errs() << "New CBit Allocation Found: " << AI->getName() <<"\n";
+	vectQbit.push_back(AI); //Cbit added here
+	tmpQArg.isCbit = true;
+	tmpQArg.argPtr = AI;
+	tmpQArg.numDim = 1;
+	tmpQArg.dimSize[0] = arraySize;
+	tmpQArg.valOrIndex = arraySize;
+	(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	(qbitsInitInFunc.find(F))->second.push_back(tmpQArg);	
+      }
+
+      else if(elementType->isArrayTy()){
+	  errs() << "Multidimensional array\n";
+
+	  tmpQArg.dimSize[0] = arraySize;
+	  tmpQArg.numDim++;
+	  tmpQArg.valOrIndex = arraySize;
+
+	  //recurse on multi-dimensional array
+	  bool isQAlloc = getQbitArrDim(elementType,&tmpQArg);
+
+	  if(isQAlloc){
+	    vectQbit.push_back(AI);
+	    tmpQArg.argPtr = AI;
+	    (qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	    (qbitsInitInFunc.find(F))->second.push_back(tmpQArg);
+
+	    if(debugGenQASMLoops)
+	      print_qgateArg(tmpQArg);
+	  }	  
+      }
+
+    }
+    else if(allocatedType->isPointerTy()){
+      
+      /*Note: this is necessary if -mem2reg is not run on LLVM IR before.
+	Eg without -mem2reg
+	module(i8* %q){
+	%q.addr = alloca i8*, align 8
+	...
+	}
+	qbit q.addr must be mapped to argument q. Hence the following code.
+	If it is known that -O1 will be run, then this can be removed.
+      */
+      
+      Type *elementType = allocatedType->getPointerElementType();
+      if(debugGenQASMLoops)
+	errs() << "\tIs a Pointer of Type: " << *elementType << "\n";
+      
+      if (elementType->isIntegerTy(16)){
+	vectQbit.push_back(AI);
+	
+	qGateArg tmpQArg;
+	tmpQArg.isPtr = true;
+	tmpQArg.isQbit = true;
+	tmpQArg.argPtr = AI;
+	
+	(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	
+	std::string argName = AI->getName();
+	unsigned pos = argName.find(".addr");
+	std::string argName2 = argName.substr(0,pos);
+
+	//find argName2 in funcArgList - avoid printing out qbit declaration twice
+	std::map<Function*, vector<qGateArg> >::iterator mIter = funcArgList.find(F);
+	if(mIter != funcArgList.end()){
+	  bool foundit = false;
+	  for(vector<qGateArg>::iterator vParamIter = (*mIter).second.begin();(vParamIter!=(*mIter).second.end() && !foundit);++vParamIter){
+	    if((*vParamIter).argPtr->getName() == argName2){ 
+	      foundit = true;
+	    }
+	  }
+	  if(!foundit) //do not add duplicate declaration
+	    (qbitsInitInFunc.find(F))->second.push_back(tmpQArg);
+	}
+      }
+    }
+    return;
+  }
+
+}
+
+void GenQASMLoops::analyzeCallInst(Function* F, Instruction* pInst){
+  if(CallInst *CI = dyn_cast<CallInst>(pInst))
+    {
+      if(debugGenQASMLoops)      
+	errs() << "Call inst: " << CI->getCalledFunction()->getName() << "\n";
+
+      if(CI->getCalledFunction()->getName() == "store_cbit"){	//trace return values
+	qGateArg tmpQGateArg1;
+	tmpQGateArg1.isCbit = true;
+	tmpDepQbit.push_back(tmpQGateArg1);
+	backtraceOperand(CI->getArgOperand(0),2); //value Operand
+	Value* rtnVal = tmpDepQbit[0].argPtr;
+	tmpDepQbit.clear();
+
+	qGateArg tmpQGateArg2;
+	tmpQGateArg2.isCbit = true;
+	tmpQGateArg2.isPtr = true;
+	tmpDepQbit.push_back(tmpQGateArg2);	
+	backtraceOperand(CI->getArgOperand(1),0); //pointer Operand
+
+	//insert info in map here
+	mapInstRtn[rtnVal] = tmpDepQbit[0];
+
+	tmpDepQbit.clear();
+	return;
+      }
+
+
+      if(((CI->getCalledFunction()->getName()).find("qasmRepLoopStart")!=string::npos) || ((CI->getCalledFunction()->getName()).find("qasmRepLoopStart")!=string::npos)){
+	vRemoveInst.push_back(CI);       
+      }
+
+      
+      bool tracked_all_operands = true;
+      
+      for(unsigned iop=0;iop<CI->getNumArgOperands();iop++){
+	tmpDepQbit.clear();
+	
+	qGateArg tmpQGateArg;
+	btCount=0;
+	
+	if(debugGenQASMLoops)
+	  errs() << "Call inst operand num: " << iop << "\n";
+	
+	tmpQGateArg.argNum = iop;
+	
+	
+	if(isa<UndefValue>(CI->getArgOperand(iop))){
+	  //errs() << "WARNING: LLVM IR code has UNDEF values. \n";
+	  tmpQGateArg.isUndef = true;	
+	  //exit(1);
+	  //assert(0 && "LLVM IR code has UNDEF values. Aborting...");
+	}
+	
+	Type* argType = CI->getArgOperand(iop)->getType();
+	if(argType->isPointerTy()){
+	  tmpQGateArg.isPtr = true;
+	  Type *argElemType = argType->getPointerElementType();
+	  if(argElemType->isIntegerTy(16))
+	    tmpQGateArg.isQbit = true;
+	  if(argElemType->isIntegerTy(1))
+	    tmpQGateArg.isCbit = true;
+	}
+	else if(argType->isIntegerTy(16)){
+	  tmpQGateArg.isQbit = true;
+	  tmpQGateArg.valOrIndex = 0;	 
+	}	  	
+	else if(argType->isIntegerTy(1)){
+	  tmpQGateArg.isCbit = true;
+	  tmpQGateArg.valOrIndex = 0;	 
+	}	  	
+	
+	//check if argument is constant int	
+	if(ConstantInt *CInt = dyn_cast<ConstantInt>(CI->getArgOperand(iop))){
+	  tmpQGateArg.valOrIndex = CInt->getZExtValue();
+	  if(debugGenQASMLoops){
+	    errs()<<" Found constant argument = "<<CInt->getValue()<<"\n";
+	  }
+	}
+	
+
+	//check if argument is constant float	
+	if(ConstantFP *CFP = dyn_cast<ConstantFP>(CI->getArgOperand(iop))){
+	  tmpQGateArg.val = CFP->getValueAPF().convertToDouble();
+	  tmpQGateArg.isDouble = true;
+	  if(debugGenQASMLoops){
+	    errs()<<" Call Inst = "<<*CI<<"\n";
+	    errs()<<" Found constant double argument = "<<tmpQGateArg.val<<"\n";
+	  }
+	}
+
+
+	tmpDepQbit.push_back(tmpQGateArg);
+	
+	tracked_all_operands &= backtraceOperand(CI->getArgOperand(iop),0);
+	
+	if(tmpDepQbit.size()>0){
+	  if(debugGenQASMLoops)
+	    print_qgateArg(tmpDepQbit[0]);
+	  
+	  allDepQbit.push_back(tmpDepQbit[0]);
+	  assert(tmpDepQbit.size() == 1 && "tmpDepQbit SIZE GT 1");
+	  tmpDepQbit.clear();
+	}
+	
+      }
+                  
+      //form info packet
+      FnCall qInfo;
+      qInfo.func = CI->getCalledFunction();
+      qInfo.instPtr = CI;
+      
+      if(allDepQbit.size() > 0){
+	if(debugGenQASMLoops)
+	  {
+	    errs() << "\nCall inst: " << CI->getCalledFunction()->getName();	    
+	    errs() << ": Found all arguments: ";       
+	    for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+	      if(allDepQbit[vb].argPtr)
+		errs() << allDepQbit[vb].argPtr->getName() <<" ";
+	      else
+		errs() << allDepQbit[vb].valOrIndex <<" ";
+	    }
+	    errs()<<"\n";
+	  }
+	
+	//populate vector of passed qubit arguments
+	for(unsigned int vb=0; vb<allDepQbit.size(); vb++)
+	  qInfo.qArgs.push_back(allDepQbit[vb]);
+	
+      }
+      
+      map<Function*, vector<FnCall> >::iterator mvdpit = mapFunction.find(F);	
+      (*mvdpit).second.push_back(qInfo);      
+
+      return;      
+    }
+}
+
+
+void GenQASMLoops::analyzeInst(Function* F, Instruction* pInst){
+  if(debugGenQASMLoops)
+    errs() << "--Processing Inst: "<<*pInst << '\n';
+
+  //analyzeAllocInst(F,pInst);
+  analyzeCallInst(F,pInst);
+    
+  if(debugGenQASMLoops)
+    {
+      errs() << "Opcode: "<<pInst->getOpcodeName() << "\n";
+      
+      unsigned numOps = pInst->getNumOperands();
+      errs() << "Num Operands: " << numOps << ": ";
+      
+      for(unsigned iop=0;iop<numOps;iop++){
+	errs() << pInst->getOperand(iop)->getName() << "; ";
+      }
+      errs() << "\n";		
+      return;
+    }
+    
+  return;
+}
+
+void GenQASMLoops::printFuncHeader(Function* F)
+{
+
+  map<Function*, vector<qGateArg> >::iterator mpItr;
+  map<Function*, vector<qGateArg> >::iterator mpItr2;
+  map<Function*, vector<qGateArg> >::iterator mvpItr;
+
+  mpItr = qbitsInFunc.find(F);
+
+  //print name of function
+  errs()<<"\nmodule "<<F->getName();
+  
+  //print arguments of function
+  mpItr2=funcArgList.find(F);    
+  errs()<<" ( ";    
+  unsigned tmp_num_elem = (*mpItr2).second.size();
+  
+  if(tmp_num_elem > 0){
+    for(unsigned tmp_i=0;tmp_i<tmp_num_elem - 1;tmp_i++){
+      
+      qGateArg tmpQA = (*mpItr2).second[tmp_i];
+      
+      if(debugGenQASMLoops)
+	print_qgateArg(tmpQA);
+      
+      if(tmpQA.isQbit)
+	errs()<<"qbit";
+      else if(tmpQA.isCbit)
+	errs()<<"cbit";
+      else{
+	Type* argTy = tmpQA.argPtr->getType();
+	if(argTy->isDoubleTy()) errs() << "double";
+	else if(argTy->isFloatTy()) errs() << "float";
+	else
+	  errs()<<"UNRECOGNIZED "<<argTy<<" ";
+      }
+      
+      if(tmpQA.isPtr)
+	errs()<<"*";	  
+      
+      errs()<<" "<<printVarName(tmpQA.argPtr->getName())<<" , ";
+    }
+    
+    if(debugGenQASMLoops)
+      print_qgateArg((*mpItr2).second[tmp_num_elem-1]);
+    
+    
+    if(((*mpItr2).second[tmp_num_elem-1]).isQbit)
+      errs()<<"qbit";
+    else if(((*mpItr2).second[tmp_num_elem-1]).isCbit)
+      errs()<<"cbit";
+    else{
+      Type* argTy = ((*mpItr2).second[tmp_num_elem-1]).argPtr->getType();
+      if(argTy->isDoubleTy()) errs() << "double";
+      else if(argTy->isFloatTy()) errs() << "float";
+      else
+	errs()<<"UNRECOGNIZED "<<argTy<<" ";
+    }
+    
+    if(((*mpItr2).second[tmp_num_elem-1]).isPtr)
+      errs()<<"*";
+    
+    errs() <<" "<<printVarName(((*mpItr2).second[tmp_num_elem-1]).argPtr->getName());
+  }
+  
+  errs()<<" ) {\n ";   
+  
+  //print qbits declared in function
+  mvpItr=qbitsInitInFunc.find(F);	    
+  for(vector<qGateArg>::iterator vvit=(*mvpItr).second.begin(),vvitE=(*mvpItr).second.end();vvit!=vvitE;++vvit)
+    {	
+      if((*vvit).isQbit)
+	errs()<<"\tqbit "<<printVarName((*vvit).argPtr->getName());
+      if((*vvit).isCbit)
+	errs()<<"\tcbit "<<printVarName((*vvit).argPtr->getName());
+
+      //if only single-dimensional qbit arrays expected
+      //errs()<<"["<<(*vvit).valOrIndex<<"];\n ";
+
+      //if n-dimensional qbit arrays expected 
+      for(int ndim = 0; ndim < (*vvit).numDim; ndim++)
+	errs()<<"["<<(*vvit).dimSize[ndim]<<"]";
+      errs() << ";\n";
+    }
+  
+}
+  
+void GenQASMLoops::genQASM(Function* F)
+{
+  map<Function*, vector<qGateArg> >::iterator mpItr;
+  map<Function*, vector<qGateArg> >::iterator mpItr2;
+  map<Function*, vector<qGateArg> >::iterator mvpItr;
+  
+  mpItr = qbitsInFunc.find(F);
+  if((*mpItr).second.size()>0){
+    
+    
+    //print gates in function
+    map<Function*, vector<FnCall> >::iterator mfvIt = mapFunction.find(F);
+    for(unsigned mIndex=0;mIndex<(*mfvIt).second.size();mIndex++){
+
+      
+      string fToPrint = (*mfvIt).second[mIndex].func->getName();
+//repeat loop calls
+      //errs() << "To print = " << fToPrint << "\n";
+      if(fToPrint.find("qasmRepLoopStart")!=string::npos){
+	string repLoopStr = fToPrint.substr(16);
+	forallStr = fToPrint.substr(23);
+	errs() << repLoopStr << " BEGIN \n";
+      }
+      else if(fToPrint.find("qasmRepLoopEnd")!=string::npos){
+	string repLoopStr = fToPrint.substr(14);
+	forallStr = "";
+	errs() << "END \n";
+      } //end of repeat loop calls
+      else if((*mfvIt).second[mIndex].qArgs.size()>0){
+
+	string fToPrint = (*mfvIt).second[mIndex].func->getName();
+	if(fToPrint.find("llvm.") != string::npos)
+	  fToPrint = fToPrint.substr(5);
+	errs()<<"\t";
+
+	//print return operand before printing MeasZ
+	if(fToPrint.find("Meas") != string::npos){
+	  //get inst ptr
+	  Value* thisInstPtr = (*mfvIt).second[mIndex].instPtr;
+	  //find inst in mapInstRtn
+	  map<Value*, qGateArg>::iterator mvq = mapInstRtn.find(thisInstPtr);
+	  if(mvq!=mapInstRtn.end()){
+	    errs()<<printVarName(((*mvq).second).argPtr->getName());
+	    if(((*mvq).second).isPtr)
+	      errs()<<"["<<((*mvq).second).valOrIndex<<"]";
+	    errs()<<" = ";
+	  }	  
+	}
+
+
+	errs()<<fToPrint<<" ( ";
+
+	//print all but last argument
+	for(vector<qGateArg>::iterator vpIt=(*mfvIt).second[mIndex].qArgs.begin(), vpItE=(*mfvIt).second[mIndex].qArgs.end();vpIt!=vpItE-1;++vpIt)
+	  {
+	    if((*vpIt).isUndef)
+	      errs() << " UNDEF ";
+	    else{
+	      if((*vpIt).isQbit || (*vpIt).isCbit){
+		errs()<<printVarName((*vpIt).argPtr->getName());
+		if(!((*vpIt).isPtr)){		  
+		  //if only single-dimensional qbit arrays expected
+		  //--if((*vpIt).numDim == 0)
+		  //errs()<<"["<<(*vpIt).valOrIndex<<"]";
+		  //--else
+		    //if n-dimensional qbit arrays expected 
+		  for(int ndim = 0; ndim < (*vpIt).numDim; ndim++){
+		    int dimVar = (*vpIt).dimSize[ndim];
+		    //errs()<<"["<<(*vpIt).dimSize[ndim]<<"]";
+		    if(dimVar == -2){
+		      //errs()<<"[ i ]";
+		      errs() << " [ " << forallStr << " ] ";
+		    }
+		    else
+		      errs()<<"["<<dimVar<<"]";
+		  }
+		}
+	      }
+	      else{
+		//assert(!(*vpIt).isPtr); 
+		if((*vpIt).isPtr) //NOTE: not expecting non-quantum pointer variables as arguments to quantum functions. If they exist, then print out name of variable
+		  errs() << " UNRECOGNIZED ";
+		else if((*vpIt).isDouble)
+		  errs() << (*vpIt).val;
+		else
+		  errs()<<(*vpIt).valOrIndex;	      
+	      }
+	    }	    	    
+	    errs()<<" , ";
+	  }
+
+	//print last element	
+	qGateArg tmpQA = (*mfvIt).second[mIndex].qArgs.back();
+
+	if(tmpQA.isUndef)
+	  errs() << " UNDEF ";
+	else{
+	  if(tmpQA.isQbit || tmpQA.isCbit){
+	    errs()<<printVarName(tmpQA.argPtr->getName());
+	    if(!(tmpQA.isPtr)){
+	      //if only single-dimensional qbit arrays expected
+	      //--if(tmpQA.numDim == 0)
+	      //errs()<<"["<<tmpQA.valOrIndex<<"]";
+	      //--else
+		//if n-dimensional qbit arrays expected 
+	      for(int ndim = 0; ndim < tmpQA.numDim; ndim++){
+		//errs()<<"["<<tmpQA.dimSize[ndim]<<"]";	
+		int dimVar = tmpQA.dimSize[ndim];	
+		if(dimVar == -2){
+		  //errs()<<"[ i ]";
+		  errs() << " [ " << forallStr << " ] ";
+		}	
+		else
+		  errs()<<"["<<dimVar<<"]";	
+	      }      	      	      
+	    }
+	  }
+	  else{
+	    //assert(!tmpQA.isPtr); //NOTE: not expecting non-quantum pointer variables as arguments to quantum functions. If they exist, then print out name of variable
+	    if(tmpQA.isPtr)
+	      errs() << " UNRECOGNIZED ";
+	    else if(tmpQA.isDouble) 
+	      errs() << tmpQA.val;
+	    else
+	      errs()<<tmpQA.valOrIndex;	    
+	  }
+	  
+	}
+	errs()<<" );\n ";	      
+      }      
+    }
+    errs()<<"}\n";
+  }
+}
+
+
+void GenQASMLoops::getFunctionArguments(Function* F)
+{
+  //std::vector<unsigned> qGateArgs;  
+
+  for(Function::arg_iterator ait=F->arg_begin();ait!=F->arg_end();++ait)
+    {    
+      std::string argName = (ait->getName()).str();
+      Type* argType = ait->getType();
+      unsigned int argNum=ait->getArgNo();         
+
+      qGateArg tmpQArg;
+      tmpQArg.argPtr = ait;
+      tmpQArg.argNum = argNum;
+
+      if(argType->isPointerTy()){
+	if(debugGenQASMLoops)
+	  errs()<<"Argument Type: " << *argType <<"\n";
+
+	tmpQArg.isPtr = true;
+
+	Type *elementType = argType->getPointerElementType();
+	if (elementType->isIntegerTy(16)){
+	  tmpQArg.isQbit = true;
+	  vectQbit.push_back(ait);
+	  (qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	  (funcArgList.find(F))->second.push_back(tmpQArg);
+	}
+	else if (elementType->isIntegerTy(1)){
+	  tmpQArg.isCbit = true;
+	  vectQbit.push_back(ait);
+	  (qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	  (funcArgList.find(F))->second.push_back(tmpQArg);
+	}
+      }
+      else if (argType->isIntegerTy(16)){
+	tmpQArg.isQbit = true;
+	vectQbit.push_back(ait);
+	(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	(funcArgList.find(F))->second.push_back(tmpQArg);
+      }
+      else if (argType->isIntegerTy(1)){
+	tmpQArg.isCbit = true;
+	vectQbit.push_back(ait);
+	(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	(funcArgList.find(F))->second.push_back(tmpQArg);
+      }
+      else if(argType->isDoubleTy())     
+	(funcArgList.find(F))->second.push_back(tmpQArg);
+
+      if(debugGenQASMLoops)
+	print_qgateArg(tmpQArg);
+    }
+}
+
+// run - Find datapaths for qubits
+bool GenQASMLoops::runOnModule(Module &M) {
+  CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+  unsigned sccNum = 0;
+  forallStr = "";
+
+  errs() << "-------QASM Generation Pass:\n";
+
+  for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode),
+         E = scc_end(rootNode); sccIb != E; ++sccIb)
+    {
+      const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+
+      if(debugGenQASMLoops)
+	errs() << "\nSCC #" << ++sccNum << " : ";      
+
+      for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(),
+	     E = nextSCC.end(); nsccI != E; ++nsccI)
+	{
+	  Function *F=(*nsccI)->getFunction();	  
+	  
+	  if(F && !F->isDeclaration()){
+	    if(debugGenQASMLoops)
+	    errs() << "Processing Function:" << F->getName() <<" \n ";
+
+	    //initialize map structures for this function
+	    vector<qGateArg> myQIFVec, myQIFVec1, myQIFVec2;
+	    qbitsInFunc[F] = myQIFVec;
+	    qbitsInitInFunc[F] = myQIFVec1;
+	    funcArgList[F] = myQIFVec2;
+
+	    std::vector<FnCall> myFuncMapVec;
+	    mapFunction[F] = myFuncMapVec;
+
+	    getFunctionArguments(F);
+
+	    //visit Alloc Insts in func and find if function is quantum or classical function
+
+	    for(inst_iterator instIb = inst_begin(F),instIe=inst_end(F); instIb!=instIe;++instIb){
+
+	      Instruction *pInst = &*instIb; // Grab pointer to instruction reference	      
+
+	      if(debugGenQASMLoops)
+		errs() << "\n Processing Inst: "<<*pInst << "\n";
+
+	      analyzeAllocInst(F,pInst);
+	    }
+
+	    map<Function*, vector<qGateArg> >::iterator mpItr = qbitsInFunc.find(F);
+	    if((*mpItr).second.size()>0){ //Is Quantum Function
+	      printFuncHeader(F);
+	    
+	      for(inst_iterator instIb = inst_begin(F),instIe=inst_end(F); instIb!=instIe;++instIb){
+
+		Instruction *pInst = &*instIb; // Grab pointer to instruction reference	      
+		allDepQbit.clear();
+		
+		if(debugGenQASMLoops)
+		  errs() << "\n Processing Inst: "<<*pInst << "\n";
+		
+		analyzeInst(F,pInst); //spatil: need a bool return type?
+	      }
+	      
+	      genQASM(F);
+	      
+	    }
+	    
+	  }
+	  else{
+	    if(debugGenQASMLoops)
+	      errs() << "WARNING: Ignoring external node or dummy function.";
+	  }
+	  
+	}
+      if (nextSCC.size() == 1 && sccIb.hasLoop())
+	errs() << " (Has self-loop).";
+    }
+  errs()<<"\n--------End of QASM generation";
+  errs() << "\n";
+
+  
+  return false;
+}
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GenRKQC.cpp llvm/lib/Transforms/Scaffold/GenRKQC.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GenRKQC.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/GenRKQC.cpp	2017-10-12 11:09:31.093119606 +0800
@@ -0,0 +1,421 @@
+// Scaffold
+// This pass implements a fault tolerant implementation of Toffoli gates
+//
+
+#include <cstdlib>
+#include <cstdio>
+
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/Constants.h"
+#include "llvm/Function.h"
+#include "llvm/Instructions.h"
+#include "llvm/Intrinsics.h"
+#include "llvm/LLVMContext.h"
+#include "llvm/Pass.h"
+#include "llvm/Argument.h"
+#include "llvm/Module.h"
+
+#include "llvm/Support/CallSite.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/InstVisitor.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/IRBuilder.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+
+using namespace llvm;
+
+namespace {
+	// We need to use a ModulePass in order to create new Functions
+	struct GenRKQC : public ModulePass {
+		static char ID;
+		GenRKQC() : ModulePass(ID) {}
+
+		struct RKQCVisitor : public InstVisitor<RKQCVisitor> {
+			// The Toffoli implementation will be a Function in M's FunctionList
+			Module *M;
+			// The constructor is called once per module (in runOnModule)
+			RKQCVisitor(Module *module) : M(module) {}
+
+			Value* createAncilla(std::string& name, BasicBlock* BB ){
+				std::string anc_name = "ancilla_"+name;
+				Type *abit_type = IntegerType::getInt8Ty(getGlobalContext());
+        		Constant *val = ConstantInt::get(Type::getInt32Ty(getGlobalContext()), 1, false);       
+				Value* Idx[2];	  
+				Idx[0] = Constant::getNullValue(Type::getInt32Ty(getGlobalContext()));  
+				Idx[1] = ConstantInt::get(Type::getInt32Ty(getGlobalContext()),0);
+				ArrayType *arrayType = ArrayType::get(abit_type, 1);
+				AllocaInst *anc = new AllocaInst(arrayType,anc_name, BB);
+				anc->setAlignment(8);
+        		Value *intArrPtr = GetElementPtrInst::CreateInBounds(anc,Idx,"",BB);
+				Value *value = new LoadInst(intArrPtr, "", BB);
+				return value;
+			}
+
+			void create_a_swap_b(CallInst& I, Function* RKQC_Func, std::string& rkqcName){
+				if(!RKQC_Func){
+					std::vector<Type*> ArgTypes(2);
+					for(int i=0;i<2;i++) ArgTypes[i] = I.getArgOperand(i)->getType();//Type::getInt16Ty(getGlobalContext());
+					FunctionType *FuncType = FunctionType::get(Type::getVoidTy(getGlobalContext()),
+						ArrayRef<Type*>(ArgTypes), false);
+					RKQC_Func = Function::Create(FuncType,GlobalVariable::ExternalLinkage,rkqcName,M);
+					RKQC_Func->addFnAttr(Attribute::AlwaysInline);
+
+					Function::arg_iterator arg_it = RKQC_Func->arg_begin();
+					Value *Target0 = arg_it;
+					Type *Type0 = arg_it->getType();
+					arg_it++;
+					Value *Target1 = arg_it;
+					Type *Type1 = arg_it->getType();
+
+					Target0->setName("target0");
+					Target1->setName("target1");
+
+
+					BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "", RKQC_Func, 0);
+
+					std::vector<Type*> Types0; Types0.push_back(Type0); Types0.push_back(Type1);
+					std::vector<Type*> Types1; Types1.push_back(Type1); Types1.push_back(Type0);
+					std::vector<Value*> T0T1; T0T1.push_back(Target0); T0T1.push_back(Target1);
+					std::vector<Value*> T1T0; T1T0.push_back(Target1); T1T0.push_back(Target0);
+
+					Function* gate_CNOT_T0T1 = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(Types0));
+					Function* gate_CNOT_T1T0 = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(Types1));
+
+					CallInst::Create(gate_CNOT_T0T1, ArrayRef<Value*>(T0T1), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_T1T0, ArrayRef<Value*>(T1T0), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_T0T1, ArrayRef<Value*>(T0T1), "", BB)->setTailCall();
+
+					ReturnInst::Create(getGlobalContext(), 0, BB);
+				}
+				std::vector<Value*>  Args(2);
+				for (int i=0; i<3; i++) Args[i] = I.getArgOperand(i);
+				BasicBlock::iterator ii(&I);
+				ReplaceInstWithInst(I.getParent()->getInstList(), ii,
+					CallInst::Create(RKQC_Func, ArrayRef<Value*>(Args)));
+			}
+
+
+			void create_assign_value_of_b_to_a(CallInst& I, Function* RKQC_Func, std::string& rkqcName){
+				if(!RKQC_Func){
+					std::vector<Type*> ArgTypes(2);
+					ArgTypes[0] = Type::getInt16Ty(getGlobalContext());
+					ArgTypes[1] = Type::getInt16Ty(getGlobalContext());
+					FunctionType *FuncType = FunctionType::get(Type::getVoidTy(getGlobalContext()),
+						ArrayRef<Type*>(ArgTypes),false);
+					RKQC_Func = Function::Create(FuncType,GlobalVariable::ExternalLinkage,rkqcName,M);
+					RKQC_Func->addFnAttr(Attribute::AlwaysInline);
+
+					Function::arg_iterator arg_it = RKQC_Func->arg_begin();
+					Value *Target = arg_it;
+					Type *Type0 = arg_it->getType();
+					arg_it++;
+					Value *Control = arg_it;
+					Type *Type1 = arg_it->getType();
+
+					Target->setName("target");
+					Control->setName("control");
+
+
+					BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "", RKQC_Func, 0);
+					std::string name = "zg";
+					Value* ancilla = createAncilla(name,BB);	
+					Type* Type_A = ancilla->getType();
+
+					std::vector<Value*> TA; TA.push_back(Target); TA.push_back(ancilla);
+					std::vector<Type*> TA_V; TA_V.push_back(Type0); TA_V.push_back(Type_A);
+
+					std::vector<Value*> AT; AT.push_back(ancilla); AT.push_back(Target);
+					std::vector<Type*> AT_V; AT_V.push_back(Type_A); AT_V.push_back(Type0);
+					
+					std::vector<Value*> BA; BA.push_back(Control); BA.push_back(Target);
+					std::vector<Type*> BA_V; BA_V.push_back(Type1); BA_V.push_back(Type0);
+					
+					Function* gate_CNOT_TA = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(TA_V));
+					Function* gate_CNOT_AT = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(AT_V));
+					Function* gate_CNOT_BA = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(BA_V));
+
+
+					CallInst::Create(gate_CNOT_TA, ArrayRef<Value*>(TA), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_AT, ArrayRef<Value*>(AT), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_BA, ArrayRef<Value*>(BA), "", BB)->setTailCall();
+					ReturnInst::Create(getGlobalContext(), 0, BB);
+				}
+				std::vector<Value*>  Args(2);
+				for (int i=0; i<2; i++) Args[i] = I.getArgOperand(i);
+				BasicBlock::iterator ii(&I);
+				ReplaceInstWithInst(I.getParent()->getInstList(), ii, CallInst::Create(RKQC_Func, ArrayRef<Value*>(Args)));
+			}
+
+			void create_assign_value_of_0_to_a(CallInst& I, Function* RKQC_Func, std::string& rkqcName){
+				if(!RKQC_Func){
+					std::vector<Type*> ArgTypes(2);
+					ArgTypes[0] = Type::getInt16Ty(getGlobalContext());
+					ArgTypes[1] = Type::getInt32Ty(getGlobalContext());
+					FunctionType *FuncType = FunctionType::get(Type::getVoidTy(getGlobalContext()),
+						ArrayRef<Type*>(ArgTypes),false);
+					RKQC_Func = Function::Create(FuncType,GlobalVariable::ExternalLinkage,rkqcName,M);
+					RKQC_Func->addFnAttr(Attribute::AlwaysInline);
+
+					Function::arg_iterator arg_it = RKQC_Func->arg_begin();
+					Value *Target = arg_it;
+					Type *Target_T = arg_it->getType();
+
+					Target->setName("target");
+
+
+					BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "", RKQC_Func, 0);
+
+					std::string name = "zero_zero";
+					Value* Control = createAncilla(name,BB);	
+					Type* Control_T = Control->getType();
+					std::string name2= "zero_garbage";
+					Value* ancilla = createAncilla(name2,BB);	
+					Type* ancilla_T = ancilla->getType();
+
+					std::vector<Value*> TA; TA.push_back(Target); TA.push_back(ancilla);
+					std::vector<Type*> TA_V; TA_V.push_back(Target_T); TA_V.push_back(ancilla_T);
+
+					std::vector<Value*> AT; AT.push_back(ancilla); AT.push_back(Target);
+					std::vector<Type*> AT_V; AT_V.push_back(ancilla_T); AT_V.push_back(Target_T);
+
+					std::vector<Value*> BA; BA.push_back(Control); BA.push_back(Target);
+					std::vector<Type*> BA_V; BA_V.push_back(Control_T); BA_V.push_back(Target_T);
+
+					
+					Function* gate_CNOT_TA = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(TA_V));
+					Function* gate_CNOT_AT = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(AT_V));
+					Function* gate_CNOT_BA = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(BA_V));
+					
+					CallInst::Create(gate_CNOT_TA, ArrayRef<Value*>(TA), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_AT, ArrayRef<Value*>(AT), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_BA, ArrayRef<Value*>(BA), "", BB)->setTailCall();
+					ReturnInst::Create(getGlobalContext(), 0, BB);
+  				}
+				std::vector<Value*>  Args(2);
+				for (int i=0; i<2; i++) Args[i] = I.getArgOperand(i);
+//				Args[0] = I.getArgOperand(0);
+				BasicBlock::iterator ii(&I);
+				ReplaceInstWithInst(I.getParent()->getInstList(), ii, CallInst::Create(RKQC_Func, ArrayRef<Value*>(Args)));
+			}
+
+			void create_assign_value_of_1_to_a(CallInst& I, Function* RKQC_Func, std::string& rkqcName){
+				if(!RKQC_Func){
+					std::vector<Type*> ArgTypes(2);
+					ArgTypes[0] = Type::getInt16Ty(getGlobalContext());
+					ArgTypes[1] = Type::getInt32Ty(getGlobalContext());
+					FunctionType *FuncType = FunctionType::get(Type::getVoidTy(getGlobalContext()),
+						ArrayRef<Type*>(ArgTypes),false);
+					RKQC_Func = Function::Create(FuncType,GlobalVariable::ExternalLinkage,rkqcName,M);
+					RKQC_Func->addFnAttr(Attribute::AlwaysInline);
+
+					Function::arg_iterator arg_it = RKQC_Func->arg_begin();
+					Value *Target = arg_it;
+					Type *Target_T = arg_it->getType();
+
+					Target->setName("target");
+
+					BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "", RKQC_Func, 0);
+
+					std::string name = "one_one";
+					Value* Control = createAncilla(name,BB);	
+					Type* Control_T = Control->getType();
+					std::string name2 = "zero_garbage";
+					Value* ancilla = createAncilla(name2,BB);	
+					Type* ancilla_T = ancilla->getType();
+
+
+					std::vector<Value*> TA; TA.push_back(Target); TA.push_back(ancilla);
+					std::vector<Type*> TA_V; TA_V.push_back(Target_T); TA_V.push_back(ancilla_T);
+
+					std::vector<Value*> AT; AT.push_back(ancilla); AT.push_back(Target);
+					std::vector<Type*> AT_V; AT_V.push_back(ancilla_T); AT_V.push_back(Target_T);
+
+					std::vector<Value*> BA; BA.push_back(Control); BA.push_back(Target);
+					std::vector<Type*> BA_V; BA_V.push_back(Control_T); BA_V.push_back(Target_T);
+
+					Function* gate_CNOT_TA = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(TA_V));
+					Function* gate_CNOT_AT = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(AT_V));
+					Function* gate_CNOT_BA = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(BA_V));
+
+					CallInst::Create(gate_CNOT_TA, ArrayRef<Value*>(TA), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_AT, ArrayRef<Value*>(AT), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_BA, ArrayRef<Value*>(BA), "", BB)->setTailCall();
+
+					ReturnInst::Create(getGlobalContext(), 0, BB);
+				}
+				std::vector<Value*>  Args(2);
+				for (int i=0; i<2; i++) Args[i] = I.getArgOperand(i);
+				BasicBlock::iterator ii(&I);
+				ReplaceInstWithInst(I.getParent()->getInstList(), ii, CallInst::Create(RKQC_Func, ArrayRef<Value*>(Args)));
+			}
+
+
+
+			void create_a_eq_a_plus_b(CallInst& I, Function* RKQC_Func, std::string& rkqcName){
+				if(!RKQC_Func){
+					std::vector<Type*> ArgTypes(3);
+					ArgTypes[0] = Type::getInt16Ty(getGlobalContext());
+					ArgTypes[1] = Type::getInt16Ty(getGlobalContext());
+					ArgTypes[2] = Type::getInt32Ty(getGlobalContext());
+					FunctionType *FuncType = FunctionType::get(Type::getVoidTy(getGlobalContext()),
+						ArrayRef<Type*>(ArgTypes),false);
+					RKQC_Func = Function::Create(FuncType,GlobalVariable::ExternalLinkage,rkqcName,M);
+					RKQC_Func->addFnAttr(Attribute::AlwaysInline);
+
+					Function::arg_iterator arg_it = RKQC_Func->arg_begin();
+					Value *A = arg_it;
+					Type *A_T = arg_it->getType();
+					arg_it++;
+					Value *B = arg_it;
+					Type *B_T = arg_it->getType();
+
+					A->setName("target");
+					B->setName("control");
+
+					BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "", RKQC_Func, 0);
+					std::string ancilla_garbage = "zg";
+					std::string ancilla_zero = "zz";
+					Value* ancillaG = createAncilla(ancilla_garbage,BB);	
+					Type *ancillaG_T = ancillaG->getType();
+					Value* ancillaZ = createAncilla(ancilla_zero,BB);	
+					Type *ancillaZ_T = ancillaZ->getType();
+
+					// Main Addition Circuit
+					std::vector<Value*> AG; AG.push_back(A); AG.push_back(ancillaG);
+					std::vector<Type*> AG_T; AG_T.push_back(A_T); AG_T.push_back(ancillaG_T);
+
+					std::vector<Value*> BZ; BZ.push_back(B); BZ.push_back(ancillaZ);
+					std::vector<Type*> BZ_T; BZ_T.push_back(B_T); BZ_T.push_back(ancillaZ_T);
+
+					std::vector<Value*> AB; AB.push_back(A); AB.push_back(B);
+					std::vector<Type*> AB_T; AB_T.push_back(A_T); AB_T.push_back(B_T);
+
+					std::vector<Value*> BGA; BGA.push_back(B); BGA.push_back(ancillaG); BGA.push_back(A);
+					std::vector<Type*> BGA_T; BGA_T.push_back(B_T); BGA_T.push_back(ancillaG_T); BGA_T.push_back(A_T);
+
+					std::vector<Value*> ZG; ZG.push_back(ancillaZ); ZG.push_back(ancillaG);
+					std::vector<Type*> ZG_T; ZG_T.push_back(ancillaZ_T); ZG_T.push_back(ancillaG_T);
+
+					std::vector<Value*> ZB; ZB.push_back(ancillaZ); ZB.push_back(B);
+					std::vector<Type*> ZB_T; ZB_T.push_back(ancillaZ_T); ZB_T.push_back(B_T);
+
+					// Register Renaming Circuit
+					std::vector<Value*> GA; GA.push_back(ancillaG); GA.push_back(A);
+					std::vector<Type*> GA_T; GA_T.push_back(ancillaG_T); GA_T.push_back(A_T);
+
+					Function* gate_CNOT_qbit_anc = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(AG_T));
+					Function* gate_CNOT_qbit_qbit = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(AB_T));
+					Function* gate_CNOT_anc_qbit = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(ZB_T));
+					Function* gate_CNOT_anc_anc = Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(ZG_T));
+					Function* gate_Toff = Intrinsic::getDeclaration(M, Intrinsic::Toffoli, ArrayRef<Type*>(BGA_T));
+
+					CallInst::Create(gate_CNOT_qbit_anc, ArrayRef<Value*>(AG), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_qbit_anc, ArrayRef<Value*>(BZ), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_qbit_qbit, ArrayRef<Value*>(AB), "", BB)->setTailCall();
+					CallInst::Create(gate_Toff, ArrayRef<Value*>(BGA), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_anc_anc, ArrayRef<Value*>(ZG), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_anc_qbit, ArrayRef<Value*>(ZB), "", BB)->setTailCall();
+
+					CallInst::Create(gate_CNOT_anc_qbit, ArrayRef<Value*>(ZB), "", BB)->setTailCall();
+    				CallInst::Create(gate_CNOT_qbit_anc, ArrayRef<Value*>(BZ), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_anc_qbit, ArrayRef<Value*>(ZB), "", BB)->setTailCall();
+
+					CallInst::Create(gate_CNOT_anc_qbit, ArrayRef<Value*>(GA), "", BB)->setTailCall();
+    				CallInst::Create(gate_CNOT_qbit_anc, ArrayRef<Value*>(AG), "", BB)->setTailCall();
+					CallInst::Create(gate_CNOT_anc_qbit, ArrayRef<Value*>(GA), "", BB)->setTailCall();
+
+					ReturnInst::Create(getGlobalContext(), 0, BB);
+				}
+				std::vector<Value*>  Args(3);
+				for (int i=0; i<3; i++) Args[i] = I.getArgOperand(i);
+				BasicBlock::iterator ii(&I);
+				ReplaceInstWithInst(I.getParent()->getInstList(), ii,
+					CallInst::Create(RKQC_Func, ArrayRef<Value*>(Args)));
+			}
+
+			void visitCallInst(CallInst &I) {
+				// Determine whether this is an RKQC function 
+				Function *CF = I.getCalledFunction();
+				if (CF->isIntrinsic()){
+					std::string name = CF->getName();
+					if(name.find("rkqc")!=std::string::npos) {
+					// Retrieve name of function
+						std::size_t func_loc = name.find("rkqc");
+						std::size_t func_name_end = name.find_first_of("(");
+						std::string rkqcFuncName = name.substr(func_loc+5, func_name_end-func_loc); 
+						errs() << rkqcFuncName << "\n";
+						std::string rkqcName = rkqcFuncName + "_impl";
+						Function* RKQC_Func = M->getFunction(rkqcName);
+
+						if(rkqcFuncName.find("a_swap_b") != std::string::npos){
+							create_a_swap_b(I, RKQC_Func, rkqcName);
+						}
+						else if(rkqcFuncName.find( "assign_value_of_b_to_a") != std::string::npos){
+							create_assign_value_of_b_to_a(I, RKQC_Func, rkqcName);
+						}
+						else if(rkqcFuncName.find( "a_eq_a_plus_b") != std::string::npos){
+    						create_a_eq_a_plus_b(I, RKQC_Func, rkqcName);
+    					}
+						else if(rkqcFuncName.find("assign_value_of_0_to_a") != std::string::npos){
+							create_assign_value_of_0_to_a(I, RKQC_Func, rkqcName);
+						}
+						else if(rkqcFuncName.find("assign_value_of_1_to_a") != std::string::npos){
+							create_assign_value_of_1_to_a(I, RKQC_Func, rkqcName);
+						}
+						else if(rkqcFuncName.find("toffoli") != std::string::npos){
+							std::vector<Value*> Args(3);
+							std::vector<Type*> Types(3);
+							for (int i=0; i<3; i++){
+								Args[i] = I.getArgOperand(i);
+								Types[i] = I.getArgOperand(i)->getType();
+							}
+							BasicBlock::iterator ii(&I);
+							Function* gate_Toffoli = Intrinsic::getDeclaration(M, Intrinsic::Toffoli, ArrayRef<Type*>(Types));
+							ReplaceInstWithInst(I.getParent()->getInstList(), ii,
+								CallInst::Create(gate_Toffoli, ArrayRef<Value*>(Args)));
+						}
+						else if(rkqcFuncName.find("NOT") != std::string::npos){
+
+							std::vector<Value*> Args(1);
+							std::vector<Type*> Types(1);
+							for (int i=0; i<1; i++) {
+								Args[i] = I.getArgOperand(i);
+								Types[i] = I.getArgOperand(i)->getType();
+							}
+							BasicBlock::iterator ii(&I);
+							Function* gate_X = Intrinsic::getDeclaration(M, Intrinsic::X, ArrayRef<Type*>(Types));
+							ReplaceInstWithInst(I.getParent()->getInstList(), ii,
+								CallInst::Create(gate_X, ArrayRef<Value*>(Args)));
+
+						}
+						else if(rkqcFuncName.find("cnot") != std::string::npos){
+							std::vector<Value*> Args(2);
+							std::vector<Type*> Types(2);
+							for (int i=0; i<2; i++){
+								Args[i] = I.getArgOperand(i);
+								Types[i] = I.getArgOperand(i)->getType();
+							}
+							BasicBlock::iterator ii(&I);
+							Function* gate_X = Intrinsic::getDeclaration(M, Intrinsic::X, ArrayRef<Type*>(Types));
+							ReplaceInstWithInst(I.getParent()->getInstList(), ii,
+								CallInst::Create(gate_X, ArrayRef<Value*>(Args)));
+						}
+
+					}// endif 'found RKQC'
+				} 	
+			} // visitCallInst()
+		}; // struct RKQCVisitor
+
+		virtual bool runOnModule(Module &M) {
+			RKQCVisitor RV(&M);
+			RV.visit(M);
+			return true;
+		} // runOnModule()
+		
+	}; // struct GenRKQC
+} // namespace
+
+char GenRKQC::ID = 0;
+static RegisterPass<GenRKQC> X("GenRKQC", "RKQC Generator", false, false);
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GenSIMDScheduleCG.cpp llvm/lib/Transforms/Scaffold/GenSIMDScheduleCG.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GenSIMDScheduleCG.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/GenSIMDScheduleCG.cpp	2017-10-12 11:09:31.093119606 +0800
@@ -0,0 +1,1578 @@
+//===----------------- GenSIMDSchedCG.cpp ----------------------===//
+// This file implements the Scaffold Pass of counting the number 
+//  of critical timesteps and gate parallelism in program
+//  in callgraph post-order.
+//
+//        This file was created by Scaffold Compiler Working Group
+// Fine-grained list scheduling for leaf modules
+// Coarse-grained scheduling for non-leaf modules
+// Get T gate proportion within schedule length
+// Cleaned up the code
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "GenSIMDSchedCG"
+#include <vector>
+#include <sstream>
+#include <fstream>
+#include <string>
+#include <limits>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/ADT/SCCIterator.h"
+#include "llvm/Argument.h"
+#include "llvm/ADT/ilist.h"
+#include "llvm/Constants.h"
+#include "llvm/IntrinsicInst.h"
+#include "llvm/Support/CommandLine.h"
+
+
+using namespace llvm;
+using namespace std;
+
+
+static cl::opt<unsigned>
+RES_CONSTRAINT("simd-kconstraint-cg", cl::init(10), cl::Hidden,
+  cl::desc("k in SIMD-k Coarse-Grained Resource Constrained Scheduling"));
+
+static cl::opt<unsigned>
+DATA_CONSTRAINT("simd-dconstraint-cg", cl::init(1024), cl::Hidden,
+  cl::desc("d in SIMD-k Coarse-Grained Resource Constrained Scheduling"));
+
+static cl::opt<unsigned>
+MOVE_WEIGHT("move-weight-cg", cl::init(4), cl::Hidden,
+  cl::desc("the communication weighting applied to a move operation"));
+
+#define MAX_RES_CONSTRAINT 128 
+#define SSCHED_THRESH 10000000
+
+#define MAX_GATE_ARGS 30
+#define MAX_BT_COUNT 15 //max backtrace allowed - to avoid infinite recursive loops
+#define NUM_QGATES 17
+#define _CNOT 0
+#define _H 1
+#define _S 2
+#define _T 3
+#define _X 4
+#define _Y 5
+#define _Z 6
+#define _MeasX 7
+#define _MeasZ 8
+#define _PrepX 9
+#define _PrepZ 10
+#define _Tdag 11
+#define _Sdag 12
+#define _Rz 13
+#define _Toffoli 14
+#define _Fredkin 15
+#define _All 16
+
+bool debugGenSIMDSchedCG = false;
+
+namespace {
+
+  typedef pair<Instruction*, uint64_t> InstPri; //instpriority
+  
+  struct CompareInstPriByValue {
+    bool operator() (const InstPri& a, const InstPri& b) const {
+      return a.second < b.second;
+    };
+  };
+
+  struct modularInfo{
+    uint64_t width;
+    uint64_t length;
+    uint64_t moves;
+    uint64_t mts;
+    //uint64_t ancilla;
+    uint64_t tgates;
+    uint64_t tgates_ub;
+    uint64_t tgates_par;
+    uint64_t tgates_par_ub;
+    //TODO add field for the move information
+    vector<uint64_t> moveInfo;
+
+    modularInfo(): width(0), length(0), moves(0), mts(0), tgates(0), tgates_ub(0), tgates_par(0), tgates_par_ub(0) {}
+  };
+
+
+  struct qGateArg{ //arguments to qgate calls
+    Value* argPtr;
+    int argNum;
+    bool isQbit;
+    bool isCbit;
+    bool isUndef;
+    bool isPtr;
+    int valOrIndex; //Value if not Qbit, Index if Qbit & not a Ptr
+    double angle;
+    qGateArg(): argPtr(NULL), argNum(-1), isQbit(false), isCbit(false), isUndef(false), isPtr(false), valOrIndex(-1), angle(0.0){ }
+  };
+  
+struct qArgInfo{
+  string name;
+  int index;
+  qArgInfo(): name("none"), index(-1){ }
+};
+
+struct qGate{
+  Function* qFunc;
+  int numArgs;
+  qArgInfo args[MAX_GATE_ARGS];
+  double angle;
+  qGate():qFunc(NULL), numArgs(0), angle(0.0) { }
+};
+
+  struct ArrParGates{
+    int typeOfGate[MAX_RES_CONSTRAINT];
+    uint64_t numGates[MAX_RES_CONSTRAINT];
+  };
+
+  struct GenSIMDSchedCG : public ModulePass {
+    static char ID; // Pass identification
+    
+    string gate_name[NUM_QGATES];
+    vector<qGateArg> tmpDepQbit;
+    vector<Value*> vectQbit;
+    
+    int btCount; //backtrace count
+
+    modularInfo totalSched;
+    modularInfo currSched;
+
+    map<string, int> gate_index;    
+
+    map<string, map<int,uint64_t> > funcQbits; //qbits in current function
+    map<Function*, map<unsigned int, map<int,uint64_t> > > tableFuncQbits;
+    map<string, unsigned int> funcArgs;
+
+    vector<ArrParGates> currArrParGates;
+
+    map<Instruction*, qGate> mapInstSet;
+    vector<InstPri> priorityVector;
+
+    vector<Instruction*> vectCalls;
+
+    map<Function*, modularInfo> funcInfo;
+    vector<Function*> isLeaf;
+    bool hasPrimitivesOnly;
+
+    bool isFirstMeas;
+
+    vector<uint64_t> histogramData;
+
+    map<string, modularInfo > fileContents;
+
+    GenSIMDSchedCG() : ModulePass(ID) {}
+    
+    bool backtraceOperand(Value* opd, int opOrIndex);
+    void analyzeAllocInst(Function* F,Instruction* pinst);
+    void analyzeCallInst(Function* F,Instruction* pinst);   // TODO: modify for corrected timing calcs
+    void getFunctionArguments(Function *F);
+    
+    void saveTableFuncQbits(Function* F);
+    void print_tableFuncQbits();
+    void print_parallelism(Function* F);
+    void print_ArrParGates();
+    void cleanupCurrArrParGates();
+    bool checkIfIntrinsic(Function* CF);
+
+    void read_schedule_file();
+
+    void init_gate_names(){
+        gate_name[_CNOT] = "CNOT";
+        gate_name[_H] = "H";
+        gate_name[_S] = "S";
+        gate_name[_T] = "T";
+        gate_name[_Toffoli] = "Toffoli";
+        gate_name[_X] = "X";
+        gate_name[_Y] = "Y";
+        gate_name[_Z] = "Z";
+        gate_name[_MeasX] = "MeasX";
+        gate_name[_MeasZ] = "MeasZ";
+        gate_name[_PrepX] = "PrepX";
+        gate_name[_PrepZ] = "PrepZ";
+        gate_name[_Sdag] = "Sdag";
+        gate_name[_Tdag] = "Tdag";
+        gate_name[_Fredkin] = "Fredkin";
+        gate_name[_Rz] = "Rz";
+        gate_name[_All] = "All";                    
+        
+        gate_index["CNOT"] = _CNOT;        
+        gate_index["H"] = _H;
+        gate_index["S"] = _S;
+        gate_index["T"] = _T;
+        gate_index["Toffoli"] = _Toffoli;
+        gate_index["X"] = _X;
+        gate_index["Y"] = _Y;
+        gate_index["Z"] = _Z;
+        gate_index["Sdag"] = _Sdag;
+        gate_index["Tdag"] = _Tdag;
+        gate_index["MeasX"] = _MeasX;
+        gate_index["MeasZ"] = _MeasZ;
+        gate_index["PrepX"] = _PrepX;
+        gate_index["PrepZ"] = _PrepZ;
+        gate_index["Fredkin"] = _Fredkin;
+        gate_index["Rz"] = _Rz;
+        gate_index["All"] = _All;                    
+        }
+
+        
+
+    void init_gates_as_functions();    
+    void init_critical_path_algo(Function* F);
+    void calc_critical_time(Function* F, qGate qg, bool isLeafFunc);        // TODO: modify for correct time measurement
+    void print_funcQbits();
+    void print_qgate(qGate qg);
+    void print_critical_info(); 
+
+    void print_scheduled_gate(qGate qg, uint64_t ts);
+
+    uint64_t find_max_funcQbits();
+    void memset_funcQbits(uint64_t val);
+    uint64_t get_ts_to_schedule(Function* F, uint64_t ts, Function* funcToSched, uint64_t& first_step);
+    uint64_t get_ts_to_schedule_leaf(Function* F, uint64_t ts, Function* funcToSched, uint64_t& first_step);
+
+    void save_blackbox_info(Function* F);
+    uint64_t calc_critical_time_unbounded(Function* F, qGate qg);        
+
+    bool check_if_pre_schedule(Function* F);
+
+    void print_qgateArg(qGateArg qg)
+    {
+      errs()<< "Printing QGate Argument:\n";
+      if(qg.argPtr) errs() << "  Name: "<<qg.argPtr->getName()<<"\n";
+      errs() << "  Arg Num: "<<qg.argNum<<"\n"
+             << "  isUndef: "<<qg.isUndef
+             << "  isQbit: "<<qg.isQbit
+             << "  isCbit: "<<qg.isCbit
+             << "  isPtr: "<<qg.isPtr << "\n"
+             << "  Value or Index: "<<qg.valOrIndex<<"\n";
+    }                    
+    
+    uint64_t getNumCritSteps(Function* F){
+      map<Function*, modularInfo>::iterator mf = funcInfo.find(F);
+      assert(mf!=funcInfo.end());
+      return (mf->second.length);
+    }
+
+    void CountCriticalFunctionResources (Function *F);
+    
+    bool runOnModule (Module &M);    
+    
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();  
+      AU.addRequired<CallGraph>();    
+    }
+    
+  }; // End of struct GenSIMDSchedCG
+} // End of anonymous namespace
+
+
+
+char GenSIMDSchedCG::ID = 0;
+static RegisterPass<GenSIMDSchedCG> X("GenCGSIMDSchedule", "Generate CoarseGrained SIMD Schedule");
+
+void GenSIMDSchedCG::getFunctionArguments(Function* F)
+{
+  for(Function::arg_iterator ait=F->arg_begin();ait!=F->arg_end();++ait)
+    {    
+      //if(ait) errs() << "Argument: "<<ait->getName()<< " ";
+
+      string argName = (ait->getName()).str();
+      Type* argType = ait->getType();
+      unsigned int argNum=ait->getArgNo();         
+
+      qGateArg tmpQArg;
+      tmpQArg.argPtr = ait;
+      tmpQArg.argNum = argNum;
+
+      if(argType->isPointerTy()){
+        tmpQArg.isPtr = true;
+
+        Type *elementType = argType->getPointerElementType();
+        if (elementType->isIntegerTy(16)){ //qbit*
+          tmpQArg.isQbit = true;
+          vectQbit.push_back(ait);
+          
+          map<int,uint64_t> tmpMap;
+          tmpMap[-1] = 0; //add entry for entire array
+          tmpMap[-2] = 0; //add entry for max     
+          funcQbits[argName]=tmpMap;      
+          funcArgs[argName] = argNum;
+        }
+        else if (elementType->isIntegerTy(1)){ //cbit*
+          tmpQArg.isCbit = true;
+          vectQbit.push_back(ait);
+          funcArgs[argName] = argNum;
+        }
+      }
+      else if (argType->isIntegerTy(16)){ //qbit
+        tmpQArg.isQbit = true;
+        vectQbit.push_back(ait);
+
+          map<int,uint64_t> tmpMap;
+          tmpMap[-1] = 0; //add entry for entire array
+          tmpMap[-2] = 0; //add entry for max
+          funcQbits[argName]=tmpMap;
+          funcArgs[argName] = argNum;
+      }
+      else if (argType->isIntegerTy(1)){ //cbit
+        tmpQArg.isCbit = true;
+        vectQbit.push_back(ait);
+          funcArgs[argName] = argNum;
+      }
+      
+    }
+}
+
+bool GenSIMDSchedCG::backtraceOperand(Value* opd, int opOrIndex)
+{
+  if(opOrIndex == 0) //backtrace for operand
+    {
+      //search for opd in qbit/cbit vector
+      vector<Value*>::iterator vIter=find(vectQbit.begin(),vectQbit.end(),opd);
+      if(vIter != vectQbit.end()){
+        tmpDepQbit[0].argPtr = opd;
+        
+        return true;
+      }
+      
+      if(btCount>MAX_BT_COUNT)
+        return false;
+      
+      if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(opd))
+        {
+
+          if(GEPI->hasAllConstantIndices()){
+            Instruction* pInst = dyn_cast<Instruction>(opd);
+            unsigned numOps = pInst->getNumOperands();
+
+            backtraceOperand(pInst->getOperand(0),0);
+            
+            //NOTE: getelemptr instruction can have multiple indices. Currently considering last operand as desired index for qubit. Check this reasoning. 
+            if(ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(numOps-1))){
+              if(tmpDepQbit.size()==1){
+                tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+              }
+            }
+          }
+          
+          else if(GEPI->hasIndices()){
+            
+            Instruction* pInst = dyn_cast<Instruction>(opd);
+            unsigned numOps = pInst->getNumOperands();
+            backtraceOperand(pInst->getOperand(0),0);
+
+            if(tmpDepQbit[0].isQbit && !(tmpDepQbit[0].isPtr)){     
+              //NOTE: getelemptr instruction can have multiple indices. consider last operand as desired index for qubit. Check if this is true for all.
+              backtraceOperand(pInst->getOperand(numOps-1),1);
+              
+            }
+          }
+          else{     
+            Instruction* pInst = dyn_cast<Instruction>(opd);
+            unsigned numOps = pInst->getNumOperands();
+            for(unsigned iop=0;iop<numOps;iop++){
+              backtraceOperand(pInst->getOperand(iop),0);
+            }
+          }
+          return true;
+        }
+      
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+        unsigned numOps = pInst->getNumOperands();
+        for(unsigned iop=0;iop<numOps;iop++){
+          btCount++;
+          backtraceOperand(pInst->getOperand(iop),0);
+          btCount--;
+        }
+        return true;
+      }
+      else{
+        return true;
+      }
+    }
+  else if(opOrIndex == 0){ //opOrIndex == 1; i.e. Backtracing for Index    
+    if(btCount>MAX_BT_COUNT) //prevent infinite backtracing
+      return true;
+
+    if(ConstantInt *CI = dyn_cast<ConstantInt>(opd)){
+      tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+      return true;
+    }      
+
+    if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+      unsigned numOps = pInst->getNumOperands();
+      for(unsigned iop=0;iop<numOps;iop++){
+        btCount++;
+        backtraceOperand(pInst->getOperand(iop),1);
+        btCount--;
+      }
+    }
+
+  }
+  else{ //opOrIndex == 2: backtracing to call inst MeasZ
+    if(CallInst *endCI = dyn_cast<CallInst>(opd)){
+      if(endCI->getCalledFunction()->getName().find("llvm.Meas") != string::npos){
+        tmpDepQbit[0].argPtr = opd;
+
+        return true;
+      }
+      else{
+        if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+          unsigned numOps = pInst->getNumOperands();
+          bool foundOne=false;
+          for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+            btCount++;
+            foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+            btCount--;
+          }
+          return foundOne;
+        }
+      }
+    }
+    else{
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+        unsigned numOps = pInst->getNumOperands();
+        bool foundOne=false;
+        for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+          btCount++;
+          foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+          btCount--;
+        }
+        return foundOne;
+      }
+    }
+  }
+  return false;
+}
+
+
+void GenSIMDSchedCG::analyzeAllocInst(Function* F, Instruction* pInst){
+  if (AllocaInst *AI = dyn_cast<AllocaInst>(pInst)) {
+    Type *allocatedType = AI->getAllocatedType();
+    
+    if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+      qGateArg tmpQArg;
+      
+      Type *elementType = arrayType->getElementType();
+      uint64_t arraySize = arrayType->getNumElements();
+      if (elementType->isIntegerTy(16)){
+        vectQbit.push_back(AI);
+        tmpQArg.isQbit = true;
+        tmpQArg.argPtr = AI;
+        tmpQArg.valOrIndex = arraySize;
+
+        map<int,uint64_t> tmpMap; //add qbit to funcQbits
+        tmpMap[-1] = 0; //entry for entire array ops
+        tmpMap[-2] = 0; //entry for max
+        funcQbits[AI->getName()]=tmpMap;
+
+      }
+      
+      if (elementType->isIntegerTy(1)){
+        vectQbit.push_back(AI); //Cbit added here
+        tmpQArg.isCbit = true;
+        tmpQArg.argPtr = AI;
+        tmpQArg.valOrIndex = arraySize;
+      }
+    }
+  }
+}
+
+
+void GenSIMDSchedCG::init_critical_path_algo(Function* F){
+
+  currSched.width = 0;
+  currSched.length = 0;
+  currSched.tgates = 0;
+  currSched.tgates_ub = 0;
+  currSched.tgates_par = 0;
+  currSched.tgates_par_ub = 0;
+
+  totalSched.width = 0;
+  totalSched.length = 0;
+  totalSched.tgates = 0;
+  totalSched.tgates_ub = 0;
+  totalSched.tgates_par = 0;
+  totalSched.tgates_par_ub = 0;
+
+  isFirstMeas = true;
+
+  hasPrimitivesOnly = true;
+}
+
+void GenSIMDSchedCG::print_funcQbits(){
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbits.begin(); mIter!=funcQbits.end(); ++mIter){
+    errs() << "Var "<< (*mIter).first << " ---> ";
+    for(map<int,uint64_t>::iterator indexIter  = (*mIter).second.begin(); indexIter!=(*mIter).second.end(); ++indexIter){
+      errs() << (*indexIter).first << ":"<<(*indexIter).second<< "  ";
+    }
+    errs() << "\n";
+  }
+}
+
+void GenSIMDSchedCG::print_ArrParGates(){
+  errs() << "Printing ArrParGate Vector \n";
+    int j = 0;
+    for(vector<ArrParGates>::iterator vit = currArrParGates.begin(); vit!=currArrParGates.end(); ++vit, j++){
+      errs() << j << " -- ";
+      for(unsigned int i=0;i<RES_CONSTRAINT;i++)
+        errs() << (*vit).typeOfGate[i] << " : " << (*vit).numGates[i] << " ; ";
+      errs() << "\n";
+    }
+  
+}
+
+void GenSIMDSchedCG::print_qgate(qGate qg){
+  errs() << qg.qFunc->getName() << " : ";
+  for(int i=0;i<qg.numArgs;i++){
+    errs() << qg.args[i].name << "(" << qg.args[i].index << ") "  ;
+  }
+  errs() << "\n";
+}
+
+uint64_t GenSIMDSchedCG::get_ts_to_schedule(Function* F, uint64_t ts, Function* funcToSched, uint64_t& first_step){
+  //F is non-leaf. Treat all incoming function as blackboxes
+
+  //errs() << "\n funcTOSched = " << funcToSched->getName() << "\n";
+
+  //print_funcQbits();
+  //print_ArrParGates();
+
+  uint64_t Win = 0;
+  uint64_t Lin = 0;
+  uint64_t Min = 0;
+  uint64_t Mtsin = 0;
+  uint64_t Tin = 0;
+  uint64_t TinUB = 0;
+  uint64_t TinPar = 0;
+  uint64_t TinParUB = 0;
+
+  if(checkIfIntrinsic(funcToSched)){
+    Win = 1;
+    Lin = 1 + MOVE_WEIGHT;
+    Min = ( funcToSched->getIntrinsicID() == Intrinsic::CNOT ) ? 4 : 2;
+    Mtsin = 1;
+
+    if(funcToSched->getIntrinsicID() == Intrinsic::T
+       || funcToSched->getIntrinsicID() == Intrinsic::Tdag){
+      //errs() << "Found T or Tdag \n";
+      Lin = 5; //cost of T gate
+      Tin = 1;
+      TinUB = 1;
+      TinPar = 1;
+      TinParUB = 1;
+    }
+    else{
+      Tin = 0;
+      TinUB = 0;
+      TinPar = 0;
+      TinParUB = 0;
+    }
+  }
+  
+  else{
+    map<Function*, modularInfo>::iterator fin = funcInfo.find(funcToSched);
+    assert(fin!=funcInfo.end() && "Func not found in funcInfo");
+        
+    Win = (*fin).second.width; //width for incoming func
+    Lin = (*fin).second.length; //length for incoming func 
+    Min = (*fin).second.moves; //moves for incoming func 
+    Mtsin = (*fin).second.mts; //move timesteps for incoming func 
+    Tin = (*fin).second.tgates; //tgates for incoming func  
+    TinUB = (*fin).second.tgates_ub; //tgates for incoming func  
+    TinPar = (*fin).second.tgates_par; //tgates for incoming func  
+    TinParUB = (*fin).second.tgates_par_ub;
+  }
+
+  //errs() << "Curr Width = " << currSched.width << " Length = " << currSched.length << " Tgates = " << currSched.tgates << " Moves = " << currSched.moves << " MTS = " << currSched.mts << "\n";
+  //errs() << "Func Width = " << Win << " Length = " << Lin <<  " Tgates = " << Tin << " Moves = " << Min << " MTS = " << Mtsin << "\n";
+  //errs() << "Total Width = " << totalSched.width << " Length = " << totalSched.length << " Tgates = " << totalSched.tgates << " Moves = " << totalSched.moves << " MTS = " << totalSched.mts << "\n";
+
+
+  if(ts < totalSched.length+currSched.length){ //might be able to parallelize  
+    if((Win + currSched.width) <= RES_CONSTRAINT) //Hooray, can be parallelized
+      {
+        //first_step = totalSched.length; //where the func got scheduled
+        first_step = max(ts,totalSched.length); //where the func got scheduled
+        currSched.width += Win;
+        //currSched.length = max(Lin, currSched.length);
+        currSched.length = max(first_step - totalSched.length + Lin, currSched.length);
+        currSched.moves += Min;
+        currSched.mts = max(Mtsin, currSched.mts);
+        currSched.tgates = max(Tin, currSched.tgates);
+        currSched.tgates_ub = min(TinUB+currSched.tgates_ub, currSched.length);
+        currSched.tgates_par = max(TinPar, currSched.tgates_par);
+        currSched.tgates_par_ub = min(TinParUB+currSched.tgates_par_ub, currSched.width);
+        //errs() << "Parallel. New Width = " << currSched.width << " New Length = " << currSched.length << " New Tgates = " << currSched.tgates << " Tpar= " << currSched.tgates_par << " TparUB=" << currSched.tgates_par_ub << "\n";
+         }
+    else // must be serialized due to SIMD-k constraint
+      {
+
+        first_step = totalSched.length+currSched.length; //where the func got scheduled
+
+        totalSched.width = max(totalSched.width,currSched.width);
+        totalSched.length += currSched.length;
+        totalSched.moves += currSched.moves;
+        totalSched.mts += currSched.mts;
+        totalSched.tgates += currSched.tgates;
+        totalSched.tgates_ub += currSched.tgates_ub;
+        totalSched.tgates_par = max(totalSched.tgates_par,currSched.tgates_par);
+        totalSched.tgates_par_ub = max(totalSched.tgates_par_ub,currSched.tgates_par_ub);
+        
+
+        currSched.length = Lin; //create new
+        currSched.width = Win; //create new W
+        currSched.moves = Min;
+        currSched.mts = Mtsin;
+        currSched.tgates = Tin; //create new W
+        currSched.tgates_ub = TinUB; //create new W
+        currSched.tgates_par = TinPar; //create new W
+        currSched.tgates_par_ub = TinParUB; //create new W
+        //errs() << "Serial(SIMD-k). New Width = " << currSched.width << " New Length = " << currSched.length << " New Tgates= " << currSched.tgates<< " New TgatesUB= " << currSched.tgates_ub<< " New TgatesPar= " << currSched.tgates_par<< " TparUB=" << currSched.tgates_par_ub << "\n";
+      }
+  }
+
+  else //cannot parallelize due to data dependency
+    {
+      //first_step = currSched.length; //where the func got scheduled
+      first_step = totalSched.length+currSched.length; //where the func got scheduled
+      totalSched.width = max(totalSched.width,currSched.width);
+      totalSched.length += currSched.length;
+      totalSched.moves += currSched.moves;
+      totalSched.mts += currSched.mts;
+      totalSched.tgates += currSched.tgates;
+      totalSched.tgates_ub += currSched.tgates_ub;
+      totalSched.tgates_par = max(totalSched.tgates_par,currSched.tgates_par);
+      totalSched.tgates_par_ub = max(totalSched.tgates_par_ub,currSched.tgates_par_ub);
+
+      currSched.length = Lin; //create new L
+      currSched.width = Win; //create new W
+      currSched.moves = Min;
+      currSched.mts = Mtsin;
+      currSched.tgates = Tin; //create new T
+      currSched.tgates_ub = TinUB; //create new W
+      currSched.tgates_par = TinPar; //create new W
+      currSched.tgates_par_ub = TinParUB; //create new W
+
+      //errs() << "Serial(Dependency). New Width = " << currSched.width << " New Length = " << currSched.length << " TotalW=" << totalSched.width << " TotalL=" << totalSched.length << " TotalT=" << totalSched.tgates << " TotalT_UB=" << totalSched.tgates_ub << " TotalTPar=" << totalSched.tgates_par << " TotalTParUB=" << totalSched.tgates_par_ub << "\n";
+    }
+
+  return (totalSched.length+currSched.length)-1; //where the last dependency should be recorded
+  //return (currSched.length)-1; //where the last dependency should be recorded
+}
+
+
+uint64_t GenSIMDSchedCG::get_ts_to_schedule_leaf(Function* F, uint64_t ts, Function* funcToSched, uint64_t& first_step){
+
+  //errs() << " funcTOSched = " << funcToSched->getName() << "\n";
+  //errs() << " Size of currSched = " << currArrParGates.size() << "\n";
+
+  //F is leaf. Treat all incoming functions with respect  
+  int funcIndex = -1;
+
+  assert(funcToSched->getName().str().find("llvm.")!=string::npos &&  "Non-Intrinsic Func Found in Leaf Function"); 
+  
+  std::string intrinsic_overloaded_name = funcToSched->getName().str();
+  
+  if(intrinsic_overloaded_name.find("CNOT.i") != string::npos) intrinsic_overloaded_name = "CNOT";
+  else if(intrinsic_overloaded_name.find("NOT.i") != string::npos) intrinsic_overloaded_name = "X";
+  else if(intrinsic_overloaded_name.find("Toffoli.i") != string::npos) intrinsic_overloaded_name = "Toffoli";
+  else if(intrinsic_overloaded_name.find("MeasX.") != string::npos) intrinsic_overloaded_name = "MeasX";
+  else if(intrinsic_overloaded_name.find("MeasZ.") != string::npos) intrinsic_overloaded_name = "MeasZ";
+  else if(intrinsic_overloaded_name.find("H.i") != string::npos) intrinsic_overloaded_name = "H";
+  else if(intrinsic_overloaded_name.find("Fredkin.i") != string::npos) intrinsic_overloaded_name = "Fredkin";
+  else if(intrinsic_overloaded_name.find("PrepX.") != string::npos) intrinsic_overloaded_name = "PrepX";
+  else if(intrinsic_overloaded_name.find("PrepZ.") != string::npos) intrinsic_overloaded_name = "PrepZ";
+  else if(intrinsic_overloaded_name.substr(0,2) == "Rz") intrinsic_overloaded_name = "Rz";
+  else if(intrinsic_overloaded_name.find("S.") != string::npos) intrinsic_overloaded_name = "S";
+  else if(intrinsic_overloaded_name.find("T.") != string::npos) intrinsic_overloaded_name = "T";
+  else if(intrinsic_overloaded_name.find("Sdag.") != string::npos) intrinsic_overloaded_name = "Sdag";
+  else if(intrinsic_overloaded_name.find("Tdag.") != string::npos) intrinsic_overloaded_name = "Tdag";
+  else if(intrinsic_overloaded_name.find("X.") != string::npos) intrinsic_overloaded_name = "X";
+  else if(intrinsic_overloaded_name.find("Z.") != string::npos) intrinsic_overloaded_name = "Z";
+
+  
+//  map<string, int>::iterator gidx = gate_index.find(funcToSched->getName().str().substr(5));
+  map<string, int>::iterator gidx = gate_index.find(intrinsic_overloaded_name);
+
+
+  assert(gidx!=gate_index.end() && "No Gate Index Found for this Intrinsic Function");
+  funcIndex = (*gidx).second;
+
+  //schedule intrinsic function
+
+  uint64_t retVal = 0;
+  bool FirstEntrySched = false;
+
+  int costOfGate = 1;
+
+  /*if(funcIndex == _T || funcIndex == _Tdag)
+    costOfGate = 10;*/
+
+  for(int c = 0; c<costOfGate; c++){
+    bool foundEntry = false;
+  
+    int searchFuncIndex = funcIndex+c*20;
+  
+    for(uint64_t i = ts; (i<currArrParGates.size() && !foundEntry); i++){
+      for(unsigned int j = 0; (j<RES_CONSTRAINT && !foundEntry); j++){
+        //if((currArrParGates[i].typeOfGate[j] == searchFuncIndex) && (currArrParGates[i].numGates[j] < DATA_CONSTRAINT)){
+        if((currArrParGates[i].typeOfGate[j] == searchFuncIndex) && ((searchFuncIndex == _CNOT && 2*currArrParGates[i].numGates[j] < DATA_CONSTRAINT)
+                                || (searchFuncIndex != _CNOT && currArrParGates[i].numGates[j]< DATA_CONSTRAINT))){
+          currArrParGates[i].numGates[j] += 1;
+          if(!FirstEntrySched){
+            first_step = i;
+            FirstEntrySched = true;
+          }
+          
+          if((c==0) && (funcIndex == _T || funcIndex == _Tdag)){
+            if(currArrParGates[i].numGates[j] > currSched.tgates_par){
+              currSched.tgates_par = currArrParGates[i].numGates[j];
+              currSched.tgates_par_ub = currArrParGates[i].numGates[j];
+              //errs() << "Incr tgate_par \n";
+            }
+          }
+
+          //errs() << "GateType Parallelism. TS = " << i << " K-factor=" << j << " Tpar=" << currSched.tgates_par << " TparUB=" << currSched.tgates_par_ub <<"\n";
+          foundEntry = true;
+          retVal = i;
+          ts = i+1; //update value of ts to start with in next iteration
+          //return i;
+        }
+        else if(currArrParGates[i].typeOfGate[j] == -1){
+          currArrParGates[i].typeOfGate[j] = searchFuncIndex;
+          currArrParGates[i].numGates[j] = 1;
+          if(!FirstEntrySched){
+            first_step = i;
+            FirstEntrySched = true;
+          }
+          if(j >= currSched.width) //update currSched.width
+            currSched.width = j+1;
+          
+          //Add to T gate count if T or Tdag gate
+          if((c==0) && (funcIndex == _T || funcIndex == _Tdag)){
+            //errs() << "Found T or Tdag \n";
+            
+            bool prevTgateFound = false;
+            for(unsigned int jcheck=0; jcheck<RES_CONSTRAINT; jcheck++){
+              if(currArrParGates[i].typeOfGate[jcheck] == _T
+                 || currArrParGates[i].typeOfGate[jcheck] == _Tdag)
+                prevTgateFound = true;
+            }
+            if(!prevTgateFound){
+              currSched.tgates++;
+              currSched.tgates_ub++;
+              if(currSched.tgates_par == 0){
+                currSched.tgates_par = 1;
+                currSched.tgates_par_ub = 1;
+                }
+              //errs() << "--Incr tgate \n";
+            }
+          }
+          
+          //errs() << "Unscheduled. New Width = " << currSched.width << " New Length = " << currSched.length << " Tgates=" << currSched.tgates << " TgatesUB=" << currSched.tgates_ub << " TgatesPar=" << currSched.tgates_par << " TgatesParUB=" << currSched.tgates_par_ub <<" K-factor=" << j <<"\n";
+          foundEntry = true;
+          retVal = i;
+          ts = i+1;
+          //return i;
+        }
+      }
+    }
+  
+    if(!foundEntry){
+      //suitable ts not found, create a new ts for this type of gate
+      //add entry to vectArrParGates
+      
+      ArrParGates tmpArrPar; //initialize
+      for(unsigned int k=0;k<RES_CONSTRAINT; k++){
+        tmpArrPar.typeOfGate[k] = -1;
+        tmpArrPar.numGates[k] = 0;
+      }
+  
+      tmpArrPar.typeOfGate[0] = searchFuncIndex;
+      tmpArrPar.numGates[0] = 1;
+      currArrParGates.push_back(tmpArrPar);
+      if(!FirstEntrySched){
+        first_step = currArrParGates.size()-1;
+        FirstEntrySched = true;
+      }
+
+      if((c==0) && (funcIndex == _T || funcIndex == _Tdag)){
+        currSched.tgates++;
+        currSched.tgates_ub++;
+        //errs() << "Incr tgates \n";
+        if(currSched.tgates_par == 0){
+          currSched.tgates_par = 1;
+          currSched.tgates_par_ub = 1;
+          }
+      }
+      
+      if(currSched.width == 0) //update currSched.width
+        currSched.width = 1;
+      currSched.length++;
+      
+      //errs() << "NEW TS. New Width = " << currSched.width << " New Length = " << currSched.length << " T gates = " << currSched.tgates << " TgatesUB=" << currSched.tgates_ub << " TgatesPar=" << currSched.tgates_par << " TgatesParUB=" << currSched.tgates_par_ub<< "\n";
+      
+      retVal = currArrParGates.size()-1;
+      ts = currArrParGates.size();
+
+      //return currArrParGates.size()-1;
+    } 
+  } // cost Of Gate
+  
+  //print_ArrParGates();
+  return retVal;
+  
+}
+
+void GenSIMDSchedCG::cleanupCurrArrParGates(){
+    currArrParGates.clear();    
+}
+
+/*bool GenSIMDSchedCG::checkTgatePar(Function* F, uint64_t par){
+  //is function leaf?
+  vector<Function*>::iterator vit = find(isLeaf.begin(), isLeaf.end(), F);
+  if(vit==isLeaf.end()) //not a leaf
+    return true;
+
+  //is Leaf
+  //iterate over currArrParGates and check for 
+
+  }*/
+
+void GenSIMDSchedCG::save_blackbox_info(Function* F){
+  //save black box info
+  modularInfo tmpMod;
+
+  tmpMod.width = max(totalSched.width,currSched.width);
+  tmpMod.length = totalSched.length + currSched.length;
+  tmpMod.moves = totalSched.moves + currSched.moves;
+  tmpMod.mts = totalSched.mts + currSched.mts;
+  tmpMod.tgates = totalSched.tgates + currSched.tgates;
+  tmpMod.tgates_ub = totalSched.tgates_ub + currSched.tgates_ub;
+
+  //check if leaf function
+  //if leaf go thru currArrParGates vector and find T parallelism
+
+  //if not leaf function
+  tmpMod.tgates_par = max(totalSched.tgates_par,currSched.tgates_par);
+  tmpMod.tgates_par_ub = max(totalSched.tgates_par_ub,currSched.tgates_par_ub);
+
+  //bool checkTgatePar = checkTgatePar(F,tmpMod.tgates_par);
+
+  funcInfo[F] = tmpMod;
+
+  bool funcIsLeaf = true;
+  vector<Function*>::iterator vit = find(isLeaf.begin(), isLeaf.end(), F);
+  if(vit==isLeaf.end()) //not a leaf
+    funcIsLeaf=false;
+  
+  errs() << "SIMD k="<<RES_CONSTRAINT<<" d=" << DATA_CONSTRAINT << " " << F->getName() << " " << tmpMod.width << " " << tmpMod.length << " " << tmpMod.moves << " " << tmpMod.mts << " leaf= " << funcIsLeaf << "\n";
+
+}
+
+
+void GenSIMDSchedCG::print_critical_info(){
+    errs() << "Timesteps = " << currArrParGates.size() << "\n";
+    for(unsigned int i = 0; i<currArrParGates.size(); i++){
+        errs() << i << " :";
+        for(unsigned int k=0;k<RES_CONSTRAINT;k++){      
+          errs() << currArrParGates[i].typeOfGate[k] << " : " << currArrParGates[i].numGates[k] << " / ";
+        }
+        errs() << "\n";
+    }
+}
+
+void GenSIMDSchedCG::print_parallelism(Function* F){
+  uint64_t maxGates[NUM_QGATES];
+  for(int k = 0; k<NUM_QGATES; k++)
+    maxGates[k] = 0;
+
+  for(vector<ArrParGates>::iterator vit = currArrParGates.begin(); vit!=currArrParGates.end(); ++vit){
+    for(unsigned int i = 0; i<RES_CONSTRAINT; i++)
+      if((*vit).numGates[i] > maxGates[(*vit).typeOfGate[i]])
+        maxGates[(*vit).typeOfGate[i]] = (*vit).numGates[i];
+  }
+
+  errs() << "\nMax Parallelism Factors: \n";
+  for(int k = 0; k<NUM_QGATES-1; k++){ //do not print 'All'
+    errs() << gate_name[k] << " : " << maxGates[k] << "\n";
+  }  
+}
+
+uint64_t GenSIMDSchedCG::find_max_funcQbits(){
+  uint64_t max_timesteps = 0;
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbits.begin(); mIter!=funcQbits.end(); ++mIter){
+    map<int,uint64_t>::iterator arrIter = (*mIter).second.find(-2); //max ts is in -2 entry
+    if((*arrIter).second > max_timesteps)
+      max_timesteps = (*arrIter).second;
+  }
+
+  //print_funcQbits();
+  //errs() << "Max timestep = " << max_timesteps << "\n";
+  return max_timesteps;
+
+}
+
+void GenSIMDSchedCG::memset_funcQbits(uint64_t val){
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbits.begin(); mIter!=funcQbits.end(); ++mIter){
+    for(map<int,uint64_t>::iterator arrIter = (*mIter).second.begin(); arrIter!=(*mIter).second.end();++arrIter)
+      (*arrIter).second = val;
+  }
+}
+
+void GenSIMDSchedCG::print_scheduled_gate(qGate qg, uint64_t ts){
+  string tmpGateName = qg.qFunc->getName();
+  if(tmpGateName.find("llvm.")!=string::npos)
+    tmpGateName = tmpGateName.substr(5);
+  errs() << ts << " " << tmpGateName;
+  for(int i = 0; i<qg.numArgs; i++){
+    errs() << " " << qg.args[i].name;
+    if(qg.args[i].index != -1)
+      errs() << qg.args[i].index;
+  }
+
+  /*
+  if(tmpGateName == "PrepX" || tmpGateName == "PrepZ"){
+    if(qg.angle > 0)
+      errs() << " 1";
+    else
+      errs() << " 0";
+  }
+  else if(tmpGateName == "Rz" || tmpGateName == "Ry" || tmpGateName == "Rx")
+    errs() << " "<<qg.angle;
+  */
+
+  errs() << "\n";
+}
+
+void GenSIMDSchedCG::print_tableFuncQbits(){
+  for(map<Function*, map<unsigned int, map<int, uint64_t> > >::iterator m1 = tableFuncQbits.begin(); m1!=tableFuncQbits.end(); ++m1){
+    errs() << "Function " << (*m1).first->getName() << " \n  ";
+    for(map<unsigned int, map<int, uint64_t> >::iterator m2 = (*m1).second.begin(); m2!=(*m1).second.end(); ++m2){
+      errs() << "\tArg# "<< (*m2).first << " -- ";
+      for(map<int, uint64_t>::iterator m3 = (*m2).second.begin(); m3!=(*m2).second.end(); ++m3){
+        errs() << " ; " << (*m3).first << " : " << (*m3).second;
+      }
+      errs() << "\n";
+    }
+  }
+}
+
+
+void GenSIMDSchedCG::calc_critical_time(Function* F, qGate qg, bool isLeafFunc){
+  string fname = qg.qFunc->getName();
+
+  print_qgate(qg);
+  uint64_t max_ts_of_all_args = 0;
+
+  uint64_t first_step = 0;
+
+  if(isFirstMeas && (fname == "llvm.MeasX" || fname == "llvm.MeasZ")){
+    uint64_t maxFQ = find_max_funcQbits();
+    uint64_t max_ts_sched; 
+
+    //errs() << "First Meas && Before Scheduled \n";
+    //print_funcQbits();
+
+    if(isLeafFunc)
+      max_ts_sched = get_ts_to_schedule_leaf(F,maxFQ, qg.qFunc, first_step);
+    else
+      max_ts_sched = get_ts_to_schedule(F,maxFQ, qg.qFunc, first_step);
+
+    memset_funcQbits(max_ts_sched);
+
+    //set this Meas in this max_ts_sched+1
+    map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[0].name);
+    assert(mIter != funcQbits.end() && "Meas Gate Var not found in funcQbits");
+
+    int argIndex = qg.args[0].index; //must have only one argument
+    assert(argIndex != -1 && "Meas gate has array argument");
+
+    //update the timestep number for that argument
+    map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+    (*indexIter).second =  max_ts_sched + 1;
+    
+    //update -2 entry for the array, i.e. max ts over all indices
+    indexIter = (*mIter).second.find(-2);
+    (*indexIter).second = max_ts_sched + 1;
+    
+    //errs() << "Scheduled in "<< max_ts_sched+1 << "\n";
+    //print_funcQbits();
+
+    isFirstMeas = false;
+    //--print_scheduled_gate(qg,max_ts_sched+1);
+    return;    
+  }
+  else{
+    //find last timestep for all arguments of qgate
+    for(int i=0;i<qg.numArgs; i++){
+      map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+      assert(mIter!=funcQbits.end()); //should already have an entry for the name of the qbit
+      
+      int argIndex = qg.args[i].index;
+      
+      //find the index of argument in the map<int,int>
+      if(argIndex == -1) //operation on entire array
+        {
+          //find max for the array        
+          map<int,uint64_t>::iterator indexIter = (*mIter).second.find(-2);
+          if((*indexIter).second > max_ts_of_all_args)
+            max_ts_of_all_args = (*indexIter).second;     
+        }
+      else
+        {
+          map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+          if(indexIter!=(*mIter).second.end()){
+            if((*indexIter).second > max_ts_of_all_args)
+              max_ts_of_all_args = (*indexIter).second;
+          }
+          else{
+            //find the value for entire array
+            map<int,uint64_t>::iterator fullArrayIndexIter = (*mIter).second.find(-1);  
+            ((*mIter).second)[argIndex] = (*fullArrayIndexIter).second;
+            //((*mIter).second)[argIndex] = 0;
+            if((*fullArrayIndexIter).second > max_ts_of_all_args)
+              max_ts_of_all_args = (*fullArrayIndexIter).second;
+          }
+        }
+    }
+    
+    if(debugGenSIMDSchedCG){
+      errs() << "Before Scheduling: \n";
+      print_funcQbits();
+    }
+    
+    //errs() << "Max timestep for all args = " << max_ts_of_all_args << "\n";
+    
+    //find timestep from max_ts_of_all_args where type of gate is same as this gate or no gate has been scheduled.
+    uint64_t ts_sched;
+
+      if(isLeafFunc)
+        ts_sched = get_ts_to_schedule_leaf(F,max_ts_of_all_args, qg.qFunc, first_step);
+      else
+        ts_sched = get_ts_to_schedule(F,max_ts_of_all_args, qg.qFunc, first_step);
+
+      //errs() << "ts_sched = " << ts_sched << " FirstStep = " << first_step << "\n";
+      
+      //schedule gate in max_ts_of_all_args + 1th timestep = ts_sched+1
+      if(F->getName()=="EdgeORACLEsplitPow17")
+      print_scheduled_gate(qg,first_step+1);
+      
+
+      //if(currArrParGates.size() != 0){
+      
+      //update last timestep for all arguments of qgate
+      for(int i=0;i<qg.numArgs; i++){
+        map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+        
+        int argIndex = qg.args[i].index;
+        
+        if(argIndex == -1){
+          for(map<int,uint64_t>::iterator entryIter = (*mIter).second.begin(); entryIter!=(*mIter).second.end();++entryIter){
+            (*entryIter).second = ts_sched + 1;
+          }
+          
+        }
+        else{
+          //update the timestep number for that argument
+          map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+          (*indexIter).second =  ts_sched + 1;
+          
+          //update -2 entry for the array, i.e. max ts over all indices
+          indexIter = (*mIter).second.find(-2);
+          if((*indexIter).second < ts_sched + 1)
+            (*indexIter).second = ts_sched + 1;
+        }  
+      }
+      //}
+      } // not first MeasX gate
+  
+  if(debugGenSIMDSchedCG){   
+    errs() << "\nAfter Scheduling: \n";
+    print_funcQbits();
+    print_critical_info();
+    errs() << "\n";
+  }
+  
+}
+
+uint64_t GenSIMDSchedCG::calc_critical_time_unbounded(Function* F, qGate qg){
+  string fname = qg.qFunc->getName();
+
+  if(debugGenSIMDSchedCG){   
+    print_qgate(qg);    
+    print_tableFuncQbits();
+  }
+
+  uint64_t max_ts_of_all_args = 0;
+  
+  //find last timestep for all arguments of qgate
+  for(int i=0;i<qg.numArgs; i++){
+    map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+    assert(mIter!=funcQbits.end()); //should already have an entry for the name of the qbit
+    
+    int argIndex = qg.args[i].index;
+    
+    //find the index of argument in the map<int,int>
+    if(argIndex == -1) //operation on entire array
+      {
+        //find max for the array          
+        map<int,uint64_t>::iterator indexIter = (*mIter).second.find(-2);
+        if((*indexIter).second > max_ts_of_all_args)
+          max_ts_of_all_args = (*indexIter).second;       
+      }
+    else
+      {
+        map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+        if(indexIter!=(*mIter).second.end()){
+          if((*indexIter).second > max_ts_of_all_args)
+            max_ts_of_all_args = (*indexIter).second;
+        }
+        else{
+          //find the value for entire array
+          map<int,uint64_t>::iterator fullArrayIndexIter = (*mIter).second.find(-1);      
+          ((*mIter).second)[argIndex] = (*fullArrayIndexIter).second;
+          if((*fullArrayIndexIter).second > max_ts_of_all_args)
+            max_ts_of_all_args = (*fullArrayIndexIter).second;
+        }
+      }
+    }
+    
+    if(debugGenSIMDSchedCG){
+      errs() << "Before Scheduling: \n";
+      print_funcQbits();
+      }
+    
+    //errs() << "Max timestep for all args = " << max_ts_of_all_args << "\n";
+      
+      //schedule gate in max_ts_of_all_args + 1th timestep
+      //--print_scheduled_gate(qg,max_ts_of_all_args+1);
+      
+      //update last timestep for all arguments of qgate
+      for(int i=0;i<qg.numArgs; i++){
+        map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+        
+        int argIndex = qg.args[i].index;
+        
+        if(argIndex == -1){
+          for(map<int,uint64_t>::iterator entryIter = (*mIter).second.begin(); entryIter!=(*mIter).second.end();++entryIter){
+            (*entryIter).second = max_ts_of_all_args + 1;
+          }
+          
+        }
+        else{
+          //update the timestep number for that argument
+          map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+          (*indexIter).second =  max_ts_of_all_args + 1;
+          
+          //update -2 entry for the array, i.e. max ts over all indices
+          indexIter = (*mIter).second.find(-2);
+          if((*indexIter).second < max_ts_of_all_args + 1)
+            (*indexIter).second = max_ts_of_all_args + 1;
+        }  
+      }
+
+  
+  if(debugGenSIMDSchedCG)
+  {   
+    errs() << "\nAfter Scheduling: \n";
+    print_funcQbits();
+    errs() << "\n";
+  }
+
+  return max_ts_of_all_args+1;
+  
+} //calc_critical_time_unbounded
+
+
+bool GenSIMDSchedCG::checkIfIntrinsic(Function* CF){
+  if(CF->isIntrinsic()){
+    if((CF->getIntrinsicID() == Intrinsic::CNOT)
+       || (CF->getIntrinsicID() == Intrinsic::Fredkin)
+       || (CF->getIntrinsicID() == Intrinsic::H)
+       || (CF->getIntrinsicID() == Intrinsic::MeasX)
+       || (CF->getIntrinsicID() == Intrinsic::MeasZ)
+       || (CF->getIntrinsicID() == Intrinsic::PrepX)
+       || (CF->getIntrinsicID() == Intrinsic::PrepZ)
+       || (CF->getIntrinsicID() == Intrinsic::Rz)
+       || (CF->getIntrinsicID() == Intrinsic::S)
+       || (CF->getIntrinsicID() == Intrinsic::T)
+       || (CF->getIntrinsicID() == Intrinsic::Sdag)
+       || (CF->getIntrinsicID() == Intrinsic::Tdag)
+       || (CF->getIntrinsicID() == Intrinsic::Toffoli)
+       || (CF->getIntrinsicID() == Intrinsic::X)
+       || (CF->getIntrinsicID() == Intrinsic::Y)
+       || (CF->getIntrinsicID() == Intrinsic::Z)){
+      return true;
+    }
+  }
+  return false;
+}
+
+
+void GenSIMDSchedCG::read_schedule_file(){
+  int len, wlen, temp;    // communciation unweighted and weighted lengths, and placeholder for move information
+  std::string line;
+  std::string lineFile;
+  
+  std::ifstream file ("comm_aware_schedule.txt");
+  if(file.is_open()) {
+    while(std::getline(file, line)){
+      //errs() << "Reading: " << line << "\n";
+      istringstream iss(line);
+      modularInfo mySize;
+      
+      iss >> lineFile;
+      iss >> mySize.width;
+      iss >> wlen;
+      iss >> len;
+      iss >> mySize.mts;
+      iss >> mySize.moves;
+      iss >> mySize.tgates;
+      //TODO Track move information
+      for(int i = 0; i < len; i++){
+	iss >> temp;
+	mySize.moveInfo.push_back(temp);
+      }
+      // Use comm-weighted length if weight is set
+      mySize.length = (MOVE_WEIGHT) ? wlen : len;
+      
+      histogramData.insert(histogramData.end(), mySize.moveInfo.begin(), mySize.moveInfo.end());
+
+      fileContents[lineFile] = mySize;
+      //errs() << lineFile << " " << mySize.width << " " << mySize.length << " " << mySize.mts << " " << mySize.moves << " " << mySize.tgates << "\n";
+    }
+    file.close(); 
+ }
+  else
+    errs() << "Error: Could not open comm_aware_schedule.txt file.\n";
+
+  //print fileContents
+  if(debugGenSIMDSchedCG){
+    errs() << "Printing fileContents:\n";
+    for(map<string, modularInfo >::iterator mit = fileContents.begin(); mit!=fileContents.end(); ++mit)
+      {
+        errs() << (*mit).first << ":" << (*mit).second.width << "," << (*mit).second.length << "\n";
+      }
+  }
+}
+
+bool GenSIMDSchedCG::check_if_pre_schedule(Function* F){
+  //check if the function has been scheduled by another algorithm
+  //eg: using communication aware algorithm
+  
+  //open the input file and search for function name
+  string fname = F->getName();
+  //errs() << "Func Name = " << fname << "\n";
+  //search for fname in fileContents
+  map<string, modularInfo >::iterator foundFn = fileContents.find(fname);
+  if(foundFn == fileContents.end()){
+    //errs() << "No function found\n";
+    return false;
+  }
+
+  funcInfo[F] = (*foundFn).second;
+
+  errs() << "SIMD k="<<RES_CONSTRAINT<<" d=" << DATA_CONSTRAINT << " " << F->getName() << " " << (*foundFn).second.width << " " << (*foundFn).second.length << " " << (*foundFn).second.moves << " " << (*foundFn).second.mts << " leaf= 1" << " (read from file)\n";
+
+  return true;
+
+}
+
+
+void GenSIMDSchedCG::analyzeCallInst(Function* F, Instruction* pInst){
+  if(CallInst *CI = dyn_cast<CallInst>(pInst))
+    {      
+      if(debugGenSIMDSchedCG)
+        errs() << "Call inst: " << CI->getCalledFunction()->getName() << "\n";
+
+      if(CI->getCalledFunction()->getName() == "store_cbit"){   //trace return values
+        return;
+      }      
+
+      vector<qGateArg> allDepQbit;                                  
+      
+      bool tracked_all_operands = true;
+
+      int myPrepState = -1;
+      double myRotationAngle = 0.0;
+      
+      for(unsigned iop=0;iop<CI->getNumArgOperands();iop++){
+        tmpDepQbit.clear();
+        
+        qGateArg tmpQGateArg;
+        btCount=0;
+        
+        tmpQGateArg.argNum = iop;
+        
+        
+        if(isa<UndefValue>(CI->getArgOperand(iop))){
+          errs() << "WARNING: LLVM IR code has UNDEF values. \n";
+          tmpQGateArg.isUndef = true;   
+          //exit(1);
+        }
+        
+        Type* argType = CI->getArgOperand(iop)->getType();
+        if(argType->isPointerTy()){
+          tmpQGateArg.isPtr = true;
+          Type *argElemType = argType->getPointerElementType();
+          if(argElemType->isIntegerTy(16))
+            tmpQGateArg.isQbit = true;
+          if(argElemType->isIntegerTy(1))
+            tmpQGateArg.isCbit = true;
+        }
+        else if(argType->isIntegerTy(16)){
+          tmpQGateArg.isQbit = true;
+          tmpQGateArg.valOrIndex = 0;    
+        }               
+        else if(argType->isIntegerTy(1)){
+          tmpQGateArg.isCbit = true;
+          tmpQGateArg.valOrIndex = 0;    
+        }
+
+
+        //check if argument is constant int
+        if(ConstantInt *CInt = dyn_cast<ConstantInt>(CI->getArgOperand(iop))){
+          myPrepState = CInt->getZExtValue();     
+        }
+        
+        //check if argument is constant float
+        if(ConstantFP *CFP = dyn_cast<ConstantFP>(CI->getArgOperand(iop))){
+          myRotationAngle = CFP->getValueAPF().convertToDouble();
+        }               
+        
+        //if(tmpQGateArg.isQbit || tmpQGateArg.isCbit){
+        if(tmpQGateArg.isQbit){
+            tmpDepQbit.push_back(tmpQGateArg);  
+            tracked_all_operands &= backtraceOperand(CI->getArgOperand(iop),0);
+        }
+
+        if(tmpDepQbit.size()>0){          
+          allDepQbit.push_back(tmpDepQbit[0]);
+          assert(tmpDepQbit.size() == 1 && "tmpDepQbit SIZE GT 1");
+          tmpDepQbit.clear();
+        }
+        
+      }
+      
+      if(allDepQbit.size() > 0){
+        if(debugGenSIMDSchedCG)
+        {
+            errs() << "\nCall inst: " << CI->getCalledFunction()->getName();        
+            errs() << ": Found all arguments: ";       
+            for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+              if(allDepQbit[vb].argPtr)
+                errs() << allDepQbit[vb].argPtr->getName() <<" Index: ";
+                                
+              //else
+                errs() << allDepQbit[vb].valOrIndex <<" ";
+            }
+            errs()<<"\n";
+            
+        }
+
+
+        //check if Intrinsic
+        bool thisFuncIsIntrinsic = checkIfIntrinsic(CI->getCalledFunction());
+        if(!thisFuncIsIntrinsic) hasPrimitivesOnly = false;
+          
+       string fname =  CI->getCalledFunction()->getName();  
+       qGate thisGate;
+       thisGate.qFunc =  CI->getCalledFunction();
+
+       if(myPrepState!=-1) thisGate.angle = (float)myPrepState;
+       if(myRotationAngle!=0.0) thisGate.angle = myRotationAngle;
+
+       for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+            if(allDepQbit[vb].argPtr){
+              //errs() << allDepQbit[vb].argPtr->getName() <<" Index: ";
+              //errs() << allDepQbit[vb].valOrIndex <<"\n";
+                qGateArg param =  allDepQbit[vb];       
+                //errs() << "1\n";
+                thisGate.args[thisGate.numArgs].name = param.argPtr->getName();
+                //errs() << "2\n";
+                if(!param.isPtr)
+                  thisGate.args[thisGate.numArgs].index = param.valOrIndex;
+                //errs() << "3\n";
+                thisGate.numArgs++;
+                //errs() << "4\n";
+            }
+       }
+       //errs() << "5\n";
+
+
+       uint64_t thisTS = calc_critical_time_unbounded(F,thisGate);       
+       //update priorityVector
+       priorityVector.push_back(make_pair(pInst,thisTS));
+
+       //add to mapInstSet
+       mapInstSet[pInst] = thisGate;
+
+      }    
+      allDepQbit.erase(allDepQbit.begin(),allDepQbit.end());
+    }
+}
+
+
+void GenSIMDSchedCG::saveTableFuncQbits(Function* F){
+  map<unsigned int, map<int, uint64_t> > tmpFuncQbitsMap;
+
+  for(map<string, map<int, uint64_t> >::iterator mapIt = funcQbits.begin(); mapIt!=funcQbits.end(); ++mapIt){
+    map<string, unsigned int>::iterator argIt = funcArgs.find((*mapIt).first);
+    if(argIt!=funcArgs.end()){
+      unsigned int argNum = (*argIt).second;
+      tmpFuncQbitsMap[argNum] = (*mapIt).second;
+    }
+  }
+  tableFuncQbits[F] = tmpFuncQbitsMap;
+}
+
+
+void GenSIMDSchedCG::CountCriticalFunctionResources (Function *F) {
+      // Traverse instruction by instruction
+  init_critical_path_algo(F);
+  
+
+  //get qbits in function
+  for (inst_iterator I = inst_begin(*F), E = inst_end(*F); I != E; ++I) {
+    Instruction *Inst = &*I;                            // Grab pointer to instruction reference
+    analyzeAllocInst(F,Inst);          
+    if(!isa<AllocaInst>(Inst))
+      break;
+  }
+
+  //errs() << "Finding priorities--- \n";
+  //find priorities for instructions
+  for (inst_iterator I = inst_begin(*F), E = inst_end(*F); I != E; ++I) {
+    Instruction *Inst = &*I;                            // Grab pointer to instruction reference
+    if(isa<CallInst>(Inst))
+      vectCalls.push_back(Inst);
+  }
+
+  //traverse in reverse sequence
+  for(vector<Instruction*>::reverse_iterator rit = vectCalls.rbegin(); rit!=vectCalls.rend(); ++rit)
+    analyzeCallInst(F,(*rit));  
+
+  //is function leaf or not?
+  if(hasPrimitivesOnly) isLeaf.push_back(F);
+
+  //reset funcQbits vector in preparation for scheduling
+  memset_funcQbits(0);
+
+  //sort vector
+  sort(priorityVector.begin(), priorityVector.end(), CompareInstPriByValue());
+
+  //errs() << "Finding Schedule--- \n";
+
+  //check if this function has a schedule from a different scheduling algo
+  bool has_pre_schedule = false;
+  has_pre_schedule = check_if_pre_schedule(F);
+  
+  if(!has_pre_schedule){
+    for(vector<InstPri>::reverse_iterator vit = priorityVector.rbegin(); vit!=priorityVector.rend(); ++vit){
+      //get qgate
+      map<Instruction*, qGate>::iterator mit = mapInstSet.find((*vit).first);
+      assert(mit!=mapInstSet.end() && "Instruction Not Found in MapInstSet.");
+      
+      qGate thisGate = (*mit).second;
+      
+      if(hasPrimitivesOnly){
+        calc_critical_time(F,thisGate,true);
+      }
+      else
+        calc_critical_time(F,thisGate,false);
+      
+    }   
+    saveTableFuncQbits(F);  
+    save_blackbox_info(F);
+  }
+  //print_ArrParGates();
+  //print_tableFuncQbits();
+
+}
+
+
+void GenSIMDSchedCG::init_gates_as_functions(){
+    
+    //add blackbox entry for each of these ??
+    
+  for(int  i =0; i< NUM_QGATES ; i++){
+    string gName = gate_name[i];
+    string fName = "llvm.";
+    fName.append(gName);
+    
+  }
+
+}
+
+
+bool GenSIMDSchedCG::runOnModule (Module &M) {
+  init_gate_names();
+  init_gates_as_functions();
+  
+  read_schedule_file();
+
+  // iterate over all functions, and over all instructions in those functions
+  CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+  
+  //Post-order
+  for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode), E = scc_end(rootNode); sccIb != E; ++sccIb) {
+    const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+    for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(), E = nextSCC.end(); nsccI != E; ++nsccI) {
+      Function *F = (*nsccI)->getFunction();      
+            
+      if(F && !F->isDeclaration()){
+        errs() << "\n#Function " << F->getName() << "\n";      
+        //errs() << "#Timestep GateName Operand1 Operand2 \n";
+        
+        funcQbits.clear();
+        funcArgs.clear();
+        vectCalls.clear();
+        mapInstSet.clear();
+        priorityVector.clear();
+        
+        getFunctionArguments(F);
+
+        // count the critical resources for this function
+        CountCriticalFunctionResources(F);
+
+        if(F->getName() == "main"){
+          //print_ArrParGates(F);
+         
+	  //Print Histogram Data
+	  ofstream outputFile;    
+          outputFile.open("histogram_data.txt");
+          // outputFile << "\nHistogram Data\n" << endl;
+          ostream_iterator<int> output_iterator(outputFile, " ");
+          copy(histogramData.begin(), histogramData.end(), output_iterator);
+
+          errs() << "\n#Num of SIMD time steps for function main : " << getNumCritSteps(F) << "\n";               
+        }
+
+        //print_critical_info();
+        //errs() << "#EndFunction\n";
+        cleanupCurrArrParGates(); 
+      }
+      else{
+            if(debugGenSIMDSchedCG)
+              errs() << "WARNING: Ignoring external node or dummy function.\n";
+          }
+    }
+  }
+  //print_tableFuncQbits();
+  //print_parallelism();
+
+  return false;
+} // End runOnModule
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GenSIMDSchedule.cpp llvm/lib/Transforms/Scaffold/GenSIMDSchedule.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GenSIMDSchedule.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/GenSIMDSchedule.cpp	2017-10-12 11:09:31.093119606 +0800
@@ -0,0 +1,1508 @@
+//===----------------- GenSIMDSched.cpp ----------------------===//
+// This file implements the Scaffold Pass of counting the number 
+//  of critical timesteps and gate parallelism in program
+//  in callgraph post-order.
+//
+//        This file was created by Scaffold Compiler Working Group
+// Fine-grained list scheduling for leaf modules
+// Coarse-grained scheduling for non-leaf modules
+// Get T gate proportion within schedule length
+// Cleaned up the code
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "GenSIMDSched"
+#include <vector>
+#include <limits>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/ADT/SCCIterator.h"
+#include "llvm/Argument.h"
+#include "llvm/ADT/ilist.h"
+#include "llvm/Constants.h"
+#include "llvm/IntrinsicInst.h"
+#include "llvm/Support/CommandLine.h"
+
+
+using namespace llvm;
+using namespace std;
+
+
+static cl::opt<unsigned>
+RES_CONSTRAINT("simd-kconstraint", cl::init(10), cl::Hidden,
+  cl::desc("k in SIMD-k Resource Constrained Scheduling"));
+
+static cl::opt<unsigned>
+DATA_CONSTRAINT("simd-dconstraint", cl::init(1024), cl::Hidden,
+  cl::desc("k in SIMD-k Resource Constrained Scheduling"));
+
+#define MAX_RES_CONSTRAINT 2000 
+#define SSCHED_THRESH 10000000
+
+#define MAX_GATE_ARGS 30
+#define MAX_BT_COUNT 15 //max backtrace allowed - to avoid infinite recursive loops
+#define NUM_QGATES 17
+#define _CNOT 0
+#define _H 1
+#define _S 2
+#define _T 3
+#define _X 4
+#define _Y 5
+#define _Z 6
+#define _MeasX 7
+#define _MeasZ 8
+#define _PrepX 9
+#define _PrepZ 10
+#define _Tdag 11
+#define _Sdag 12
+#define _Rz 13
+#define _Toffoli 14
+#define _Fredkin 15
+#define _All 16
+
+bool debugGenSIMDSched = false;
+
+namespace {
+
+  typedef pair<Instruction*, uint64_t> InstPri; //instpriority
+  
+  struct CompareInstPriByValue {
+    bool operator() (const InstPri& a, const InstPri& b) const {
+      return a.second < b.second;
+    };
+  };
+
+  struct modularInfo{
+    uint64_t width;
+    uint64_t length;
+    //uint64_t ancilla;
+    uint64_t tgates;
+    uint64_t tgates_ub;
+    uint64_t tgates_par;
+    uint64_t tgates_par_ub;
+    modularInfo(): width(0), length(0), tgates(0), tgates_ub(0), tgates_par(0), tgates_par_ub(0) {}
+  };
+
+
+  struct qGateArg{ //arguments to qgate calls
+    Value* argPtr;
+    int argNum;
+    bool isQbit;
+    bool isCbit;
+    bool isAbit;
+    bool isUndef;
+    bool isPtr;
+    int valOrIndex; //Value if not Qbit, Index if Qbit & not a Ptr
+    double angle;
+    qGateArg(): argPtr(NULL), argNum(-1), isQbit(false), isCbit(false), isAbit(false), isUndef(false), isPtr(false), valOrIndex(-1), angle(0.0){ }
+  };
+  
+struct qArgInfo{
+  string name;
+  int index;
+  qArgInfo(): name("none"), index(-1){ }
+};
+
+struct qGate{
+  Function* qFunc;
+  int numArgs;
+  qArgInfo args[MAX_GATE_ARGS];
+  double angle;
+  qGate():qFunc(NULL), numArgs(0), angle(0.0) { }
+};
+
+  struct ArrParGates{
+    int typeOfGate[MAX_RES_CONSTRAINT];
+    uint64_t numGates[MAX_RES_CONSTRAINT];
+  };
+
+  struct GenSIMDSched : public ModulePass {
+    static char ID; // Pass identification
+    
+    string gate_name[NUM_QGATES];
+    vector<qGateArg> tmpDepQbit;
+    vector<Value*> vectQbit;
+    
+    int btCount; //backtrace count
+
+    modularInfo totalSched;
+    modularInfo currSched;
+
+    map<string, int> gate_index;    
+
+    map<string, map<int,uint64_t> > funcQbits; //qbits in current function
+    map<Function*, map<unsigned int, map<int,uint64_t> > > tableFuncQbits;
+    map<string, unsigned int> funcArgs;
+
+    vector<ArrParGates> currArrParGates;
+
+    map<Instruction*, qGate> mapInstSet;
+    vector<InstPri> priorityVector;
+
+    vector<Instruction*> vectCalls;
+
+    map<Function*, modularInfo> funcInfo;
+    vector<Function*> isLeaf;
+    bool hasPrimitivesOnly;
+
+    bool isFirstMeas;
+
+    GenSIMDSched() : ModulePass(ID) {}
+    
+    // Get arguments from operation
+    bool backtraceOperand(Value* opd, int opOrIndex);
+    // 
+    void analyzeAllocInst(Function* F,Instruction* pinst);
+    void analyzeCallInst(Function* F,Instruction* pinst);
+    void getFunctionArguments(Function *F);
+    
+    void saveTableFuncQbits(Function* F);
+    void print_tableFuncQbits();
+    void print_parallelism(Function* F);
+    void print_ArrParGates();
+    void cleanupCurrArrParGates();
+    bool checkIfIntrinsic(Function* CF);
+
+    void init_gate_names(){
+        gate_name[_CNOT] = "CNOT";
+        gate_name[_H] = "H";
+        gate_name[_S] = "S";
+        gate_name[_T] = "T";
+        gate_name[_Toffoli] = "Toffoli";
+        gate_name[_X] = "X";
+        gate_name[_Y] = "Y";
+        gate_name[_Z] = "Z";
+        gate_name[_MeasX] = "MeasX";
+        gate_name[_MeasZ] = "MeasZ";
+        gate_name[_PrepX] = "PrepX";
+        gate_name[_PrepZ] = "PrepZ";
+        gate_name[_Sdag] = "Sdag";
+        gate_name[_Tdag] = "Tdag";
+        gate_name[_Fredkin] = "Fredkin";
+        gate_name[_Rz] = "Rz";
+        gate_name[_All] = "All";                    
+        
+        gate_index["CNOT"] = _CNOT;        
+        gate_index["H"] = _H;
+        gate_index["S"] = _S;
+        gate_index["T"] = _T;
+        gate_index["Toffoli"] = _Toffoli;
+        gate_index["X"] = _X;
+        gate_index["Y"] = _Y;
+        gate_index["Z"] = _Z;
+        gate_index["Sdag"] = _Sdag;
+        gate_index["Tdag"] = _Tdag;
+        gate_index["MeasX"] = _MeasX;
+        gate_index["MeasZ"] = _MeasZ;
+        gate_index["PrepX"] = _PrepX;
+        gate_index["PrepZ"] = _PrepZ;
+        gate_index["Fredkin"] = _Fredkin;
+        gate_index["Rz"] = _Rz;
+        gate_index["All"] = _All;                    
+        }
+
+        
+
+    void init_gates_as_functions();    
+    void init_critical_path_algo(Function* F);
+    void calc_critical_time(Function* F, qGate qg, bool isLeafFunc);        
+    void print_funcQbits();
+    void print_qgate(qGate qg);
+    void print_critical_info(); 
+
+    void print_scheduled_gate(qGate qg, uint64_t ts);
+
+    uint64_t find_max_funcQbits();
+    void memset_funcQbits(uint64_t val);
+    uint64_t get_ts_to_schedule(Function* F, uint64_t ts, Function* funcToSched, uint64_t& first_step);
+    uint64_t get_ts_to_schedule_leaf(Function* F, uint64_t ts, Function* funcToSched, uint64_t& first_step);
+
+    void save_blackbox_info(Function* F);
+    uint64_t calc_critical_time_unbounded(Function* F, qGate qg);        
+
+    void print_qgateArg(qGateArg qg)
+    {
+      errs()<< "Printing QGate Argument:\n";
+      if(qg.argPtr) errs() << "  Name: "<<qg.argPtr->getName()<<"\n";
+      errs() << "  Arg Num: "<<qg.argNum<<"\n"
+             << "  isUndef: "<<qg.isUndef
+             << "  isQbit: "<<qg.isQbit
+             << "  isAbit: "<<qg.isAbit
+             << "  isCbit: "<<qg.isCbit
+             << "  isPtr: "<<qg.isPtr << "\n"
+             << "  Value or Index: "<<qg.valOrIndex<<"\n";
+    }                    
+    
+    uint64_t getNumCritSteps(Function* F){
+      map<Function*, modularInfo>::iterator mf = funcInfo.find(F);
+      assert(mf!=funcInfo.end());
+      return (mf->second.length);
+    }
+
+    void CountCriticalFunctionResources (Function *F);
+    
+    bool runOnModule (Module &M);    
+    
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();  
+      AU.addRequired<CallGraph>();    
+    }
+    
+  }; // End of struct GenSIMDSched
+} // End of anonymous namespace
+
+
+
+char GenSIMDSched::ID = 0;
+static RegisterPass<GenSIMDSched> X("GenSIMDSchedule", "Generate SIMD Schedule");
+
+void GenSIMDSched::getFunctionArguments(Function* F)
+{
+  for(Function::arg_iterator ait=F->arg_begin();ait!=F->arg_end();++ait)
+    {    
+      //if(ait) errs() << "Argument: "<<ait->getName()<< " ";
+
+      string argName = (ait->getName()).str();
+      Type* argType = ait->getType();
+      unsigned int argNum=ait->getArgNo();         
+
+      qGateArg tmpQArg;
+      tmpQArg.argPtr = ait;
+      tmpQArg.argNum = argNum;
+
+      if(argType->isPointerTy()){
+        tmpQArg.isPtr = true;
+
+        Type *elementType = argType->getPointerElementType();
+        if (elementType->isIntegerTy(16)){ //qbit*
+          tmpQArg.isQbit = true;
+          vectQbit.push_back(ait);
+          
+          map<int,uint64_t> tmpMap;
+          tmpMap[-1] = 0; //add entry for entire array
+          tmpMap[-2] = 0; //add entry for max     
+          funcQbits[argName]=tmpMap;      
+          funcArgs[argName] = argNum;
+        }
+        else if (elementType->isIntegerTy(1)){ //cbit*
+          tmpQArg.isCbit = true;
+          vectQbit.push_back(ait);
+          funcArgs[argName] = argNum;
+        }
+		else if (elementType->isIntegerTy(8)){
+		  tmpQArg.isAbit = true;
+		  vectQbit.push_back(ait);
+		  funcArgs[argName] = argNum;
+		}
+      }
+      else if (argType->isIntegerTy(16)){ //qbit
+        tmpQArg.isQbit = true;
+        vectQbit.push_back(ait);
+
+          map<int,uint64_t> tmpMap;
+          tmpMap[-1] = 0; //add entry for entire array
+          tmpMap[-2] = 0; //add entry for max
+          funcQbits[argName]=tmpMap;
+          funcArgs[argName] = argNum;
+      }
+      else if (argType->isIntegerTy(1)){ //cbit
+        tmpQArg.isCbit = true;
+        vectQbit.push_back(ait);
+          funcArgs[argName] = argNum;
+      }
+      else if (argType->isIntegerTy(8)){
+		  tmpQArg.isAbit = true;
+		  vectQbit.push_back(ait);
+		  funcArgs[argName] = argNum;
+		}
+    }
+}
+
+bool GenSIMDSched::backtraceOperand(Value* opd, int opOrIndex)
+{
+  if(opOrIndex == 0) //backtrace for operand
+    {
+      //search for opd in qbit/cbit vector
+      vector<Value*>::iterator vIter=find(vectQbit.begin(),vectQbit.end(),opd);
+      if(vIter != vectQbit.end()){
+        tmpDepQbit[0].argPtr = opd;
+        
+        return true;
+      }
+      
+      if(btCount>MAX_BT_COUNT)
+        return false;
+      
+      if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(opd))
+        {
+
+          if(GEPI->hasAllConstantIndices()){
+            Instruction* pInst = dyn_cast<Instruction>(opd);
+            unsigned numOps = pInst->getNumOperands();
+
+            backtraceOperand(pInst->getOperand(0),0);
+            
+            //NOTE: getelemptr instruction can have multiple indices. Currently considering last operand as desired index for qubit. Check this reasoning. 
+            if(ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(numOps-1))){
+              if(tmpDepQbit.size()==1){
+                tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+              }
+            }
+          }
+          
+          else if(GEPI->hasIndices()){
+            
+            Instruction* pInst = dyn_cast<Instruction>(opd);
+            unsigned numOps = pInst->getNumOperands();
+            backtraceOperand(pInst->getOperand(0),0);
+
+            if((tmpDepQbit[0].isQbit||tmpDepQbit[0].isAbit) && !(tmpDepQbit[0].isPtr)){     
+              //NOTE: getelemptr instruction can have multiple indices. consider last operand as desired index for qubit. Check if this is true for all.
+              backtraceOperand(pInst->getOperand(numOps-1),1);
+              
+            }
+          }
+          else{     
+            Instruction* pInst = dyn_cast<Instruction>(opd);
+            unsigned numOps = pInst->getNumOperands();
+            for(unsigned iop=0;iop<numOps;iop++){
+              backtraceOperand(pInst->getOperand(iop),0);
+            }
+          }
+          return true;
+        }
+      
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+        unsigned numOps = pInst->getNumOperands();
+        for(unsigned iop=0;iop<numOps;iop++){
+          btCount++;
+          backtraceOperand(pInst->getOperand(iop),0);
+          btCount--;
+        }
+        return true;
+      }
+      else{
+        return true;
+      }
+    }
+  else if(opOrIndex == 0){ //opOrIndex == 1; i.e. Backtracing for Index    
+    if(btCount>MAX_BT_COUNT) //prevent infinite backtracing
+      return true;
+
+    if(ConstantInt *CI = dyn_cast<ConstantInt>(opd)){
+      tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+      return true;
+    }      
+
+    if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+      unsigned numOps = pInst->getNumOperands();
+      for(unsigned iop=0;iop<numOps;iop++){
+        btCount++;
+        backtraceOperand(pInst->getOperand(iop),1);
+        btCount--;
+      }
+    }
+
+  }
+  else{ //opOrIndex == 2: backtracing to call inst MeasZ
+    if(CallInst *endCI = dyn_cast<CallInst>(opd)){
+      if(endCI->getCalledFunction()->getName().find("llvm.Meas") != string::npos){
+        tmpDepQbit[0].argPtr = opd;
+
+        return true;
+      }
+      else{
+        if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+          unsigned numOps = pInst->getNumOperands();
+          bool foundOne=false;
+          for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+            btCount++;
+            foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+            btCount--;
+          }
+          return foundOne;
+        }
+      }
+    }
+    else{
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+        unsigned numOps = pInst->getNumOperands();
+        bool foundOne=false;
+        for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+          btCount++;
+          foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+          btCount--;
+        }
+        return foundOne;
+      }
+    }
+  }
+  return false;
+}
+
+
+void GenSIMDSched::analyzeAllocInst(Function* F, Instruction* pInst){
+  if (AllocaInst *AI = dyn_cast<AllocaInst>(pInst)) {
+    Type *allocatedType = AI->getAllocatedType();
+    
+    if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+      qGateArg tmpQArg;
+      
+      Type *elementType = arrayType->getElementType();
+      uint64_t arraySize = arrayType->getNumElements();
+      if (elementType->isIntegerTy(16)){
+        vectQbit.push_back(AI);
+        tmpQArg.isQbit = true;
+        tmpQArg.argPtr = AI;
+        tmpQArg.valOrIndex = arraySize;
+
+        map<int,uint64_t> tmpMap; //add qbit to funcQbits
+        tmpMap[-1] = 0; //entry for entire array ops
+        tmpMap[-2] = 0; //entry for max
+        funcQbits[AI->getName()]=tmpMap;
+
+      }
+
+	  if (elementType->isIntegerTy(8)){
+		vectQbit.push_back(AI);
+		tmpQArg.isAbit = true;
+		tmpQArg.argPtr = AI;
+		tmpQArg.valOrIndex = arraySize;
+
+		map<int,uint64_t> tmpMap; //add qbit to funcQbits
+        tmpMap[-1] = 0; //entry for entire array ops
+        tmpMap[-2] = 0; //entry for max
+        funcQbits[AI->getName()]=tmpMap;
+	  }
+
+      
+      if (elementType->isIntegerTy(1)){
+        vectQbit.push_back(AI); //Cbit added here
+        tmpQArg.isCbit = true;
+        tmpQArg.argPtr = AI;
+        tmpQArg.valOrIndex = arraySize;
+      }
+    }
+  }
+}
+
+
+void GenSIMDSched::init_critical_path_algo(Function* F){
+
+  currSched.width = 0;
+  currSched.length = 0;
+  currSched.tgates = 0;
+  currSched.tgates_ub = 0;
+  currSched.tgates_par = 0;
+  currSched.tgates_par_ub = 0;
+
+  totalSched.width = 0;
+  totalSched.length = 0;
+  totalSched.tgates = 0;
+  totalSched.tgates_ub = 0;
+  totalSched.tgates_par = 0;
+  totalSched.tgates_par_ub = 0;
+
+  isFirstMeas = true;
+
+  hasPrimitivesOnly = true;
+}
+
+void GenSIMDSched::print_funcQbits(){
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbits.begin(); mIter!=funcQbits.end(); ++mIter){
+    errs() << "Var "<< (*mIter).first << " ---> ";
+    for(map<int,uint64_t>::iterator indexIter  = (*mIter).second.begin(); indexIter!=(*mIter).second.end(); ++indexIter){
+      errs() << (*indexIter).first << ":"<<(*indexIter).second<< "  ";
+    }
+    errs() << "\n";
+  }
+}
+
+void GenSIMDSched::print_ArrParGates(){
+  errs() << "Printing ArrParGate Vector \n";
+    int j = 0;
+    for(vector<ArrParGates>::iterator vit = currArrParGates.begin(); vit!=currArrParGates.end(); ++vit, j++){
+      errs() << j << " -- ";
+      for(unsigned int i=0;i<RES_CONSTRAINT;i++)
+        errs() << (*vit).typeOfGate[i] << " : " << (*vit).numGates[i] << " ; ";
+      errs() << "\n";
+    }
+  
+}
+
+void GenSIMDSched::print_qgate(qGate qg){
+  errs() << qg.qFunc->getName() << " : ";
+  for(int i=0;i<qg.numArgs;i++){
+    errs() << qg.args[i].name << qg.args[i].index << ", "  ;
+  }
+  errs() << "\n";
+}
+
+uint64_t GenSIMDSched::get_ts_to_schedule(Function* F, uint64_t ts, Function* funcToSched, uint64_t& first_step){
+  //F is non-leaf. Treat all incoming function as blackboxes
+
+  //errs() << "\n funcTOSched = " << funcToSched->getName() << "\n";
+
+  //print_funcQbits();
+  //print_ArrParGates();
+
+  uint64_t Win = 0;
+  uint64_t Lin = 0;
+  uint64_t Tin = 0;
+  uint64_t TinUB = 0;
+  uint64_t TinPar = 0;
+  uint64_t TinParUB = 0;
+
+  if(checkIfIntrinsic(funcToSched)){
+    Win = 1;
+    Lin = 1;
+
+    if(funcToSched->getIntrinsicID() == Intrinsic::T
+       || funcToSched->getIntrinsicID() == Intrinsic::Tdag){
+      //errs() << "Found T or Tdag \n";
+      Lin = 100; //cost of T gate
+      Tin = 1;
+      TinUB = 1;
+      TinPar = 1;
+      TinParUB = 1;
+    }
+    else{
+      Tin = 0;
+      TinUB = 0;
+      TinPar = 0;
+      TinParUB = 0;
+    }
+  }
+  
+  else{
+    map<Function*, modularInfo>::iterator fin = funcInfo.find(funcToSched);
+    assert(fin!=funcInfo.end() && "Func not found in funcInfo");
+        
+    Win = (*fin).second.width; //width for incoming func
+    Lin = (*fin).second.length; //length for incoming func 
+    Tin = (*fin).second.tgates; //tgates for incoming func  
+    TinUB = (*fin).second.tgates_ub; //tgates for incoming func  
+    TinPar = (*fin).second.tgates_par; //tgates for incoming func  
+    TinParUB = (*fin).second.tgates_par_ub;
+  }
+
+  //errs() << "Curr Width = " << currSched.width << " Curr Length = " << currSched.length << " CurrTgates = " << currSched.tgates << "\n";
+  //errs() << "Func Width = " << Win << " Func Length = " << Lin <<  " Func Tgates = " << Tin << "\n";
+  //errs() << "Total Width = " << currSched.width << " Total Length = " << totalSched.length << "TS = " << ts  << " TotalTgates = " << totalSched.tgates <<"\n";
+
+
+  if(ts < totalSched.length+currSched.length){ //might be able to parallelize  
+    if((Win + currSched.width) <= RES_CONSTRAINT) //Hooray, can be parallelized
+      {
+        //first_step = totalSched.length; //where the func got scheduled
+        first_step = max(ts,totalSched.length); //where the func got scheduled
+        currSched.width += Win;
+        //currSched.length = max(Lin, currSched.length);
+        currSched.length = max(first_step - totalSched.length + Lin, currSched.length);
+        currSched.tgates = max(Tin, currSched.tgates);
+        currSched.tgates_ub = min(TinUB+currSched.tgates_ub, currSched.length);
+        currSched.tgates_par = max(TinPar, currSched.tgates_par);
+        currSched.tgates_par_ub = min(TinParUB+currSched.tgates_par_ub, currSched.width);
+        //errs() << "Parallel. New Width = " << currSched.width << " New Length = " << currSched.length << " New Tgates = " << currSched.tgates << " Tpar= " << currSched.tgates_par << " TparUB=" << currSched.tgates_par_ub << "\n";
+         }
+    else // must be serialized due to SIMD-k constraint
+      {
+
+        first_step = totalSched.length+currSched.length; //where the func got scheduled
+
+        totalSched.width = max(totalSched.width,currSched.width);
+        totalSched.length += currSched.length;
+        totalSched.tgates += currSched.tgates;
+        totalSched.tgates_ub += currSched.tgates_ub;
+        totalSched.tgates_par = max(totalSched.tgates_par,currSched.tgates_par);
+        totalSched.tgates_par_ub = max(totalSched.tgates_par_ub,currSched.tgates_par_ub);
+        
+
+        currSched.length = Lin; //create new
+        currSched.width = Win; //create new W
+        currSched.tgates = Tin; //create new W
+        currSched.tgates_ub = TinUB; //create new W
+        currSched.tgates_par = TinPar; //create new W
+        currSched.tgates_par_ub = TinParUB; //create new W
+        //errs() << "Serial(SIMD-k). New Width = " << currSched.width << " New Length = " << currSched.length << " New Tgates= " << currSched.tgates<< " New TgatesUB= " << currSched.tgates_ub<< " New TgatesPar= " << currSched.tgates_par<< " TparUB=" << currSched.tgates_par_ub << "\n";
+      }
+  }
+
+  else //cannot parallelize due to data dependency
+    {
+      //first_step = currSched.length; //where the func got scheduled
+      first_step = totalSched.length+currSched.length; //where the func got scheduled
+      totalSched.width = max(totalSched.width,currSched.width);
+      totalSched.length += currSched.length;
+      totalSched.tgates += currSched.tgates;
+      totalSched.tgates_ub += currSched.tgates_ub;
+      totalSched.tgates_par = max(totalSched.tgates_par,currSched.tgates_par);
+      totalSched.tgates_par_ub = max(totalSched.tgates_par_ub,currSched.tgates_par_ub);
+
+      currSched.length = Lin; //create new L
+      currSched.width = Win; //create new W
+      currSched.tgates = Tin; //create new T
+      currSched.tgates_ub = TinUB; //create new W
+      currSched.tgates_par = TinPar; //create new W
+      currSched.tgates_par_ub = TinParUB; //create new W
+
+      //errs() << "Serial(Dependency). New Width = " << currSched.width << " New Length = " << currSched.length << " TotalW=" << totalSched.width << " TotalL=" << totalSched.length << " TotalT=" << totalSched.tgates << " TotalT_UB=" << totalSched.tgates_ub << " TotalTPar=" << totalSched.tgates_par << " TotalTParUB=" << totalSched.tgates_par_ub << "\n";
+    }
+
+  return (totalSched.length+currSched.length)-1; //where the last dependency should be recorded
+  //return (currSched.length)-1; //where the last dependency should be recorded
+}
+
+
+uint64_t GenSIMDSched::get_ts_to_schedule_leaf(Function* F, uint64_t ts, Function* funcToSched, uint64_t& first_step){
+
+  //errs() << " funcTOSched = " << funcToSched->getName() << "\n";
+  //errs() << " Size of currSched = " << currArrParGates.size() << "\n";
+
+  //F is leaf. Treat all incoming functions with respect  
+  int funcIndex = -1;
+
+  assert(funcToSched->getName().str().find("llvm.")!=string::npos &&  "Non-Intrinsic Func Found in Leaf Function"); 
+
+  std::string intrinsic_overloaded_name = funcToSched->getName().str();
+  
+  if(intrinsic_overloaded_name.find("CNOT.i") != string::npos) intrinsic_overloaded_name = "CNOT";
+  else if(intrinsic_overloaded_name.find("NOT.i") != string::npos) intrinsic_overloaded_name = "X";
+  else if(intrinsic_overloaded_name.find("Toffoli.i") != string::npos) intrinsic_overloaded_name = "Toffoli";
+  else if(intrinsic_overloaded_name.find("MeasX.") != string::npos) intrinsic_overloaded_name = "MeasX";
+  else if(intrinsic_overloaded_name.find("MeasZ.") != string::npos) intrinsic_overloaded_name = "MeasZ";
+  else if(intrinsic_overloaded_name.find("H.i") != string::npos) intrinsic_overloaded_name = "H";
+  else if(intrinsic_overloaded_name.find("Fredkin.i") != string::npos) intrinsic_overloaded_name = "Fredkin";
+  else if(intrinsic_overloaded_name.find("PrepX.") != string::npos) intrinsic_overloaded_name = "PrepX";
+  else if(intrinsic_overloaded_name.find("PrepZ.") != string::npos) intrinsic_overloaded_name = "PrepZ";
+  else if(intrinsic_overloaded_name.substr(0,2) == "Rz") intrinsic_overloaded_name = "Rz";
+  else if(intrinsic_overloaded_name.find("S.") != string::npos) intrinsic_overloaded_name = "S";
+  else if(intrinsic_overloaded_name.find("T.") != string::npos) intrinsic_overloaded_name = "T";
+  else if(intrinsic_overloaded_name.find("Sdag.") != string::npos) intrinsic_overloaded_name = "Sdag";
+  else if(intrinsic_overloaded_name.find("Tdag.") != string::npos) intrinsic_overloaded_name = "Tdag";
+  else if(intrinsic_overloaded_name.find("X.") != string::npos) intrinsic_overloaded_name = "X";
+  else if(intrinsic_overloaded_name.find("Z.") != string::npos) intrinsic_overloaded_name = "Z";
+
+  
+//  map<string, int>::iterator gidx = gate_index.find(funcToSched->getName().str().substr(5));
+  map<string, int>::iterator gidx = gate_index.find(intrinsic_overloaded_name);
+
+  assert(gidx!=gate_index.end() && "No Gate Index Found for this Intrinsic Function");
+  funcIndex = (*gidx).second;
+
+  //schedule intrinsic function
+
+  uint64_t retVal = 0;
+  bool FirstEntrySched = false;
+
+  int costOfGate = 1;
+
+  /*if(funcIndex == _T || funcIndex == _Tdag)
+    costOfGate = 10;*/
+
+  for(int c = 0; c<costOfGate; c++){
+    bool foundEntry = false;
+  
+    int searchFuncIndex = funcIndex+c*20;
+  
+    for(uint64_t i = ts; (i<currArrParGates.size() && !foundEntry); i++){
+      for(unsigned int j = 0; (j<RES_CONSTRAINT && !foundEntry); j++){
+        //if((currArrParGates[i].typeOfGate[j] == searchFuncIndex) && (currArrParGates[i].numGates[j] < DATA_CONSTRAINT)){
+        if((currArrParGates[i].typeOfGate[j] == searchFuncIndex) && ((searchFuncIndex == _CNOT && 2*currArrParGates[i].numGates[j] < DATA_CONSTRAINT)
+                                || (searchFuncIndex != _CNOT && currArrParGates[i].numGates[j]< DATA_CONSTRAINT))){
+          currArrParGates[i].numGates[j] += 1;
+          if(!FirstEntrySched){
+            first_step = i;
+            FirstEntrySched = true;
+          }
+          
+          if((c==0) && (funcIndex == _T || funcIndex == _Tdag)){
+            if(currArrParGates[i].numGates[j] > currSched.tgates_par){
+              currSched.tgates_par = currArrParGates[i].numGates[j];
+              currSched.tgates_par_ub = currArrParGates[i].numGates[j];
+              //errs() << "Incr tgate_par \n";
+            }
+          }
+
+          //errs() << "GateType Parallelism. TS = " << i << " K-factor=" << j << " Tpar=" << currSched.tgates_par << " TparUB=" << currSched.tgates_par_ub <<"\n";
+          foundEntry = true;
+          retVal = i;
+          ts = i+1; //update value of ts to start with in next iteration
+          //return i;
+        }
+        else if(currArrParGates[i].typeOfGate[j] == -1){
+          currArrParGates[i].typeOfGate[j] = searchFuncIndex;
+          currArrParGates[i].numGates[j] = 1;
+          if(!FirstEntrySched){
+            first_step = i;
+            FirstEntrySched = true;
+          }
+          if(j >= currSched.width) //update currSched.width
+            currSched.width = j+1;
+          
+          //Add to T gate count if T or Tdag gate
+          if((c==0) && (funcIndex == _T || funcIndex == _Tdag)){
+            //errs() << "Found T or Tdag \n";
+            
+            bool prevTgateFound = false;
+            for(unsigned int jcheck=0; jcheck<RES_CONSTRAINT; jcheck++){
+              if(currArrParGates[i].typeOfGate[jcheck] == _T
+                 || currArrParGates[i].typeOfGate[jcheck] == _Tdag)
+                prevTgateFound = true;
+            }
+            if(!prevTgateFound){
+              currSched.tgates++;
+              currSched.tgates_ub++;
+              if(currSched.tgates_par == 0){
+                currSched.tgates_par = 1;
+                currSched.tgates_par_ub = 1;
+                }
+              //errs() << "--Incr tgate \n";
+            }
+          }
+          
+          //errs() << "Unscheduled. New Width = " << currSched.width << " New Length = " << currSched.length << " Tgates=" << currSched.tgates << " TgatesUB=" << currSched.tgates_ub << " TgatesPar=" << currSched.tgates_par << " TgatesParUB=" << currSched.tgates_par_ub <<" K-factor=" << j <<"\n";
+          foundEntry = true;
+          retVal = i;
+          ts = i+1;
+          //return i;
+        }
+      }
+    }
+  
+    if(!foundEntry){
+      //suitable ts not found, create a new ts for this type of gate
+      //add entry to vectArrParGates
+      
+      ArrParGates tmpArrPar; //initialize
+      for(unsigned int k=0;k<RES_CONSTRAINT; k++){
+        tmpArrPar.typeOfGate[k] = -1;
+        tmpArrPar.numGates[k] = 0;
+      }
+  
+      tmpArrPar.typeOfGate[0] = searchFuncIndex;
+      tmpArrPar.numGates[0] = 1;
+      currArrParGates.push_back(tmpArrPar);
+      if(!FirstEntrySched){
+        first_step = currArrParGates.size()-1;
+        FirstEntrySched = true;
+      }
+
+      if((c==0) && (funcIndex == _T || funcIndex == _Tdag)){
+        currSched.tgates++;
+        currSched.tgates_ub++;
+        //errs() << "Incr tgates \n";
+        if(currSched.tgates_par == 0){
+          currSched.tgates_par = 1;
+          currSched.tgates_par_ub = 1;
+          }
+      }
+      
+      if(currSched.width == 0) //update currSched.width
+        currSched.width = 1;
+      currSched.length++;
+      
+      //errs() << "NEW TS. New Width = " << currSched.width << " New Length = " << currSched.length << " T gates = " << currSched.tgates << " TgatesUB=" << currSched.tgates_ub << " TgatesPar=" << currSched.tgates_par << " TgatesParUB=" << currSched.tgates_par_ub<< "\n";
+      
+      retVal = currArrParGates.size()-1;
+      ts = currArrParGates.size();
+
+      //return currArrParGates.size()-1;
+    } 
+  } // cost Of Gate
+  
+  //print_ArrParGates();
+  return retVal;
+  
+}
+
+void GenSIMDSched::cleanupCurrArrParGates(){
+    currArrParGates.clear();    
+}
+
+/*bool GenSIMDSched::checkTgatePar(Function* F, uint64_t par){
+  //is function leaf?
+  vector<Function*>::iterator vit = find(isLeaf.begin(), isLeaf.end(), F);
+  if(vit==isLeaf.end()) //not a leaf
+    return true;
+
+  //is Leaf
+  //iterate over currArrParGates and check for 
+
+  }*/
+
+void GenSIMDSched::save_blackbox_info(Function* F){
+  //save black box info
+  modularInfo tmpMod;
+
+  tmpMod.width = max(totalSched.width,currSched.width);
+  tmpMod.length = totalSched.length + currSched.length;
+  tmpMod.tgates = totalSched.tgates + currSched.tgates;
+  tmpMod.tgates_ub = totalSched.tgates_ub + currSched.tgates_ub;
+
+  //check if leaf function
+  //if leaf go thru currArrParGates vector and find T parallelism
+
+  //if not leaf function
+  tmpMod.tgates_par = max(totalSched.tgates_par,currSched.tgates_par);
+  tmpMod.tgates_par_ub = max(totalSched.tgates_par_ub,currSched.tgates_par_ub);
+
+  //bool checkTgatePar = checkTgatePar(F,tmpMod.tgates_par);
+
+  funcInfo[F] = tmpMod;
+
+  bool funcIsLeaf = true;
+  vector<Function*>::iterator vit = find(isLeaf.begin(), isLeaf.end(), F);
+  if(vit==isLeaf.end()) //not a leaf
+    funcIsLeaf=false;
+  
+  //errs() << "SIMD k="<<RES_CONSTRAINT<<" d=" << DATA_CONSTRAINT << " " << F->getName() << " " << tmpMod.width << " " << tmpMod.length << " " <<tmpMod.tgates << " " << tmpMod.tgates_ub << " " << tmpMod.tgates_par<< " " << tmpMod.tgates_par_ub << " leaf=" << funcIsLeaf << "\n";
+
+}
+
+
+void GenSIMDSched::print_critical_info(){
+    errs() << "Timesteps = " << currArrParGates.size() << "\n";
+    for(unsigned int i = 0; i<currArrParGates.size(); i++){
+        errs() << i << " :";
+        for(unsigned int k=0;k<RES_CONSTRAINT;k++){      
+          errs() << currArrParGates[i].typeOfGate[k] << " : " << currArrParGates[i].numGates[k] << " / ";
+        }
+        errs() << "\n";
+    }
+}
+
+void GenSIMDSched::print_parallelism(Function* F){
+  uint64_t maxGates[NUM_QGATES];
+  for(int k = 0; k<NUM_QGATES; k++)
+    maxGates[k] = 0;
+
+  for(vector<ArrParGates>::iterator vit = currArrParGates.begin(); vit!=currArrParGates.end(); ++vit){
+    for(unsigned int i = 0; i<RES_CONSTRAINT; i++)
+      if((*vit).numGates[i] > maxGates[(*vit).typeOfGate[i]])
+        maxGates[(*vit).typeOfGate[i]] = (*vit).numGates[i];
+  }
+
+  errs() << "\nMax Parallelism Factors: \n";
+  for(int k = 0; k<NUM_QGATES-1; k++){ //do not print 'All'
+    errs() << gate_name[k] << " : " << maxGates[k] << "\n";
+  }  
+}
+
+uint64_t GenSIMDSched::find_max_funcQbits(){
+  uint64_t max_timesteps = 0;
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbits.begin(); mIter!=funcQbits.end(); ++mIter){
+    map<int,uint64_t>::iterator arrIter = (*mIter).second.find(-2); //max ts is in -2 entry
+    if((*arrIter).second > max_timesteps)
+      max_timesteps = (*arrIter).second;
+  }
+
+  //print_funcQbits();
+  //errs() << "Max timestep = " << max_timesteps << "\n";
+  return max_timesteps;
+
+}
+
+void GenSIMDSched::memset_funcQbits(uint64_t val){
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbits.begin(); mIter!=funcQbits.end(); ++mIter){
+    for(map<int,uint64_t>::iterator arrIter = (*mIter).second.begin(); arrIter!=(*mIter).second.end();++arrIter)
+      (*arrIter).second = val;
+  }
+}
+
+void GenSIMDSched::print_scheduled_gate(qGate qg, uint64_t ts){
+  string tmpGateName = qg.qFunc->getName();
+  if(tmpGateName.find("CNOT.") != string::npos) tmpGateName = "CNOT";
+  else if(tmpGateName.find("NOT.") != string::npos) tmpGateName = "X";
+  else if(tmpGateName.find("Toffoli.") != string::npos) tmpGateName = "Toffoli";
+  else if(tmpGateName.find("MeasX.") != string::npos) tmpGateName = "MeasX";
+  else if(tmpGateName.find("MeasZ.") != string::npos) tmpGateName = "MeasZ";
+  else if(tmpGateName.find("H.i") != string::npos) tmpGateName = "H";
+  else if(tmpGateName.find("Fredkin.") != string::npos) tmpGateName = "Fredkin";
+  else if(tmpGateName.find("PrepX.") != string::npos) tmpGateName = "PrepX";
+  else if(tmpGateName.find("PrepZ.") != string::npos) tmpGateName = "PrepZ";
+  else if(tmpGateName.substr(0,2) == "Rz") tmpGateName = "Rz";
+  else if(tmpGateName.find("S.") != string::npos) tmpGateName = "S";
+  else if(tmpGateName.find("T.") != string::npos) tmpGateName = "T";
+  else if(tmpGateName.find("Sdag.") != string::npos) tmpGateName = "Sdag";
+  else if(tmpGateName.find("Tdag.") != string::npos) tmpGateName = "Tdag";
+  else if(tmpGateName.find("X.") != string::npos) tmpGateName = "X";
+  else if(tmpGateName.find("Z.") != string::npos) tmpGateName = "Z";
+
+  if(tmpGateName.find("llvm.")!=string::npos)
+    tmpGateName = tmpGateName.substr(5);
+  errs() << ts << " " << tmpGateName;
+  for(int i = 0; i<qg.numArgs; i++){
+    errs() << " " << qg.args[i].name;
+    if(qg.args[i].index != -1)
+      errs() << qg.args[i].index;
+  }
+
+  /*
+  if(tmpGateName == "PrepX" || tmpGateName == "PrepZ"){
+    if(qg.angle > 0)
+      errs() << " 1";
+    else
+      errs() << " 0";
+  }
+  else if(tmpGateName == "Rz" || tmpGateName == "Ry" || tmpGateName == "Rx")
+    errs() << " "<<qg.angle;
+  */
+
+  errs() << "\n";
+}
+
+void GenSIMDSched::print_tableFuncQbits(){
+  for(map<Function*, map<unsigned int, map<int, uint64_t> > >::iterator m1 = tableFuncQbits.begin(); m1!=tableFuncQbits.end(); ++m1){
+    errs() << "Function " << (*m1).first->getName() << " \n  ";
+    for(map<unsigned int, map<int, uint64_t> >::iterator m2 = (*m1).second.begin(); m2!=(*m1).second.end(); ++m2){
+      errs() << "\tArg# "<< (*m2).first << " -- ";
+      for(map<int, uint64_t>::iterator m3 = (*m2).second.begin(); m3!=(*m2).second.end(); ++m3){
+        errs() << " ; " << (*m3).first << " : " << (*m3).second;
+      }
+      errs() << "\n";
+    }
+  }
+}
+
+
+void GenSIMDSched::calc_critical_time(Function* F, qGate qg, bool isLeafFunc){
+  string fname = qg.qFunc->getName();
+
+  //print_qgate(qg);
+  uint64_t max_ts_of_all_args = 0;
+
+  uint64_t first_step = 0;
+
+  if(isFirstMeas && (fname == "llvm.MeasX" || fname == "llvm.MeasZ")){
+    uint64_t maxFQ = find_max_funcQbits();
+    uint64_t max_ts_sched; 
+
+    //errs() << "First Meas && Before Scheduled \n";
+    //print_funcQbits();
+
+    if(isLeafFunc)
+      max_ts_sched = get_ts_to_schedule_leaf(F,maxFQ, qg.qFunc, first_step);
+    else
+      max_ts_sched = get_ts_to_schedule(F,maxFQ, qg.qFunc, first_step);
+
+    memset_funcQbits(max_ts_sched);
+
+    //set this Meas in this max_ts_sched+1
+    map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[0].name);
+    assert(mIter != funcQbits.end() && "Meas Gate Var not found in funcQbits");
+
+    int argIndex = qg.args[0].index; //must have only one argument
+    assert(argIndex != -1 && "Meas gate has array argument");
+
+    //update the timestep number for that argument
+    map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+    (*indexIter).second =  max_ts_sched + 1;
+    
+    //update -2 entry for the array, i.e. max ts over all indices
+    indexIter = (*mIter).second.find(-2);
+    (*indexIter).second = max_ts_sched + 1;
+    
+    //errs() << "Scheduled in "<< max_ts_sched+1 << "\n";
+    //print_funcQbits();
+
+    isFirstMeas = false;
+    print_scheduled_gate(qg,max_ts_sched+1);
+    return;    
+  }
+  else{
+    //find last timestep for all arguments of qgate
+    for(int i=0;i<qg.numArgs; i++){
+      map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+      assert(mIter!=funcQbits.end()); //should already have an entry for the name of the qbit
+      
+      int argIndex = qg.args[i].index;
+      
+      //find the index of argument in the map<int,int>
+      if(argIndex == -1) //operation on entire array
+        {
+          //find max for the array        
+          map<int,uint64_t>::iterator indexIter = (*mIter).second.find(-2);
+          if((*indexIter).second > max_ts_of_all_args)
+            max_ts_of_all_args = (*indexIter).second;     
+        }
+      else
+        {
+          map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+          if(indexIter!=(*mIter).second.end()){
+            if((*indexIter).second > max_ts_of_all_args)
+              max_ts_of_all_args = (*indexIter).second;
+          }
+          else{
+            //find the value for entire array
+            map<int,uint64_t>::iterator fullArrayIndexIter = (*mIter).second.find(-1);  
+            ((*mIter).second)[argIndex] = (*fullArrayIndexIter).second;
+            //((*mIter).second)[argIndex] = 0;
+            if((*fullArrayIndexIter).second > max_ts_of_all_args)
+              max_ts_of_all_args = (*fullArrayIndexIter).second;
+          }
+        }
+    }
+    
+    if(debugGenSIMDSched){
+      errs() << "Before Scheduling: \n";
+      print_funcQbits();
+    }
+    
+    //errs() << "Max timestep for all args = " << max_ts_of_all_args << "\n";
+    
+    //find timestep from max_ts_of_all_args where type of gate is same as this gate or no gate has been scheduled.
+    uint64_t ts_sched;
+
+      if(isLeafFunc)
+        ts_sched = get_ts_to_schedule_leaf(F,max_ts_of_all_args, qg.qFunc, first_step);
+      else
+        ts_sched = get_ts_to_schedule(F,max_ts_of_all_args, qg.qFunc, first_step);
+
+      //errs() << "ts_sched = " << ts_sched << " FirstStep = " << first_step << "\n";
+      
+      //schedule gate in max_ts_of_all_args + 1th timestep = ts_sched+1
+      print_scheduled_gate(qg,first_step+1);
+      
+
+      //if(currArrParGates.size() != 0){
+      
+      //update last timestep for all arguments of qgate
+      for(int i=0;i<qg.numArgs; i++){
+        map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+        
+        int argIndex = qg.args[i].index;
+        
+        if(argIndex == -1){
+          for(map<int,uint64_t>::iterator entryIter = (*mIter).second.begin(); entryIter!=(*mIter).second.end();++entryIter){
+            (*entryIter).second = ts_sched + 1;
+          }
+          
+        }
+        else{
+          //update the timestep number for that argument
+          map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+          (*indexIter).second =  ts_sched + 1;
+          
+          //update -2 entry for the array, i.e. max ts over all indices
+          indexIter = (*mIter).second.find(-2);
+          if((*indexIter).second < ts_sched + 1)
+            (*indexIter).second = ts_sched + 1;
+        }  
+      }
+      //}
+      } // not first MeasX gate
+  
+  if(debugGenSIMDSched){   
+    errs() << "\nAfter Scheduling: \n";
+    print_funcQbits();
+    print_critical_info();
+    errs() << "\n";
+  }
+  
+}
+
+uint64_t GenSIMDSched::calc_critical_time_unbounded(Function* F, qGate qg){
+  string fname = qg.qFunc->getName();
+
+  if(debugGenSIMDSched){   
+    print_qgate(qg);    
+    print_tableFuncQbits();
+  }
+
+  uint64_t max_ts_of_all_args = 0;
+  
+  //find last timestep for all arguments of qgate
+  for(int i=0;i<qg.numArgs; i++){
+    map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+    assert(mIter!=funcQbits.end()); //should already have an entry for the name of the qbit
+    
+    int argIndex = qg.args[i].index;
+    
+    //find the index of argument in the map<int,int>
+    if(argIndex == -1) //operation on entire array
+      {
+        //find max for the array          
+        map<int,uint64_t>::iterator indexIter = (*mIter).second.find(-2);
+        if((*indexIter).second > max_ts_of_all_args)
+          max_ts_of_all_args = (*indexIter).second;       
+      }
+    else
+      {
+        map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+        if(indexIter!=(*mIter).second.end()){
+          if((*indexIter).second > max_ts_of_all_args)
+            max_ts_of_all_args = (*indexIter).second;
+        }
+        else{
+          //find the value for entire array
+          map<int,uint64_t>::iterator fullArrayIndexIter = (*mIter).second.find(-1);      
+          ((*mIter).second)[argIndex] = (*fullArrayIndexIter).second;
+          if((*fullArrayIndexIter).second > max_ts_of_all_args)
+            max_ts_of_all_args = (*fullArrayIndexIter).second;
+        }
+      }
+    }
+    
+    if(debugGenSIMDSched){
+      errs() << "Before Scheduling: \n";
+      print_funcQbits();
+      }
+    
+    //errs() << "Max timestep for all args = " << max_ts_of_all_args << "\n";
+      
+      //schedule gate in max_ts_of_all_args + 1th timestep
+      //--print_scheduled_gate(qg,max_ts_of_all_args+1);
+      
+      //update last timestep for all arguments of qgate
+      for(int i=0;i<qg.numArgs; i++){
+        map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+        
+        int argIndex = qg.args[i].index;
+        
+        if(argIndex == -1){
+          for(map<int,uint64_t>::iterator entryIter = (*mIter).second.begin(); entryIter!=(*mIter).second.end();++entryIter){
+            (*entryIter).second = max_ts_of_all_args + 1;
+          }
+          
+        }
+        else{
+          //update the timestep number for that argument
+          map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+          (*indexIter).second =  max_ts_of_all_args + 1;
+          
+          //update -2 entry for the array, i.e. max ts over all indices
+          indexIter = (*mIter).second.find(-2);
+          if((*indexIter).second < max_ts_of_all_args + 1)
+            (*indexIter).second = max_ts_of_all_args + 1;
+        }  
+      }
+
+  
+  if(debugGenSIMDSched)
+  {   
+    errs() << "\nAfter Scheduling: \n";
+    print_funcQbits();
+    errs() << "\n";
+  }
+
+  return max_ts_of_all_args+1;
+  
+} //calc_critical_time_unbounded
+
+
+bool GenSIMDSched::checkIfIntrinsic(Function* CF){
+  if(CF->isIntrinsic()){
+    if((CF->getIntrinsicID() == Intrinsic::CNOT)
+       || (CF->getIntrinsicID() == Intrinsic::Fredkin)
+       || (CF->getIntrinsicID() == Intrinsic::H)
+       || (CF->getIntrinsicID() == Intrinsic::MeasX)
+       || (CF->getIntrinsicID() == Intrinsic::MeasZ)
+       || (CF->getIntrinsicID() == Intrinsic::PrepX)
+       || (CF->getIntrinsicID() == Intrinsic::PrepZ)
+       || (CF->getIntrinsicID() == Intrinsic::Rz)
+       || (CF->getIntrinsicID() == Intrinsic::S)
+       || (CF->getIntrinsicID() == Intrinsic::T)
+       || (CF->getIntrinsicID() == Intrinsic::Sdag)
+       || (CF->getIntrinsicID() == Intrinsic::Tdag)
+       || (CF->getIntrinsicID() == Intrinsic::Toffoli)
+       || (CF->getIntrinsicID() == Intrinsic::X)
+       || (CF->getIntrinsicID() == Intrinsic::Y)
+       || (CF->getIntrinsicID() == Intrinsic::Z)){
+      return true;
+    }
+  }
+  return false;
+}
+
+
+void GenSIMDSched::analyzeCallInst(Function* F, Instruction* pInst){
+  if(CallInst *CI = dyn_cast<CallInst>(pInst))
+    {      
+      if(debugGenSIMDSched)
+        errs() << "Call inst: " << CI->getCalledFunction()->getName() << "\n";
+
+      if(CI->getCalledFunction()->getName() == "store_cbit"){   //trace return values
+        return;
+      }      
+
+      vector<qGateArg> allDepQbit;                                  
+      
+      bool tracked_all_operands = true;
+
+      int myPrepState = -1;
+      double myRotationAngle = 0.0;
+      
+      for(unsigned iop=0;iop<CI->getNumArgOperands();iop++){
+        tmpDepQbit.clear();
+        
+        qGateArg tmpQGateArg;
+        btCount=0;
+        
+        tmpQGateArg.argNum = iop;
+        
+        
+        if(isa<UndefValue>(CI->getArgOperand(iop))){
+          errs() << "WARNING: LLVM IR code has UNDEF values. \n";
+          tmpQGateArg.isUndef = true;   
+          //exit(1);
+        }
+        
+        Type* argType = CI->getArgOperand(iop)->getType();
+        if(argType->isPointerTy()){
+          tmpQGateArg.isPtr = true;
+          Type *argElemType = argType->getPointerElementType();
+          if(argElemType->isIntegerTy(16))
+            tmpQGateArg.isQbit = true;
+          if(argElemType->isIntegerTy(1))
+            tmpQGateArg.isCbit = true;
+		  if(argElemType->isIntegerTy(8))
+            tmpQGateArg.isAbit = true;
+
+        }
+        else if(argType->isIntegerTy(16)){
+          tmpQGateArg.isQbit = true;
+          tmpQGateArg.valOrIndex = 0;    
+        }               
+		else if(argType->isIntegerTy(8)){
+          tmpQGateArg.isAbit = true;
+          tmpQGateArg.valOrIndex = 0;    
+        }  
+        else if(argType->isIntegerTy(1)){
+          tmpQGateArg.isCbit = true;
+          tmpQGateArg.valOrIndex = 0;    
+        }
+
+
+        //check if argument is constant int
+        if(ConstantInt *CInt = dyn_cast<ConstantInt>(CI->getArgOperand(iop))){
+          myPrepState = CInt->getZExtValue();     
+        }
+        
+        //check if argument is constant float
+        if(ConstantFP *CFP = dyn_cast<ConstantFP>(CI->getArgOperand(iop))){
+          myRotationAngle = CFP->getValueAPF().convertToDouble();
+        }               
+        
+        //if(tmpQGateArg.isQbit || tmpQGateArg.isCbit){
+        if(tmpQGateArg.isQbit || tmpQGateArg.isAbit){
+            tmpDepQbit.push_back(tmpQGateArg);  
+            tracked_all_operands &= backtraceOperand(CI->getArgOperand(iop),0);
+        }
+
+        if(tmpDepQbit.size()>0){          
+          allDepQbit.push_back(tmpDepQbit[0]);
+          assert(tmpDepQbit.size() == 1 && "tmpDepQbit SIZE GT 1");
+          tmpDepQbit.clear();
+        }
+        
+      }
+      
+      if(allDepQbit.size() > 0){
+        if(debugGenSIMDSched)
+        {
+            errs() << "\nCall inst: " << CI->getCalledFunction()->getName();        
+            errs() << ": Found all arguments: ";       
+            for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+              if(allDepQbit[vb].argPtr)
+                errs() << allDepQbit[vb].argPtr->getName() <<" Index: ";
+                                
+              //else
+                errs() << allDepQbit[vb].valOrIndex <<" ";
+            }
+            errs()<<"\n";
+            
+        }
+
+
+        //check if Intrinsic
+        bool thisFuncIsIntrinsic = checkIfIntrinsic(CI->getCalledFunction());
+        if(!thisFuncIsIntrinsic) hasPrimitivesOnly = false;
+          
+       string fname =  CI->getCalledFunction()->getName();  
+       qGate thisGate;
+       thisGate.qFunc =  CI->getCalledFunction();
+
+       if(myPrepState!=-1) thisGate.angle = (float)myPrepState;
+       if(myRotationAngle!=0.0) thisGate.angle = myRotationAngle;
+
+       for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+            if(allDepQbit[vb].argPtr){
+              //errs() << allDepQbit[vb].argPtr->getName() <<" Index: ";
+              //errs() << allDepQbit[vb].valOrIndex <<"\n";
+                qGateArg param =  allDepQbit[vb];       
+                //errs() << "1\n";
+                thisGate.args[thisGate.numArgs].name = param.argPtr->getName();
+                //errs() << "2\n";
+                if(!param.isPtr)
+                  thisGate.args[thisGate.numArgs].index = param.valOrIndex;
+                //errs() << "3\n";
+                thisGate.numArgs++;
+                //errs() << "4\n";
+            }
+       }
+       //errs() << "5\n";
+
+
+       uint64_t thisTS = calc_critical_time_unbounded(F,thisGate);       
+       //update priorityVector
+       priorityVector.push_back(make_pair(pInst,thisTS));
+
+       //add to mapInstSet
+       mapInstSet[pInst] = thisGate;
+
+      }    
+      allDepQbit.erase(allDepQbit.begin(),allDepQbit.end());
+    }
+}
+
+
+void GenSIMDSched::saveTableFuncQbits(Function* F){
+  map<unsigned int, map<int, uint64_t> > tmpFuncQbitsMap;
+
+  for(map<string, map<int, uint64_t> >::iterator mapIt = funcQbits.begin(); mapIt!=funcQbits.end(); ++mapIt){
+    map<string, unsigned int>::iterator argIt = funcArgs.find((*mapIt).first);
+    if(argIt!=funcArgs.end()){
+      unsigned int argNum = (*argIt).second;
+      tmpFuncQbitsMap[argNum] = (*mapIt).second;
+    }
+  }
+  tableFuncQbits[F] = tmpFuncQbitsMap;
+}
+
+
+void GenSIMDSched::CountCriticalFunctionResources (Function *F) {
+      // Traverse instruction by instruction
+  init_critical_path_algo(F);
+  
+
+  //get qbits in function
+  for (inst_iterator I = inst_begin(*F), E = inst_end(*F); I != E; ++I) {
+    Instruction *Inst = &*I;                            // Grab pointer to instruction reference
+    analyzeAllocInst(F,Inst);          
+    if(!isa<AllocaInst>(Inst))
+      break;
+  }
+
+  //errs() << "Finding priorities--- \n";
+  //find priorities for instructions
+  for (inst_iterator I = inst_begin(*F), E = inst_end(*F); I != E; ++I) {
+    Instruction *Inst = &*I;                            // Grab pointer to instruction reference
+    if(isa<CallInst>(Inst))
+      vectCalls.push_back(Inst);
+  }
+
+  //traverse in reverse sequence
+  for(vector<Instruction*>::reverse_iterator rit = vectCalls.rbegin(); rit!=vectCalls.rend(); ++rit)
+    analyzeCallInst(F,(*rit));  
+
+  //is function leaf or not?
+  if(hasPrimitivesOnly) isLeaf.push_back(F);
+
+  //sort vector
+  sort(priorityVector.begin(), priorityVector.end(), CompareInstPriByValue());
+
+  //reset funcQbits vector in preparation for scheduling
+  memset_funcQbits(0);
+
+  //errs() << "Finding Schedule--- \n";
+  for(vector<InstPri>::reverse_iterator vit = priorityVector.rbegin(); vit!=priorityVector.rend(); ++vit){
+    //get qgate
+    map<Instruction*, qGate>::iterator mit = mapInstSet.find((*vit).first);
+    assert(mit!=mapInstSet.end() && "Instruction Not Found in MapInstSet.");
+
+    qGate thisGate = (*mit).second;
+
+//    errs() << (*vit).second << " | ";   
+ 
+    if(hasPrimitivesOnly)
+      calc_critical_time(F,thisGate,true);
+    else
+      calc_critical_time(F,thisGate,false);
+
+  }
+
+
+  saveTableFuncQbits(F);  
+  save_blackbox_info(F);
+
+
+
+  //print_ArrParGates();
+  //print_tableFuncQbits();
+
+}
+
+
+void GenSIMDSched::init_gates_as_functions(){
+    
+    //add blackbox entry for each of these ??
+    
+  for(int  i =0; i< NUM_QGATES ; i++){
+    string gName = gate_name[i];
+    string fName = "llvm.";
+    fName.append(gName);
+    
+  }
+
+}
+
+
+bool GenSIMDSched::runOnModule (Module &M) {
+  init_gate_names();
+  init_gates_as_functions();
+  
+  // iterate over all functions, and over all instructions in those functions
+  CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+  
+  //Post-order
+  for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode), E = scc_end(rootNode); sccIb != E; ++sccIb) {
+    const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+    for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(), E = nextSCC.end(); nsccI != E; ++nsccI) {
+      Function *F = (*nsccI)->getFunction();      
+            
+      if(F && !F->isDeclaration()){
+        //errs() << "SIMD_K " << RES_CONSTRAINT << ", SIMD_D " << DATA_CONSTRAINT << "\n";      
+        errs() << "#Function " << F->getName() << "\n";      
+        //errs() << "#Timestep GateName Operand1 Operand2 \n";
+        
+        funcQbits.clear();
+        funcArgs.clear();
+        vectCalls.clear();
+        mapInstSet.clear();
+        priorityVector.clear();
+
+        getFunctionArguments(F);
+
+        // count the critical resources for this function
+        CountCriticalFunctionResources(F);
+
+        if(F->getName() == "main"){
+          //print_ArrParGates(F);
+          //errs() << "\n#Num of critical time steps for function main : " << getNumCritSteps(F) << "\n";           
+        }
+
+        //print_critical_info();
+        errs() << "#EndFunction\n";
+        cleanupCurrArrParGates(); 
+      }
+      else{
+            if(debugGenSIMDSched)
+              errs() << "WARNING: Ignoring external node or dummy function.\n";
+          }
+    }
+  }
+  //print_tableFuncQbits();
+  //print_parallelism();
+
+  return false;
+} // End runOnModule
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GetCriticalPath.cpp llvm/lib/Transforms/Scaffold/GetCriticalPath.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/GetCriticalPath.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/GetCriticalPath.cpp	2017-10-12 11:09:31.093119606 +0800
@@ -0,0 +1,1380 @@
+//===----------------- GetCriticalPath.cpp ----------------------===//
+// This file implements the Scaffold Pass of counting the number 
+//  of critical timesteps and gate parallelism in program
+//  in callgraph post-order.
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "GetCriticalPath"
+#include <vector>
+#include <limits>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/ADT/SCCIterator.h"
+#include "llvm/Argument.h"
+#include "llvm/ADT/ilist.h"
+#include "llvm/Constants.h"
+#include "llvm/IntrinsicInst.h"
+
+
+using namespace llvm;
+using namespace std;
+
+#define MAX_GATE_ARGS 30
+#define MAX_BT_COUNT 15 //max backtrace allowed - to avoid infinite recursive loops
+#define NUM_QGATES 17
+#define _CNOT 0
+#define _H 1
+#define _S 2
+#define _T 3
+#define _X 4
+#define _Y 5
+#define _Z 6
+#define _MeasX 7
+#define _MeasZ 8
+#define _PrepX 9
+#define _PrepZ 10
+#define _Tdag 11
+#define _Sdag 12
+#define _Rz 13
+#define _Toffoli 14
+#define _Fredkin 15
+#define _All 16
+
+bool debugGetCriticalPath = false;
+
+namespace {
+
+  struct qGateArg{ //arguments to qgate calls
+    Value* argPtr;
+    int argNum;
+    bool isQbit;
+    bool isCbit;
+    bool isUndef;
+    bool isPtr;
+    int valOrIndex; //Value if not Qbit, Index if Qbit & not a Ptr
+    qGateArg(): argPtr(NULL), argNum(-1), isQbit(false), isCbit(false), isUndef(false), isPtr(false), valOrIndex(-1) { }
+  };
+
+  struct qArgInfo{
+    string name;
+    int index;
+    qArgInfo(): name("none"), index(-1){ }
+  };
+
+  struct qGate{
+    Function* qFunc;
+    int numArgs;
+    qArgInfo args[MAX_GATE_ARGS];
+    uint64_t asap_num;
+    uint64_t alap_num;
+    qGate():qFunc(NULL), numArgs(0), asap_num(0), alap_num(0) { }
+  };
+
+  struct ArrParGates{
+    uint64_t parallel_gates[NUM_QGATES];
+  };
+
+  struct allTSParallelism{
+    uint64_t timesteps;
+    vector<ArrParGates> gates;
+    allTSParallelism(): timesteps(0){ }
+  };  
+
+  struct MaxInfo{ //TimeStepInfo
+    uint64_t timesteps;
+    uint64_t parallel_gates[NUM_QGATES];
+    MaxInfo(): timesteps(0){ }
+  };
+
+  struct GetCriticalPath : public ModulePass {
+    static char ID; // Pass identification
+
+    string gate_name[NUM_QGATES];
+    vector<qGateArg> tmpDepQbit;
+    vector<Value*> vectQbit;
+
+    int btCount; //backtrace count
+
+    vector<qArgInfo> currTimeStep; //contains set of arguments operated on currently
+    vector<string> currParallelFunc;
+    MaxInfo maxParallelFactor; //overall max parallel factor
+    map<string, int> gate_index;    
+    vector<uint64_t> curr_parallel_ts; //vector of current timesteps that are parallel; used for comparing functions
+    map<string, allTSParallelism > funcParallelFactor; //string is function name
+    map<string, MaxInfo> funcMaxParallelFactor;
+
+    map<string, map<int,uint64_t> > funcQbits; //qbits in current function
+    map<string, map<int,uint64_t> > funcQbitsStart; //start ts of qbits in current function
+    map<string, map<int,uint64_t> > funcQbitsHalf; //qbits in current function
+    map<Function*, map<unsigned int, map<int,uint64_t> > > tableFuncQbits;
+    map<Function*, map<unsigned int, map<int,uint64_t> > > tableFuncQbitsStart;
+    map<string, unsigned int> funcArgs;
+
+    map<uint64_t, vector<qGate> > tsGates;
+    map<Function*, uint64_t> crit_path_f; 
+
+    allTSParallelism currTS;
+
+    bool isFirstMeas;
+    bool isLeaf;
+
+    uint64_t highestDelay;
+
+    GetCriticalPath() : ModulePass(ID) {}
+
+    bool backtraceOperand(Value* opd, int opOrIndex);
+    void analyzeAllocInst(Function* F,Instruction* pinst);
+    void analyzeCallInst(Function* F,Instruction* pinst);
+    void getFunctionArguments(Function *F);
+
+    void saveTableFuncQbits(Function* F);
+    void saveTableFuncQbitsStart(Function* F);
+    void print_tableFuncQbits();
+    void print_tableFuncQbitsStart();
+    void print_tsGates();
+
+    void init_gate_names(){
+      gate_name[_CNOT] = "CNOT";
+      gate_name[_H] = "H";
+      gate_name[_S] = "S";
+      gate_name[_T] = "T";
+      gate_name[_Toffoli] = "Toffoli";
+      gate_name[_X] = "X";
+      gate_name[_Y] = "Y";
+      gate_name[_Z] = "Z";
+      gate_name[_MeasX] = "MeasX";
+      gate_name[_MeasZ] = "MeasZ";
+      gate_name[_PrepX] = "PrepX";
+      gate_name[_PrepZ] = "PrepZ";
+      gate_name[_Sdag] = "Sdag";
+      gate_name[_Tdag] = "Tdag";
+      gate_name[_Fredkin] = "Fredkin";
+      gate_name[_Rz] = "Rz";
+      gate_name[_All] = "All";                    
+
+      gate_index["CNOT"] = _CNOT;        
+      gate_index["H"] = _H;
+      gate_index["S"] = _S;
+      gate_index["T"] = _T;
+      gate_index["Toffoli"] = _Toffoli;
+      gate_index["X"] = _X;
+      gate_index["Y"] = _Y;
+      gate_index["Z"] = _Z;
+      gate_index["Sdag"] = _Sdag;
+      gate_index["Tdag"] = _Tdag;
+      gate_index["MeasX"] = _MeasX;
+      gate_index["MeasZ"] = _MeasZ;
+      gate_index["PrepX"] = _PrepX;
+      gate_index["PrepZ"] = _PrepZ;
+      gate_index["Fredkin"] = _Fredkin;
+      gate_index["Rz"] = _Rz;
+      gate_index["All"] = _All;                            
+    }
+
+    void init_gates_as_functions();    
+    void init_critical_path_algo(Function* F);
+    void calc_critical_time(Function* F, qGate qg);        
+    void print_funcQbits();
+    void print_funcQbitsHalf();
+    void print_qgate(qGate qg);
+    void print_critical_info(string func);
+    void calc_max_parallelism_statistic();
+    uint64_t compute_max_ts_of_all_args(qGate qg);
+    uint64_t compute_least_slack(Function* F, qGate qg, uint64_t tmax);
+
+    void update_critical_info(string currFunc, uint64_t ts, string fname);
+
+    void print_scheduled_gate(qGate qg, uint64_t ts);
+    void addToTSGates(qGate qg, uint64_t ts);
+
+    void init_funcQbitsHalf(uint64_t i);
+    void gen_half_funcQbits(uint64_t ct, uint64_t hct);
+    void schedule_alap_insts(uint64_t ct, uint64_t hct);
+    void process_nonLeafALAP();
+
+    uint64_t find_max_funcQbits();
+    void memset_funcQbits(uint64_t val);
+    void memset_funcQbitsHalf(uint64_t val);
+
+    void print_qgateArg(qGateArg qg)
+    {
+      errs()<< "Printing QGate Argument:\n";
+      if(qg.argPtr) errs() << "  Name: "<<qg.argPtr->getName()<<"\n";
+      errs() << "  Arg Num: "<<qg.argNum<<"\n"
+        << "  isUndef: "<<qg.isUndef
+        << "  isQbit: "<<qg.isQbit
+        << "  isCbit: "<<qg.isCbit
+        << "  isPtr: "<<qg.isPtr << "\n"
+        << "  Value or Index: "<<qg.valOrIndex<<"\n";
+    }                    
+
+    void CountCriticalFunctionResources (Function *F);
+
+    bool runOnModule (Module &M);
+
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();  
+      AU.addRequired<CallGraph>();    
+    }
+
+  }; // End of struct GetCriticalPath
+} // End of anonymous namespace
+
+
+
+char GetCriticalPath::ID = 0;
+static RegisterPass<GetCriticalPath> X("GetCriticalPath", "Get Critical Path");
+
+void GetCriticalPath::getFunctionArguments(Function* F)
+{
+  for(Function::arg_iterator ait=F->arg_begin();ait!=F->arg_end();++ait)
+  {    
+    //if(ait) errs() << "Argument: "<<ait->getName()<< " ";
+
+    string argName = (ait->getName()).str();
+    Type* argType = ait->getType();
+    unsigned int argNum=ait->getArgNo();         
+
+    qGateArg tmpQArg;
+    tmpQArg.argPtr = ait;
+    tmpQArg.argNum = argNum;
+
+    if(argType->isPointerTy()){
+      tmpQArg.isPtr = true;
+
+      Type *elementType = argType->getPointerElementType();
+      if (elementType->isIntegerTy(16)){ //qbit*
+        tmpQArg.isQbit = true;
+        vectQbit.push_back(ait);
+
+        map<int,uint64_t> tmpMap;
+        tmpMap[-1] = 0; //add entry for entire array
+        tmpMap[-2] = 0; //add entry for max
+        funcQbits[argName]=tmpMap;
+
+        map<int,uint64_t> tmpMapHalf;
+        funcQbitsHalf[argName]=tmpMapHalf;
+
+        funcArgs[argName] = argNum;
+
+      }
+      else if (elementType->isIntegerTy(1)){ //cbit*
+        tmpQArg.isCbit = true;
+        vectQbit.push_back(ait);
+        funcArgs[argName] = argNum;
+      }
+    }
+    else if (argType->isIntegerTy(16)){ //qbit
+      tmpQArg.isQbit = true;
+      vectQbit.push_back(ait);
+
+      map<int,uint64_t> tmpMap;
+      tmpMap[-1] = 0; //add entry for entire array
+      tmpMap[-2] = 0; //add entry for max
+      funcQbits[argName]=tmpMap;
+
+      map<int,uint64_t> tmpMapHalf;
+      funcQbitsHalf[argName]=tmpMapHalf;
+
+      funcArgs[argName] = argNum;
+    }
+    else if (argType->isIntegerTy(1)){ //cbit
+      tmpQArg.isCbit = true;
+      vectQbit.push_back(ait);
+      funcArgs[argName] = argNum;
+    }
+
+  }
+}
+
+bool GetCriticalPath::backtraceOperand(Value* opd, int opOrIndex)
+{
+  if(opOrIndex == 0) //backtrace for operand
+  {
+    //search for opd in qbit/cbit vector
+    vector<Value*>::iterator vIter=find(vectQbit.begin(),vectQbit.end(),opd);
+    if(vIter != vectQbit.end()){
+      tmpDepQbit[0].argPtr = opd;
+
+      return true;
+    }
+
+    if(btCount>MAX_BT_COUNT)
+      return false;
+
+    if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(opd))
+    {
+
+      if(GEPI->hasAllConstantIndices()){
+        Instruction* pInst = dyn_cast<Instruction>(opd);
+        unsigned numOps = pInst->getNumOperands();
+
+        backtraceOperand(pInst->getOperand(0),0);
+
+        //NOTE: getelemptr instruction can have multiple indices. Currently considering last operand as desired index for qubit. Check this reasoning. 
+        if(ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(numOps-1))){
+          if(tmpDepQbit.size()==1){
+            tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+          }
+        }
+      }
+
+      else if(GEPI->hasIndices()){
+
+        Instruction* pInst = dyn_cast<Instruction>(opd);
+        unsigned numOps = pInst->getNumOperands();
+        backtraceOperand(pInst->getOperand(0),0);
+
+        if(tmpDepQbit[0].isQbit && !(tmpDepQbit[0].isPtr)){     
+          //NOTE: getelemptr instruction can have multiple indices. consider last operand as desired index for qubit. Check if this is true for all.
+          backtraceOperand(pInst->getOperand(numOps-1),1);
+
+        }
+      }
+      else{	    
+        Instruction* pInst = dyn_cast<Instruction>(opd);
+        unsigned numOps = pInst->getNumOperands();
+        for(unsigned iop=0;iop<numOps;iop++){
+          backtraceOperand(pInst->getOperand(iop),0);
+        }
+      }
+      return true;
+    }
+
+    if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+      unsigned numOps = pInst->getNumOperands();
+      for(unsigned iop=0;iop<numOps;iop++){
+        btCount++;
+        backtraceOperand(pInst->getOperand(iop),0);
+        btCount--;
+      }
+      return true;
+    }
+    else{
+      return true;
+    }
+  }
+  else if(opOrIndex == 0){ //opOrIndex == 1; i.e. Backtracing for Index    
+    if(btCount>MAX_BT_COUNT) //prevent infinite backtracing
+      return true;
+
+    if(ConstantInt *CI = dyn_cast<ConstantInt>(opd)){
+      tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+      return true;
+    }      
+
+    if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+      unsigned numOps = pInst->getNumOperands();
+      for(unsigned iop=0;iop<numOps;iop++){
+        btCount++;
+        backtraceOperand(pInst->getOperand(iop),1);
+        btCount--;
+      }
+    }
+
+  }
+  else{ //opOrIndex == 2: backtracing to call inst MeasZ
+    if(CallInst *endCI = dyn_cast<CallInst>(opd)){
+      if(endCI->getCalledFunction()->getName().find("llvm.Meas") != string::npos){
+        tmpDepQbit[0].argPtr = opd;
+
+        return true;
+      }
+      else{
+        if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+          unsigned numOps = pInst->getNumOperands();
+          bool foundOne=false;
+          for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+            btCount++;
+            foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+            btCount--;
+          }
+          return foundOne;
+        }
+      }
+    }
+    else{
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+        unsigned numOps = pInst->getNumOperands();
+        bool foundOne=false;
+        for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+          btCount++;
+          foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+          btCount--;
+        }
+        return foundOne;
+      }
+    }
+  }
+  return false;
+}
+
+
+void GetCriticalPath::analyzeAllocInst(Function* F, Instruction* pInst){
+  if (AllocaInst *AI = dyn_cast<AllocaInst>(pInst)) {
+    Type *allocatedType = AI->getAllocatedType();
+
+    if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+      qGateArg tmpQArg;
+
+      Type *elementType = arrayType->getElementType();
+      uint64_t arraySize = arrayType->getNumElements();
+      if (elementType->isIntegerTy(16)){
+        vectQbit.push_back(AI);
+        tmpQArg.isQbit = true;
+        tmpQArg.argPtr = AI;
+        tmpQArg.valOrIndex = arraySize;
+
+        map<int,uint64_t> tmpMap; //add qbit to funcQbits
+        tmpMap[-1] = 0; //entry for entire array
+        tmpMap[-2] = 0; //entry for max
+        funcQbits[AI->getName()]=tmpMap;
+
+        map<int,uint64_t> tmpMapHalf;
+        funcQbitsHalf[AI->getName()]=tmpMapHalf;
+
+      }
+
+      if (elementType->isIntegerTy(1)){
+        vectQbit.push_back(AI); //Cbit added here
+        tmpQArg.isCbit = true;
+        tmpQArg.argPtr = AI;
+        tmpQArg.valOrIndex = arraySize;
+      }
+    }
+  }
+}
+
+
+void GetCriticalPath::init_critical_path_algo(Function* F){
+
+  MaxInfo structMaxInfo;
+  allTSParallelism vectGateInfo; //initialize an entry in the function map
+  //ArrParGates tmpParGates;
+
+  isFirstMeas = true;
+  isLeaf = true;
+  highestDelay = 0;
+
+  //clear tsGates
+  for(map<uint64_t, vector<qGate> >::iterator mit=tsGates.begin(); mit!=tsGates.end(); ++mit){
+    (*mit).second.clear();
+  }
+  tsGates.clear();
+
+  currTimeStep.clear(); //initialize critical time steps   
+
+  curr_parallel_ts.clear();
+
+  maxParallelFactor.timesteps = 0;   //initialize critical time steps
+
+  for(int i=0; i< NUM_QGATES ; i++){
+    maxParallelFactor.parallel_gates[i] = 0;
+    structMaxInfo.parallel_gates[i] = 0;
+    //tmpParGates.parallel_gates[i] = 0;
+  }
+  //vectGateInfo.gates.push_back(tmpParGates); //dummy first entry
+  funcParallelFactor[F->getName().str()] = vectGateInfo;
+  funcMaxParallelFactor[F->getName().str()] = structMaxInfo;
+  currParallelFunc.clear();
+}
+
+void GetCriticalPath::print_funcQbits(){
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbits.begin(); mIter!=funcQbits.end(); ++mIter){
+    errs() << "Var "<< (*mIter).first << " ---> ";
+    for(map<int,uint64_t>::iterator indexIter  = (*mIter).second.begin(); indexIter!=(*mIter).second.end(); ++indexIter){
+      errs() << (*indexIter).first << ":"<<(*indexIter).second<< "  ";
+    }
+    errs() << "\n";
+  }
+}
+
+void GetCriticalPath::print_funcQbitsHalf(){
+  errs() << "Printing funcQbitsHalf ---- \n";
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbitsHalf.begin(); mIter!=funcQbitsHalf.end(); ++mIter){
+    errs() << "Var "<< (*mIter).first << " ---> ";
+    for(map<int,uint64_t>::iterator indexIter  = (*mIter).second.begin(); indexIter!=(*mIter).second.end(); ++indexIter){
+      errs() << (*indexIter).first << ":"<<(*indexIter).second<< "  ";
+    }
+    errs() << "\n";
+  }
+}
+
+void GetCriticalPath::print_qgate(qGate qg){
+  errs() << "--Gate: " << qg.qFunc->getName() << " : ";
+  for(int i=0;i<qg.numArgs;i++){
+    errs() << qg.args[i].name << " idx=" << qg.args[i].index 
+      << ", "  ;
+  }
+  errs() << "ASAP=" << qg.asap_num << " ALAP=" << qg.alap_num;
+  errs() << "\n";
+}
+
+
+void GetCriticalPath::print_critical_info(string func){
+  map<string, allTSParallelism>::iterator fitr = funcParallelFactor.find(func);
+  assert(fitr!=funcParallelFactor.end() && "Func not found in funcParFac");
+  errs() << "Timesteps = " << (*fitr).second.timesteps << "\n";
+  for(unsigned int i = 0; i<(*fitr).second.gates.size(); i++){
+    errs() << i << " :";
+    for(int k=0;k<NUM_QGATES;k++)
+      errs() << " " << (*fitr).second.gates[i].parallel_gates[k];
+    errs() << "\n";
+  }
+}
+
+void GetCriticalPath::update_critical_info(string currFunc, uint64_t ts, string fname){
+  map<string, allTSParallelism>::iterator fitr = funcParallelFactor.find(fname);
+  map<string, allTSParallelism>::iterator citr = funcParallelFactor.find(currFunc);
+  assert(fitr!=funcParallelFactor.end() && "parallel func not found in funcParallelFactor");
+
+  assert(citr!=funcParallelFactor.end() && "curr func not found in funcParallelFactor");
+
+  unsigned currTSsize = (*citr).second.gates.size();
+  unsigned newTSsize = (*fitr).second.gates.size();
+
+  //errs() << "ts = " << ts << " currsize = " << currTSsize << " newsize = "<<newTSsize <<"\n";
+
+  if(ts+newTSsize > currTSsize)
+    (*citr).second.timesteps = ts+newTSsize;
+
+  if(ts + newTSsize <= currTSsize){
+    for(unsigned i = 0; i<newTSsize; i++){
+      for(int k=0; k<NUM_QGATES;k++){
+        (*citr).second.gates[ts+i].parallel_gates[k] += (*fitr).second.gates[i].parallel_gates[k];            
+      }
+    }
+  }
+  else{
+    for(unsigned i = 0; i<currTSsize-ts; i++){
+      //errs() << "i = " << i << " ts+i=" << ts+i << "\n";
+      for(int k=0; k<NUM_QGATES;k++)
+        (*citr).second.gates[ts+i].parallel_gates[k] += (*fitr).second.gates[i].parallel_gates[k];            
+    }
+
+    for(unsigned i = currTSsize-ts; i<newTSsize; i++){
+      //errs() << "i = " << i << "\n";
+      ArrParGates tmpParGates;
+      for(int k=0; k<NUM_QGATES;k++){
+        tmpParGates.parallel_gates[k] = (*fitr).second.gates[i].parallel_gates[k];                              
+      }
+      (*citr).second.gates.push_back(tmpParGates); 
+    }
+
+  }
+
+  //print_critical_info(currFunc);
+}
+
+
+uint64_t GetCriticalPath::find_max_funcQbits(){
+  uint64_t max_timesteps = 0;
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbits.begin(); mIter!=funcQbits.end(); ++mIter){
+    map<int,uint64_t>::iterator arrIter = (*mIter).second.find(-2);
+    if((*arrIter).second > max_timesteps)
+      max_timesteps = (*arrIter).second;
+  }
+
+  return max_timesteps;
+
+}
+
+void GetCriticalPath::memset_funcQbits(uint64_t val){
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbits.begin(); mIter!=funcQbits.end(); ++mIter){
+    for(map<int,uint64_t>::iterator arrIter = (*mIter).second.begin(); arrIter!=(*mIter).second.end();++arrIter)
+      (*arrIter).second = val;
+  }
+}
+
+void GetCriticalPath::memset_funcQbitsHalf(uint64_t val){
+  for(map<string, map<int,uint64_t> >::iterator mIter = funcQbitsHalf.begin(); mIter!=funcQbitsHalf.end(); ++mIter){
+    for(map<int,uint64_t>::iterator arrIter = (*mIter).second.begin(); arrIter!=(*mIter).second.end();++arrIter)
+      (*arrIter).second = val;
+  }
+}
+
+void GetCriticalPath::print_scheduled_gate(qGate qg, uint64_t ts){
+  string tmpGateName = qg.qFunc->getName();
+  if(tmpGateName.find("llvm.")!=string::npos)
+    tmpGateName = tmpGateName.substr(5);
+  errs() << ts << " : " << tmpGateName;
+  for(int i = 0; i<qg.numArgs; i++){
+    //if(qg.args[i].index != -1)
+    errs() << " " << qg.args[i].name << qg.args[i].index;
+  }
+
+  errs() << "\n";
+}
+
+void GetCriticalPath::print_tableFuncQbits(){
+  for(map<Function*, map<unsigned int, map<int, uint64_t> > >::iterator m1 = tableFuncQbits.begin(); m1!=tableFuncQbits.end(); ++m1){
+    errs() << "Function " << (*m1).first->getName() << " \n  ";
+    for(map<unsigned int, map<int, uint64_t> >::iterator m2 = (*m1).second.begin(); m2!=(*m1).second.end(); ++m2){
+      errs() << "\tArg# "<< (*m2).first << " -- ";
+      for(map<int, uint64_t>::iterator m3 = (*m2).second.begin(); m3!=(*m2).second.end(); ++m3){
+        errs() << " ; " << (*m3).first << " : " << (*m3).second;
+      }
+      errs() << "\n";
+    }
+  }
+}
+
+void GetCriticalPath::print_tableFuncQbitsStart(){
+  errs() << "Printing tableFuncQbitsStart\n";
+  for(map<Function*, map<unsigned int, map<int, uint64_t> > >::iterator m1 = tableFuncQbitsStart.begin(); m1!=tableFuncQbitsStart.end(); ++m1){
+    errs() << "Function " << (*m1).first->getName() << " \n  ";
+    for(map<unsigned int, map<int, uint64_t> >::iterator m2 = (*m1).second.begin(); m2!=(*m1).second.end(); ++m2){
+      errs() << "\tArg# "<< (*m2).first << " -- ";
+      for(map<int, uint64_t>::iterator m3 = (*m2).second.begin(); m3!=(*m2).second.end(); ++m3){
+        errs() << " ; " << (*m3).first << " : " << (*m3).second;
+      }
+      errs() << "\n";
+    }
+  }
+}
+
+void GetCriticalPath::calc_max_parallelism_statistic()
+{
+  map<string, allTSParallelism>::iterator fitr = funcParallelFactor.find("main");
+  assert(fitr!=funcParallelFactor.end() && "Func not found in funcParFac");
+  errs() << "Timesteps = " << (*fitr).second.timesteps << "\n";
+
+  uint64_t max_par = 0;
+  uint64_t ts_par = 0;
+
+  for(unsigned int i = 0; i<(*fitr).second.gates.size(); i++){
+
+    uint64_t nonZero = 0;
+
+    for(int k=0;k<NUM_QGATES-1;k++){ //skip the 'All' entry
+      //count non-zero entries
+      if((*fitr).second.gates[i].parallel_gates[k] > 0)
+        nonZero++;
+    }
+
+    if(nonZero>max_par){
+      max_par = nonZero;
+      ts_par = i;
+    }
+
+  }
+
+  errs() << "Max parallelism in types of gates = " << max_par << " in TS: " << ts_par << "\n";
+
+}
+
+void GetCriticalPath::print_tsGates()
+{
+  for(map<uint64_t, vector<qGate> >::iterator mit = tsGates.begin(); mit!=tsGates.end(); ++mit){
+    errs() << "TS#"<<(*mit).first << " --> ";
+    for(vector<qGate>::iterator vit = (*mit).second.begin(); vit!=(*mit).second.end();++vit)
+      print_qgate(*vit);
+  }
+
+}
+
+void GetCriticalPath::addToTSGates(qGate qg, uint64_t ts)
+{
+  if(isLeaf){
+    //add to tsGates
+    map<uint64_t, vector<qGate> >::iterator git = tsGates.find(ts);
+    if(git!=tsGates.end()){
+      (*git).second.push_back(qg); //add to vector
+    }
+    else{
+      vector<qGate> tmpVect;
+      tmpVect.push_back(qg);
+      tsGates[ts] = tmpVect; //add to map	
+    } 
+  } //isLeaf
+}
+
+uint64_t GetCriticalPath::compute_max_ts_of_all_args(qGate qg)
+{
+
+  uint64_t max_ts_of_all_args = 0;
+
+  //find last timestep for all arguments of qgate
+  for(int i=0;i<qg.numArgs; i++){
+    map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+    assert(mIter!=funcQbits.end()); //should already have an entry for the name of the qbit
+
+    int argIndex = qg.args[i].index;
+
+    //find the index of argument in the map<int,int>
+    if(argIndex == -1) //operation on entire array
+    {
+      //find max for the array
+      map<int,uint64_t>::iterator indexIter = (*mIter).second.find(-2);
+      if((*indexIter).second > max_ts_of_all_args)
+        max_ts_of_all_args = (*indexIter).second;	  
+    }
+    else
+    {
+      map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+      if(indexIter!=(*mIter).second.end()){
+        if((*indexIter).second > max_ts_of_all_args)
+          max_ts_of_all_args = (*indexIter).second;
+      }
+      else{
+        //find the value for entire array
+        map<int,uint64_t>::iterator fullArrayIndexIter = (*mIter).second.find(-1);
+
+        ((*mIter).second)[argIndex] = (*fullArrayIndexIter).second;
+        if((*fullArrayIndexIter).second > max_ts_of_all_args)
+          max_ts_of_all_args = (*fullArrayIndexIter).second;
+        //((*mIter).second)[argIndex] = 0;
+      }
+    }
+  }
+
+  if(debugGetCriticalPath){
+    errs() << "Before Scheduling: \n";
+    print_funcQbits();
+  }
+
+  //errs() << "Max timestep for all args = " << max_ts_of_all_args << "\n";
+
+  return max_ts_of_all_args;
+
+}
+
+uint64_t GetCriticalPath::compute_least_slack(Function* F, qGate qg, uint64_t tmax){
+
+  //errs() << "In compute least \n";
+
+  //print_funcQbits();
+  //print_qgate(qg);
+
+  vector<uint64_t> endsAt; //currently ends at
+  vector<uint64_t> startsAt; //supposed to start at
+
+  for(int i=0;i<qg.numArgs; i++){
+    startsAt.push_back(0);
+    endsAt.push_back(0);
+  }
+
+  //compute startsAt
+  //print_tableFuncQbitsStart();
+
+  map<Function*, map<unsigned int, map<int, uint64_t> > >::iterator tableIt = tableFuncQbitsStart.find(qg.qFunc);
+  assert(tableIt!=tableFuncQbitsStart.end() && "No previous entry for this function");
+
+  for(int i=0;i<qg.numArgs; i++){    
+    map<unsigned int, map<int, uint64_t> >::iterator entryIt = (*tableIt).second.find(i);
+    if(entryIt!=(*tableIt).second.end()){
+
+      //differentiate for qbit and qbit*
+
+      if(qg.args[i].index == -1){ //qbit*
+
+        //errs() << "Array\n";
+
+        map<int, uint64_t>::iterator lookUpIt = (*entryIt).second.find(-2);
+        startsAt[i] = tmax + (*lookUpIt).second;			
+      }
+      else{ //qbit was passed
+        //errs() << "i = " << i << " Qbit\n";
+        //errs() << "index = " << qg.args[i].index << " Qbit\n";
+        //take the 0th entry and add that to the index entry
+        map<int, uint64_t>::iterator lookUpQbitIt = (*entryIt).second.find(0);
+        assert(lookUpQbitIt!=(*entryIt).second.end() && "arg index not found in tablefuncqbitshalf"); //there exists entry for reqd index in the func table of called func
+        startsAt[i] = tmax + (*lookUpQbitIt).second;
+
+      }
+    }
+    else{
+      assert(false && "entry not found in tableFuncStart");
+    }
+  }
+
+  //compute endsAt
+  //find last timestep for all arguments of qgate
+  for(int i=0;i<qg.numArgs; i++){
+    map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+    assert(mIter!=funcQbits.end()); //should already have an entry for the name of the qbit
+
+    int argIndex = qg.args[i].index;
+
+    //find the index of argument in the map<int,int>
+    if(argIndex == -1) //operation on entire array
+    {
+      //find max for the array
+      map<int,uint64_t>::iterator indexIter = (*mIter).second.find(-2);
+      endsAt[i] = (*indexIter).second;	  
+    }
+    else
+    {
+      map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+      if(indexIter!=(*mIter).second.end()){
+        endsAt[i] = (*indexIter).second;
+      }
+      else{
+        //find the value for entire array
+        map<int,uint64_t>::iterator fullArrayIndexIter = (*mIter).second.find(-1);
+
+        ((*mIter).second)[argIndex] = (*fullArrayIndexIter).second;
+        endsAt[i] = (*fullArrayIndexIter).second;
+      }
+    }
+  }
+
+  //print_tableFuncQbits();
+  //print_tableFuncQbitsStart();
+
+  //for(int i=0;i<qg.numArgs; i++){
+  //errs() << "Arg#"<<i<<" End: " << endsAt[i] << " St: " << startsAt[i] << "\n";
+  //}
+
+  //compute least slack
+  uint64_t leastslack = 0;
+  if(qg.numArgs > 0){
+    leastslack = startsAt[0] - endsAt[0];
+    for(int i=1;i<qg.numArgs; i++){
+      if(startsAt[i]-endsAt[i] < leastslack)
+        leastslack = startsAt[i]-endsAt[i];
+    }
+  }
+
+  //errs() << "LS = " << leastslack << "\n";
+  if(leastslack > tmax) leastslack = 1;
+
+  return leastslack;  
+}
+
+void GetCriticalPath::calc_critical_time(Function* F, qGate qg){
+  string fname = qg.qFunc->getName();
+
+  //print_qgate(qg);
+
+  if(isFirstMeas && (fname == "llvm.MeasX" || fname == "llvm.MeasZ")){
+    uint64_t maxFQ = find_max_funcQbits();
+    memset_funcQbits(maxFQ);
+
+    //--print_scheduled_gate(qg,maxFQ+1);
+    addToTSGates(qg,maxFQ+1);
+
+    map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[0].name);
+
+    int argIndex = qg.args[0].index;
+
+    //update the timestep number for that argument
+    map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+    (*indexIter).second =  maxFQ + 1;
+
+    //update -2 entry for the array, i.e. max ts over all indices
+    indexIter = (*mIter).second.find(-2);
+    (*indexIter).second = maxFQ + 1;
+
+    //update_critical_info(F->getName().str(), maxFQ, qg.qFunc->getName(), qg.angle);   
+    isFirstMeas = false;
+  }
+  else{ //not a Meas gate
+
+    uint64_t max_ts_of_all_args = compute_max_ts_of_all_args(qg);;
+
+    //errs() << "Max timestep for all args = " << max_ts_of_all_args << "\n";
+
+
+    if(fname.find("llvm.")!=string::npos){ //is intrinsic
+
+      //schedule gate in max_ts_of_all_args + 1th timestep
+      //--print_scheduled_gate(qg,max_ts_of_all_args+1);
+      addToTSGates(qg,max_ts_of_all_args+1);
+      qg.asap_num = max_ts_of_all_args+1;
+
+      //find last timestep for all arguments of qgate
+      for(int i=0;i<qg.numArgs; i++){
+        map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+
+        int argIndex = qg.args[i].index;
+
+        if(argIndex == -1){
+          for(map<int,uint64_t>::iterator entryIter = (*mIter).second.begin(); entryIter!=(*mIter).second.end();++entryIter){
+            (*entryIter).second = max_ts_of_all_args + 1;
+          }
+
+        }
+        else{
+          //update the timestep number for that argument
+          map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+          (*indexIter).second =  max_ts_of_all_args + 1;
+
+          //update -2 entry for the array, i.e. max ts over all indices
+          indexIter = (*mIter).second.find(-2);
+          if((*indexIter).second < max_ts_of_all_args + 1)
+            (*indexIter).second = max_ts_of_all_args + 1;
+        }  
+      }
+    } //intrinsic func
+
+    else{ //not an intrinsic function
+
+      //not an intrinsic function
+      //errs() << "Non intrinsic \n";
+      isLeaf = false;
+
+      //errs() << "Max ts = " << max_ts_of_all_args << "\n";
+
+      //for all operands of newly called function, compute slack
+      uint64_t least_slack = compute_least_slack(F, qg, max_ts_of_all_args);
+
+      //errs() << "Least slack = " << least_slack << "\n";
+
+      //start scheduling from max_ts_of_all_args - least_slack + 1
+
+      //small code to ensure that any ancilla processing that does not fall within this function's critical path get a cycle in the schedule.
+      map<Function*, uint64_t>::iterator delayIt = crit_path_f.find(qg.qFunc);
+      assert(delayIt != crit_path_f.end() && "Func not found in critpathf");
+      uint64_t tmpDelay = max_ts_of_all_args + (*delayIt).second - least_slack + 1; 
+      if(tmpDelay > highestDelay) highestDelay = tmpDelay;
+
+      //check tableFuncQbits for values to update with
+      map<Function*, map<unsigned int, map<int, uint64_t> > >::iterator tableIt = tableFuncQbits.find(qg.qFunc);
+      assert(tableIt!=tableFuncQbits.end() && "No previous entry for this function");
+
+      for(int i=0;i<qg.numArgs; i++){
+        map<string, map<int,uint64_t> >::iterator mIter = funcQbits.find(qg.args[i].name);
+        assert(mIter!=funcQbits.end()); //should already have an entry for the name of the qbit
+
+        map<unsigned int, map<int, uint64_t> >::iterator entryIt = (*tableIt).second.find(i);
+        if(entryIt!=(*tableIt).second.end()){
+
+          //differentiate for qbit and qbit*
+
+          if(qg.args[i].index == -1){ //qbit*
+            for(map<int, uint64_t>::iterator indexIt = (*entryIt).second.begin(); indexIt!=(*entryIt).second.end(); ++indexIt){
+              map<int,uint64_t>::iterator currEntryIt = (*mIter).second.find((*indexIt).first);
+              if(currEntryIt!=(*mIter).second.end())
+                (*currEntryIt).second = max_ts_of_all_args + (*indexIt).second - least_slack + 1;
+              else
+                (*mIter).second[(*indexIt).first] = max_ts_of_all_args + (*indexIt).second - least_slack + 1;
+            }
+          }
+          else{ //qbit was passed
+            //take the 0th entry and add that to the index entry
+            map<int, uint64_t>::iterator lookUpQbitIt = (*entryIt).second.find(0);
+            assert(lookUpQbitIt!=(*entryIt).second.end()); //there exists entry for 0 in the func table of called func
+            map<int, uint64_t>::iterator currEntryIt = (*mIter).second.find(qg.args[i].index);
+            if(currEntryIt!=(*mIter).second.end())
+              (*currEntryIt).second = max_ts_of_all_args + (*lookUpQbitIt).second - least_slack + 1;
+            else
+              (*mIter).second[qg.args[i].index] = max_ts_of_all_args + (*lookUpQbitIt).second - least_slack + 1;
+
+            //update -2 entry for the array, i.e. max ts over all indices
+            currEntryIt = (*mIter).second.find(-2);
+            if((*currEntryIt).second < max_ts_of_all_args + (*lookUpQbitIt).second)
+              (*currEntryIt).second = max_ts_of_all_args + (*lookUpQbitIt).second- least_slack + 1;	    
+          }
+        } 
+      }
+    } //not intrinsic Gate
+    //update_critical_info(F->getName().str(), max_ts_of_all_args, qg.qFunc->getName(), qg.angle);   
+  } // not a MeasX gate
+
+  if(debugGetCriticalPath)
+  {   
+    errs() << "\nAfter Scheduling: \n";
+    print_funcQbits();
+    print_qgate(qg);
+    errs() << "\n";
+  }
+
+}
+
+void GetCriticalPath::analyzeCallInst(Function* F, Instruction* pInst){
+  if(CallInst *CI = dyn_cast<CallInst>(pInst))
+  {      
+    if(debugGetCriticalPath)
+      errs() << "Call inst: " << CI->getCalledFunction()->getName() << "\n";
+
+    if(CI->getCalledFunction()->getName() == "store_cbit"){	//trace return values
+      return;
+    }
+
+    vector<qGateArg> allDepQbit;                                  
+
+    bool tracked_all_operands = true;
+
+
+
+    for(unsigned iop=0;iop<CI->getNumArgOperands();iop++){
+      tmpDepQbit.clear();
+
+      qGateArg tmpQGateArg;
+      btCount=0;
+
+      tmpQGateArg.argNum = iop;
+
+
+      if(isa<UndefValue>(CI->getArgOperand(iop))){
+        errs() << "WARNING: LLVM IR code has UNDEF values. \n";
+        tmpQGateArg.isUndef = true;	
+        //exit(1);
+      }
+
+      Type* argType = CI->getArgOperand(iop)->getType();
+      if(argType->isPointerTy()){
+        tmpQGateArg.isPtr = true;
+        Type *argElemType = argType->getPointerElementType();
+        if(argElemType->isIntegerTy(16))
+          tmpQGateArg.isQbit = true;
+        if(argElemType->isIntegerTy(1))
+          tmpQGateArg.isCbit = true;
+      }
+      else if(argType->isIntegerTy(16)){
+        tmpQGateArg.isQbit = true;
+        tmpQGateArg.valOrIndex = 0;	 
+      }	  	
+      else if(argType->isIntegerTy(1)){
+        tmpQGateArg.isCbit = true;
+        tmpQGateArg.valOrIndex = 0;	 
+      }
+
+
+      //if(tmpQGateArg.isQbit || tmpQGateArg.isCbit){
+      if(tmpQGateArg.isQbit){
+        tmpDepQbit.push_back(tmpQGateArg);	
+        tracked_all_operands &= backtraceOperand(CI->getArgOperand(iop),0);
+      }
+
+      if(tmpDepQbit.size()>0){	  
+        allDepQbit.push_back(tmpDepQbit[0]);
+        assert(tmpDepQbit.size() == 1 && "tmpDepQbit SIZE GT 1");
+        tmpDepQbit.clear();
+      }
+
+    }
+
+    if(allDepQbit.size() > 0){
+      if(debugGetCriticalPath)
+      {
+        errs() << "\nCall inst: " << CI->getCalledFunction()->getName();	    
+        errs() << ": Found all arguments: ";       
+        for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+          if(allDepQbit[vb].argPtr)
+            errs() << allDepQbit[vb].argPtr->getName() <<" Index: ";
+
+          //else
+          errs() << allDepQbit[vb].valOrIndex <<" ";
+        }
+        errs()<<"\n";
+
+      }
+
+      string fname =  CI->getCalledFunction()->getName();  
+      qGate thisGate;
+      thisGate.qFunc =  CI->getCalledFunction();
+
+
+      for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+        if(allDepQbit[vb].argPtr){
+          qGateArg param =  allDepQbit[vb];       
+          thisGate.args[thisGate.numArgs].name = param.argPtr->getName();
+          if(!param.isPtr)
+            thisGate.args[thisGate.numArgs].index = param.valOrIndex;
+          thisGate.numArgs++;
+        }
+      }
+
+      calc_critical_time(F,thisGate);       
+
+    }    
+    allDepQbit.erase(allDepQbit.begin(),allDepQbit.end());
+    }
+  }
+
+
+  void GetCriticalPath::saveTableFuncQbits(Function* F){
+    map<unsigned int, map<int, uint64_t> > tmpFuncQbitsMap;
+
+    for(map<string, map<int, uint64_t> >::iterator mapIt = funcQbits.begin(); mapIt!=funcQbits.end(); ++mapIt){
+      map<string, unsigned int>::iterator argIt = funcArgs.find((*mapIt).first);
+      if(argIt!=funcArgs.end()){
+        unsigned int argNum = (*argIt).second;
+        tmpFuncQbitsMap[argNum] = (*mapIt).second;
+      }
+    }
+    tableFuncQbits[F] = tmpFuncQbitsMap;
+  }
+
+
+  void GetCriticalPath::saveTableFuncQbitsStart(Function* F){
+    map<unsigned int, map<int, uint64_t> > tmpFuncQbitsMap;
+
+    for(map<string, map<int, uint64_t> >::iterator mapIt = funcQbitsHalf.begin(); mapIt!=funcQbitsHalf.end(); ++mapIt){
+      map<string, unsigned int>::iterator argIt = funcArgs.find((*mapIt).first);
+      if(argIt!=funcArgs.end()){
+        unsigned int argNum = (*argIt).second;
+        tmpFuncQbitsMap[argNum] = (*mapIt).second;
+      }
+    }
+    tableFuncQbitsStart[F] = tmpFuncQbitsMap;
+  }
+
+
+  void GetCriticalPath::init_funcQbitsHalf(uint64_t i){
+    //copy all entries of funcQbit
+    //print_funcQbitsHalf();
+
+    for(map<string, map<int,uint64_t> >::iterator inItr = funcQbits.begin(); inItr!=funcQbits.end(); ++inItr){
+      //find string in funcQbitsHalf
+      //errs() << "Looking for string " << (*inItr).first << "\n";
+      map<string, map<int,uint64_t> >::iterator outItr = funcQbitsHalf.find((*inItr).first);
+      assert(outItr != funcQbitsHalf.end() && "funcQbitsHalf does not have entry");
+
+      for(map<int,uint64_t>::iterator in2Itr = (*inItr).second.begin(); in2Itr!=(*inItr).second.end(); ++in2Itr){
+        (*outItr).second[(*in2Itr).first] = i;
+      }
+    }
+
+  }
+
+  void GetCriticalPath::gen_half_funcQbits(uint64_t ct, uint64_t hct){
+    init_funcQbitsHalf(ct);
+
+    for(uint64_t i=hct+1; i<ct; i++){
+      map<uint64_t, vector<qGate> >::iterator mit=tsGates.find(i);
+      for(vector<qGate>::iterator vit = (*mit).second.begin(); vit!=(*mit).second.end(); ++vit){
+        //iterate over the args
+        for(int j=0; j<(*vit).numArgs; j++){
+          string argName = (*vit).args[j].name;
+          int argIndex = (*vit).args[j].index;
+          map<string, map<int,uint64_t> >::iterator fit = funcQbitsHalf.find(argName);
+          assert(fit!=funcQbitsHalf.end() && "arg not found in funQbitsHalf");
+
+          assert(argIndex != -1 && "argindex is -1");
+
+          map<int,uint64_t>::iterator mfit = (*fit).second.find(argIndex);
+          assert(mfit != (*fit).second.end() && "arg index not found in funcQbitsHalf");
+
+          if(i < (*mfit).second){ //gate scheduled in TS=i
+            (*mfit).second = i;	  
+          }
+
+        }
+
+      }
+
+    }
+    //print_funcQbitsHalf();
+
+  }
+
+  void GetCriticalPath::schedule_alap_insts(uint64_t ct, uint64_t hct){
+    //errs() << "Scheduling insts ALAP, starting from ts: " << hct << "\n";
+
+    assert(hct!=0 && "ZERO hct");
+
+    for(uint64_t i=hct; i>=1; i--){
+      map<uint64_t, vector<qGate> >::iterator mit=tsGates.find(i);
+      for(vector<qGate>::iterator vit = (*mit).second.begin(); vit!=(*mit).second.end(); ++vit){
+        //iterate over the args and get ALAP num
+        uint64_t min_ts_of_all_args = ct;
+
+        for(int j=0; j<(*vit).numArgs; j++){
+          string argName = (*vit).args[j].name;
+          int argIndex = (*vit).args[j].index;
+
+          map<string, map<int,uint64_t> >::iterator fit = funcQbitsHalf.find(argName);
+          assert(fit!=funcQbitsHalf.end() && "arg not found in funQbitsHalf");
+          assert(argIndex != -1 && "argIndex = -1 in sched_alap");
+
+          //if(argIndex == -1) //operation on entire array
+          //{
+          //find min for the array
+          //map<int,uint64_t>::iterator indexIter = (*fit).second.find(-2);
+          //  if((*indexIter).second < min_ts_of_all_args)
+          //    min_ts_of_all_args = (*indexIter).second;	  
+          //}
+          //else
+          //{
+          map<int,uint64_t>::iterator mfit = (*fit).second.find(argIndex);
+          assert(mfit != (*fit).second.end() && "arg index not found in funcQbitsHalf");
+
+          if((*mfit).second < min_ts_of_all_args)
+            min_ts_of_all_args = (*mfit).second;
+          //}
+        }
+        //print_qgate((*vit));
+        //errs() << "min_ts_of_all_args = " << min_ts_of_all_args << "\n";
+        (*vit).alap_num = min_ts_of_all_args-1;
+
+        //schedule gate in min_ts_of_all_args - 1; update funcQbitsHalf
+        //--print_scheduled_gate((*vit),min_ts_of_all_args-1);
+
+        //find last timestep for all arguments of qgate
+        for(int j=0;j<(*vit).numArgs; j++){
+          map<string, map<int,uint64_t> >::iterator mIter = funcQbitsHalf.find((*vit).args[j].name);
+
+          int argIndex = (*vit).args[j].index;
+
+          if(argIndex == -1){
+            for(map<int,uint64_t>::iterator entryIter = (*mIter).second.begin(); entryIter!=(*mIter).second.end();++entryIter){
+              (*entryIter).second = min_ts_of_all_args - 1;
+            }
+
+          }
+          else{
+            //update the timestep number for that argument
+            map<int,uint64_t>::iterator indexIter = (*mIter).second.find(argIndex);
+            (*indexIter).second =  min_ts_of_all_args - 1;
+
+            //update -2 entry for the array, i.e. min ts over all indices
+            indexIter = (*mIter).second.find(-2);
+            if((*indexIter).second > min_ts_of_all_args - 1)
+              (*indexIter).second = min_ts_of_all_args - 1;
+          }  
+        }
+      }
+    }
+    //print_funcQbitsHalf();
+  }
+
+  void GetCriticalPath::process_nonLeafALAP(){
+    //copy entries from funcQbits and set values to 1 => zero slack
+    init_funcQbitsHalf(1);
+
+  }
+
+  void GetCriticalPath::CountCriticalFunctionResources (Function *F) {
+    // Traverse instruction by instruction
+    init_critical_path_algo(F);
+
+
+    for (inst_iterator I = inst_begin(*F), E = inst_end(*F); I != E; ++I) {
+      Instruction *Inst = &*I;                            // Grab pointer to instruction reference
+      analyzeAllocInst(F,Inst);          
+      analyzeCallInst(F,Inst);	
+    }
+
+    if(isLeaf){
+      //print_tsGates();
+
+      //do ALAP processing
+      uint64_t critTimeF = max(find_max_funcQbits(), highestDelay);
+      uint64_t halfCritTime = critTimeF/2;
+
+      //errs() << "from FuncQbits = " << find_max_funcQbits();
+      //errs() << " highestDelay = " << highestDelay << "\n";
+      //errs() << "crittimeF=" << critTimeF << "\n";
+
+      if(critTimeF > 3){
+        //generate_half_funcQbits_table
+        gen_half_funcQbits(critTimeF,halfCritTime);
+
+        //schedule instrs in first half ALAP
+        schedule_alap_insts(critTimeF,halfCritTime);
+      }
+      else
+        init_funcQbitsHalf(1);
+
+
+      //print_funcQbits();
+      //print_funcQbitsHalf();
+
+    }
+    else{
+      //dummy info for ALAP
+      process_nonLeafALAP();
+
+    }
+
+
+    saveTableFuncQbits(F);
+    saveTableFuncQbitsStart(F);
+    //print_tableFuncQbits();
+    //print_tableFuncQbitsStart();
+
+  }
+
+
+  void GetCriticalPath::init_gates_as_functions(){
+    for(int  i =0; i< NUM_QGATES ; i++){
+      string gName = gate_name[i];
+      string fName = "llvm.";
+      fName.append(gName);
+
+      allTSParallelism tmp_info;
+      MaxInfo tmp_max_info;
+
+      tmp_info.timesteps = 1;
+      tmp_max_info.timesteps = 1;
+
+      ArrParGates tmp_gate_info;
+      for(int  k=0; k< NUM_QGATES ; k++){
+        tmp_gate_info.parallel_gates[k] = 0;
+        tmp_max_info.parallel_gates[k] = 0;
+      }
+      tmp_gate_info.parallel_gates[i] = 1;
+      tmp_gate_info.parallel_gates[_All] = 1;
+
+      tmp_max_info.parallel_gates[i] = 1;
+      tmp_max_info.parallel_gates[_All] = 1;
+
+      tmp_info.gates.push_back(tmp_gate_info);
+
+      funcParallelFactor[fName] = tmp_info;
+      funcMaxParallelFactor[fName] = tmp_max_info;
+
+    }
+  }
+
+
+  bool GetCriticalPath::runOnModule (Module &M) {
+    init_gate_names();
+    init_gates_as_functions();
+
+    // iterate over all functions, and over all instructions in those functions
+    CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+
+    //Post-order
+    for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode), E = scc_end(rootNode); sccIb != E; ++sccIb) {
+      const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+      for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(), E = nextSCC.end(); nsccI != E; ++nsccI) {
+        Function *F = (*nsccI)->getFunction();	  
+
+        if(F && !F->isDeclaration()){
+          //errs() << "\nFunction: " << F->getName() << "\n";      
+
+          funcQbits.clear();
+          funcQbitsHalf.clear();
+          funcArgs.clear();
+
+          getFunctionArguments(F);
+
+          // count the critical resources for this function
+          CountCriticalFunctionResources(F);
+
+          crit_path_f[F] = max(find_max_funcQbits(), highestDelay);
+          //if(F->getName() == "main")
+          //errs() << F->getName() << ": " << "Critical Path Length : " << find_max_funcQbits() << "\n";
+          errs() << F->getName() << " " << max(find_max_funcQbits(),highestDelay) << " isLeaf= " << isLeaf <<"\n";	
+        }
+        else{
+          if(debugGetCriticalPath)
+            errs() << "WARNING: Ignoring external node or dummy function.\n";
+        }
+      }
+    }
+    //print_tableFuncQbits();
+    //print_critical_info("main");
+
+    //calc_max_parallelism_statistic();
+
+    return false;
+  } // End runOnModule
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/InlineModule.cpp llvm/lib/Transforms/Scaffold/InlineModule.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/InlineModule.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/InlineModule.cpp	2017-10-12 11:09:31.093119606 +0800
@@ -0,0 +1,168 @@
+//===-------------------------- InlineModule.cpp ------------------------===//
+// This file implements the Scaffold pass of inlining modules whose gate 
+// counts are below the threshold. These modules' names have been previously 
+// written to the file "inline_info.txt".
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "InlineModule"
+#include <sstream>
+#include <fstream>
+#include <string>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/Transforms/Utils/Cloning.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+#include "llvm/Support/CallSite.h"
+#include "llvm/Transforms/IPO/InlinerPass.h"
+#include "llvm/Transforms/Utils/Local.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/Target/TargetData.h"
+#include "llvm/ADT/SCCIterator.h"
+
+// DEBUG switch
+bool debugInlining = true;
+
+using namespace llvm;
+
+// An anonymous namespace for the pass. Things declared inside it are
+// only visible to the current file.
+namespace {
+
+  // Derived from ModulePass to work on callgraph
+  struct InlineModule : public ModulePass {
+    static char ID; // Pass identification
+    InlineModule() : ModulePass(ID) {}
+
+    // what functions to make inlined
+    std::vector <Function*> makeInlined;
+    
+    // mark those call sites to be inlined
+    std::vector<CallInst*> inlineCallInsts; 
+
+    // functions in post-order
+    std::vector<Function*> vectPostOrder;
+
+    bool runOnModule (Module &M);
+    bool runOnSCC( const std::vector<CallGraphNode *> &scc );
+    bool runOnFunction( Function & F );    
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+        AU.setPreservesCFG();  
+        AU.addRequired<CallGraph>();
+        AU.addRequired<TargetData>(); 
+    }
+
+  }; // End of struct InlineModule
+} // End of anonymous namespace
+
+
+char InlineModule::ID = 0;
+static RegisterPass<InlineModule> X("InlineModule", "Quantum Module Inlining Pass", false, false);
+
+bool InlineModule::runOnModule( Module & M ) {  
+  std::vector<std::string> inlinedNames;
+  std::string line;
+  std::ifstream file ("inline_info.txt");
+  if(file.is_open()) {
+    while(std::getline(file, line))
+      inlinedNames.push_back(line);
+    file.close();
+  }
+  else
+    errs() << "Error: Could not open inline_info file.\n";
+
+  for (std::vector<std::string>::iterator i = inlinedNames.begin(), e = inlinedNames.end();
+      i!=e; ++i) {
+    if (debugInlining)
+      errs() << "inline_info: " << *i << "\n";
+    makeInlined.push_back(M.getFunction(*i));
+  }
+  
+  // First, get a pointer to previous analysis results
+  CallGraph & CG = getAnalysis<CallGraph>();
+
+  CallGraphNode * entry = CG.getRoot();
+  if( entry && entry->getFunction() && debugInlining)
+    errs() << "Entry is function: " << entry->getFunction()->getName() << "\n";
+
+  // Iterate over all SCCs in the module in bottom-up order
+  for( scc_iterator<CallGraph*>
+   si=scc_begin( &CG ), se=scc_end( &CG ); si != se; ++si ) {
+    runOnSCC( *si );
+  }
+
+  //reverse the vector for preorder
+  std::reverse(vectPostOrder.begin(),vectPostOrder.end());
+
+  for(std::vector<Function*>::iterator vit = vectPostOrder.begin(), vitE = vectPostOrder.end();
+      vit!=vitE; ++vit) { 
+    Function *f = *vit;      
+    runOnFunction(*f);    
+  }
+
+  
+  // now we have all the call sites which need to be inlined
+  // inline from the leaves all the way up
+  const TargetData *TD = getAnalysisIfAvailable<TargetData>();
+  InlineFunctionInfo InlineInfo(&CG, TD);  
+
+  std::reverse(inlineCallInsts.begin(),inlineCallInsts.end());
+  for (std::vector<CallInst*>::iterator i = inlineCallInsts.begin(), e = inlineCallInsts.end();
+      i!=e; ++i) {
+    CallInst* CI = *i;
+    bool success = InlineFunction(CI, InlineInfo, false);
+    if(!success) {
+      if (debugInlining)
+        errs() << "Error: Could not inline callee function " << CI->getCalledFunction()->getName()
+                 << " into caller function " << "\n";
+      continue;
+    }
+    if (debugInlining)    
+      errs() << "Successfully inlined callee function " << CI->getCalledFunction()->getName()
+                 << " into caller function " << "\n";
+  }  
+  
+  return false;
+}
+
+bool InlineModule::runOnSCC( const std::vector<CallGraphNode *> &scc ) {
+  for( std::vector<CallGraphNode *>::const_iterator
+   i = scc.begin(), e = scc.end(); i != e; ++i ) {
+    if( *i && (*i)->getFunction() ) {
+      Function & F = *(*i)->getFunction();
+      //runOnFunction( F, *i );
+      vectPostOrder.push_back(&F);
+    }
+  }
+  return false;
+}
+
+bool InlineModule::runOnFunction( Function & F ) {
+  if (debugInlining)  
+    errs() << "run on function: " << F.getName() << "\n";
+  
+  for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I) {
+    Instruction *pInst = &*I;          
+    if(CallInst *CI = dyn_cast<CallInst>(pInst)) {
+      if (std::find(makeInlined.begin(), makeInlined.end(), CI->getCalledFunction()) != makeInlined.end()) {  
+        if (debugInlining)  
+          errs() << "makeInlined: " << CI->getCalledFunction()->getName() << "\n";
+        inlineCallInsts.push_back(CI);
+      }
+    }
+  }
+
+  return true;
+}
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/LLVMBuild.txt llvm/lib/Transforms/Scaffold/LLVMBuild.txt
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/LLVMBuild.txt	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/LLVMBuild.txt	2017-10-12 11:09:31.093119606 +0800
@@ -0,0 +1,23 @@
+;===- ./lib/Transforms/Scaffold/LLVMBuild.txt ------------------*- Conf -*--===;
+;
+; The LLVM Compiler Infrastructure
+;
+; This file is distributed under the University of Illinois Open Source
+; License. See LICENSE.TXT for details.
+;
+;===------------------------------------------------------------------------===;
+;
+; This is an LLVMBuild description file for the components in this subdirectory.
+;
+; For more information on the LLVMBuild system, please see:
+;
+; http://llvm.org/docs/LLVMBuild.html
+;
+;===------------------------------------------------------------------------===;
+
+[component_0]
+type = Library
+name = Scaffold
+parent = Transforms
+library_name = Scaffold
+required_libraries = Analysis Core InstCombine Support Target TransformUtils
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/Makefile llvm/lib/Transforms/Scaffold/Makefile
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/Makefile	2017-10-12 11:09:31.093119606 +0800
@@ -0,0 +1,8 @@
+# Makefile for Scaffold passes
+
+LEVEL = ../../..
+LIBRARYNAME = Scaffold
+LOADABLE_MODULE = 1
+
+
+include $(LEVEL)/Makefile.common
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/Optimize.cpp llvm/lib/Transforms/Scaffold/Optimize.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/Optimize.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/Optimize.cpp	2017-10-12 11:09:31.094119615 +0800
@@ -0,0 +1,1543 @@
+//===- Optimize.cpp - Optimize flattened circuit and produce QASM file-------------------===//
+//
+//                     The LLVM Scaffold Compiler Infrastructure
+//
+// This file was created by Scaffold Compiler Working Group
+//===----------------------------------------------------------------------===//
+
+#include <sstream>
+#include <algorithm>
+#include <string>
+#include <climits>
+#include "llvm/Argument.h"
+#include "llvm/Pass.h"
+#include "llvm/Module.h"
+#include "llvm/Function.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/SCCIterator.h"
+#include "llvm/ADT/ilist.h"
+#include "llvm/Constants.h"
+#include "llvm/Analysis/DebugInfo.h"
+#include "llvm/IntrinsicInst.h"
+
+
+using namespace llvm;
+using namespace std;
+
+#define MAX_BT_COUNT 15 //max backtrace allowed - to avoid infinite recursive loops
+#define MAX_QBIT_ARR_DIM 5 //max dimensions allowed for qbit arrays
+#define OPT_THRESHOLD 10
+bool debugOptimize = false;
+
+namespace {
+
+  struct qGateArg{ //arguments to qgate calls
+    Value* argPtr;
+    int argNum;
+    bool isQbit;
+    bool isAbit;
+    bool isCbit;
+    bool isParam;
+    bool isUndef;
+    bool isPtr;
+    bool isDouble;
+    int numDim; //number of dimensions of qbit array
+    int dimSize[MAX_QBIT_ARR_DIM]; //sizes of dimensions of array for qbit declarations OR indices of specific qbit for gate arguments
+    int valOrIndex; //Value if not Qbit, Index if Qbit & not a Ptr
+    double val;
+    //Note: valOrIndex is of type integer. Assumes that quantities will be int in the program.
+    qGateArg(): argPtr(NULL), argNum(-1), isQbit(false), isAbit(false), isCbit(false), isParam(false), isUndef(false), isPtr(false), isDouble(false), numDim(0), valOrIndex(-1), val(0.0){ }
+  };
+  
+  struct FnCall{ //datapath sequence
+    Function* func;
+    Value* instPtr;
+    std::vector<qGateArg> qArgs;
+  };    
+
+  struct OpGate{
+    char gateTy;
+    int target;
+    int control1;
+    int control2;
+  };
+
+  struct Optimize : public ModulePass {
+    static char ID;  // Pass identification, replacement for typeid
+    std::vector<Value*> vectQbit;
+
+    std::vector<qGateArg> tmpDepQbit;
+    std::vector<qGateArg> allDepQbit;
+
+    map<Function*, vector<qGateArg> > mapQbitsInit;
+    map<Function*, vector<qGateArg> > mapFuncArgs;
+    map<Function*, vector<FnCall> > mapMapFunc;
+
+    vector<qGateArg> qbitsInFunc; //qbits in function
+    vector<qGateArg> qbitsInFuncShort; //qbits in function
+    vector<qGateArg> qbitsInitInFunc; //new qbits declared in function
+    vector<qGateArg> funcArgList; //function arguments
+    vector<FnCall> mapFunction; //trace sequence of qgate calls
+    vector<OpGate> gateList; //for optimizing gates
+    vector<string>  bitMap;
+    vector<unsigned> indMap;
+    map<Value*, qGateArg> mapInstRtn;    //traces return cbits for Meas Inst
+
+    int btCount; //backtrace count
+
+    Optimize() : ModulePass(ID) {  }
+
+    bool getQbitArrDim(Type* instType, qGateArg* qa);
+    bool backtraceOperand(Value* opd, int opOrIndex);
+    unsigned canSwap(vector<OpGate>& G, unsigned iInd, unsigned fInd);
+    bool ifCommute(OpGate G1, OpGate G2);
+    void optimal(vector<OpGate>& G, vector<unsigned>& M);
+    unsigned countGate(vector<OpGate>& G);
+    void erase_OpGate(OpGate& G);
+    bool shareBit(OpGate G1, OpGate G2);
+    void optimal_initial(Function* F, vector<string>& B, vector<OpGate>& G);
+    void analyzeAllocInst(Function* F,Instruction* pinst);
+    void analyzeAllocInstShort(Function* F,Instruction* pinst);
+    void analyzeCallInst(Function* F,Instruction* pinst);
+    void analyzeInst(Function* F,Instruction* pinst);
+
+    // run - Print out SCCs in the call graph for the specified module.
+    bool runOnModule(Module &M);
+
+    void printFuncHeader(Function* F, bool lastFunc);
+
+	string to_string(int var);
+
+    string printVarName(StringRef s)
+    {
+      std::string sName = s.str();
+
+      unsigned pos = sName.rfind("..");
+
+      if(pos == sName.length()-2){
+	std::string s1 = sName.substr(0,pos);
+	return s1;
+      }
+      else{
+	unsigned pos1 = sName.rfind(".");
+	
+	if(pos1 == sName.length()-1){
+	  std::string s1 = sName.substr(0,pos1);
+	  return s1;
+	}
+	else{
+	  pos = sName.find(".addr");
+	  std::string s1 = sName.substr(0,pos);     
+	  return s1;
+	}
+      }
+    }
+    
+    void print_qgateArg(qGateArg qg)
+    {
+      errs()<< "Printing QGate Argument:\n";
+      if(qg.argPtr) errs() << "  Name: "<<qg.argPtr->getName()<<"\n";
+      errs() << "  Arg Num: "<<qg.argNum<<"\n"
+	     << "  isUndef: "<<qg.isUndef
+	     << "  isQbit: "<<qg.isQbit
+	     << "  isAbit: "<<qg.isAbit
+	     << "  isCbit: "<<qg.isCbit
+	     << "  isPtr: "<<qg.isPtr << "\n"
+	     << "  Value or Index: "<<qg.valOrIndex<<"\n"
+	     << "  Num of Dim: "<<qg.numDim<<"\n";
+      for(int i = 0; i<qg.numDim; i++)
+	errs() << "     dimSize ["<<i<<"] = "<<qg.dimSize[i] << "\n";
+    }
+
+    void genGateArray(Function* F);
+    void getFunctionArguments(Function* F);
+    bool DetermineQFunc(Function* F);
+    
+    void print(raw_ostream &O, const Module* = 0) const { 
+      errs() << "Qbits found: ";
+      for(unsigned int vb=0; vb<vectQbit.size(); vb++){
+	errs() << vectQbit[vb]->getName() <<" ";
+      }
+      errs()<<"\n";      
+    }
+  
+    // getAnalysisUsage - This pass requires the CallGraph.
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();
+      AU.addRequired<CallGraph>();
+    }
+  };
+}
+
+char Optimize::ID = 0;
+static RegisterPass<Optimize>
+X("Optimize", "Optimize circuits"); //spatil: should be Z or X??
+
+bool Optimize::backtraceOperand(Value* opd, int opOrIndex)
+{
+
+  if(opOrIndex == 0) //backtrace for operand
+  {
+    //search for opd in qbit/cbit vector
+    std::vector<Value*>::iterator vIter=std::find(vectQbit.begin(),vectQbit.end(),opd);
+    if(vIter != vectQbit.end()){
+      if(debugOptimize)
+        errs()<<"Found qubit associated: "<< opd->getName() << "\n";
+
+      tmpDepQbit[0].argPtr = opd;
+
+      return true;
+    }
+
+    if(btCount>MAX_BT_COUNT)
+      return false;
+
+    if(GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(opd))
+	{
+	  if(debugOptimize)
+	  {
+	      errs() << "Get Elem Ptr Inst Found: " << *GEPI <<"\n";
+	      errs() << GEPI->getPointerOperand()->getName();
+	      errs() << " has index = " << GEPI->hasIndices();
+	      errs() << " has all constant index = " << GEPI->hasAllConstantIndices() << "\n";
+	  }
+
+	  if(GEPI->hasAllConstantIndices()){
+	    Instruction* pInst = dyn_cast<Instruction>(opd);
+	    unsigned numOps = pInst->getNumOperands();
+	    if(debugOptimize)
+	      errs() << " Has constant index. Num Operands: " << numOps << ": ";
+
+	    
+	    bool foundOne = backtraceOperand(pInst->getOperand(0),0);
+
+	    if(numOps>2){ //set the dimensionality of the qbit
+	      tmpDepQbit[0].numDim = numOps-2;
+	    
+	    for(unsigned arrIter=2; arrIter < numOps; arrIter++)
+	      {
+		ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(arrIter));
+		//errs() << "Arr[ "<<arrIter<<" ] = "<<CI->getZExtValue()<<"\n";
+		if(tmpDepQbit.size()==1){
+		  tmpDepQbit[0].dimSize[arrIter-2] = CI->getZExtValue();  
+		}
+	      }
+	    }
+	    else if(numOps==2){
+	      tmpDepQbit[0].numDim = 1;
+	      ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(numOps-1));
+	      if(tmpDepQbit.size()==1){
+		tmpDepQbit[0].dimSize[0] = CI->getZExtValue();
+		if(debugOptimize)
+		  errs()<<" Found constant index = "<<CI->getValue()<<"\n";
+	      }
+	    }
+
+	    //NOTE: getelemptr instruction can have multiple indices. Currently considering last operand as desired index for qubit. Check this reasoning. 
+	    ConstantInt *CI = dyn_cast<ConstantInt>(pInst->getOperand(numOps-1));
+	    if(tmpDepQbit.size()==1){
+	      tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+	      if(debugOptimize)
+		errs()<<" Found constant index = "<<CI->getValue()<<"\n";
+	    }
+	    return foundOne;
+	  }
+	  
+	  else if(GEPI->hasIndices()){ //NOTE: Edit this function for multiple indices, some of which are constant, others are not.
+	  
+	    errs() << "Oh no! I don't know how to handle this case..ABORT ABORT..\n";
+	    Instruction* pInst = dyn_cast<Instruction>(opd);
+	    unsigned numOps = pInst->getNumOperands();
+	    if(debugOptimize)
+	      errs() << " Has non-constant index. Num Operands: " << numOps << ": ";		
+	    bool foundOne = backtraceOperand(pInst->getOperand(0),0);
+
+	    if(tmpDepQbit[0].isQbit && !(tmpDepQbit[0].isPtr)){     
+	      //NOTE: getelemptr instruction can have multiple indices. consider last operand as desired index for qubit. Check if this is true for all.
+	      backtraceOperand(pInst->getOperand(numOps-1),1);
+	      
+	    }
+		else if(tmpDepQbit[0].isAbit && !(tmpDepQbit[0].isPtr)){
+			backtraceOperand(pInst->getOperand(numOps-1),1);
+		}
+	    return foundOne;
+	  }	  
+	  else{	    
+	    Instruction* pInst = dyn_cast<Instruction>(opd);
+	    unsigned numOps = pInst->getNumOperands();
+	    bool foundOne = false;
+	    for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	      foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),0);
+	    }
+	    return foundOne;
+	  }
+	}
+      
+      if(isa<LoadInst>(opd)){
+	if(tmpDepQbit[0].isQbit && !tmpDepQbit[0].isPtr){
+	  tmpDepQbit[0].numDim = 1;
+	  tmpDepQbit[0].dimSize[0] = 0;
+	  if(debugOptimize)
+	    errs()<<" Added default dim to qbit & not ptr variable.\n";
+	}
+	else if(tmpDepQbit[0].isAbit && !tmpDepQbit[0].isPtr){
+		tmpDepQbit[0].numDim = 1;
+		tmpDepQbit[0].dimSize[0] = 0;
+	}
+      }
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	unsigned numOps = pInst->getNumOperands();
+	bool foundOne = false;
+	for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	  btCount++;
+	  foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),0);
+	  btCount--;
+	}
+	return foundOne;
+      }
+      else{
+	if(debugOptimize)
+	  errs() << "Ending Recursion\n";
+	return false;
+      }
+    }
+  else if(opOrIndex == 0){ //opOrIndex == 1; i.e. Backtracing for Index    
+    if(btCount>MAX_BT_COUNT) //prevent infinite backtracing
+      return true;
+
+    if(ConstantInt *CI = dyn_cast<ConstantInt>(opd)){
+      tmpDepQbit[0].valOrIndex = CI->getZExtValue();
+      if(debugOptimize)
+	errs()<<" Found constant index = "<<CI->getValue()<<"\n";
+
+      return true;
+    }      
+
+    if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+      unsigned numOps = pInst->getNumOperands();
+      bool foundOne = false;
+      for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	btCount++;
+	foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),1);
+	btCount--;
+      }
+      return foundOne;
+    }
+
+  }
+
+  else{ //opOrIndex == 2: backtracing to call inst MeasZ
+    if(debugOptimize)
+      errs()<<"backtracing for call inst: "<<*opd<<"\n";
+    if(CallInst *endCI = dyn_cast<CallInst>(opd)){
+      if(endCI->getCalledFunction()->getName().find("llvm.Meas") != string::npos){
+	tmpDepQbit[0].argPtr = opd;
+
+	if(debugOptimize)
+	  errs()<<" Found call inst = "<<*endCI<<"\n";
+	return true;
+      }
+      else{
+	if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	  unsigned numOps = pInst->getNumOperands();
+	  bool foundOne=false;
+	  for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	    btCount++;
+	    foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+	    btCount--;
+	  }
+	  return foundOne;
+	}
+      }
+    }
+    else{
+      if(Instruction* pInst = dyn_cast<Instruction>(opd)){
+	unsigned numOps = pInst->getNumOperands();
+	bool foundOne=false;
+	for(unsigned iop=0;(iop<numOps && !foundOne);iop++){
+	  btCount++;
+	  foundOne = foundOne || backtraceOperand(pInst->getOperand(iop),2);
+	  btCount--;
+	}
+	return foundOne;
+      }
+    }
+  }
+  return false;
+}
+
+bool Optimize::getQbitArrDim(Type *instType, qGateArg* qa)
+{
+  bool myRet = false;
+
+  errs() << "In get_all_dimensions \n";
+
+  if(ArrayType *arrayType = dyn_cast<ArrayType>(instType)) {
+    Type *elementType = arrayType->getElementType();
+    uint64_t arraySize = arrayType->getNumElements();
+    errs() << "Array Size = "<<arraySize << "\n";
+    qa->dimSize[qa->numDim] = arraySize;
+    qa->numDim++;
+
+    if (elementType->isIntegerTy(16)){
+      myRet = true;
+      qa->isQbit = true;
+    }
+    else if (elementType->isIntegerTy(1)){
+      myRet = true;
+      qa->isCbit = true;
+    }
+	else if(elementType->isIntegerTy(8)){
+		myRet = true;
+		qa->isAbit = true;
+	}
+    else if (elementType->isArrayTy()){
+      myRet |= getQbitArrDim(elementType,qa);
+    }
+    else myRet = false;
+  }
+
+  return myRet;
+
+}
+
+void Optimize::analyzeAllocInstShort(Function* F, Instruction* pInst){
+
+  if (AllocaInst *AI = dyn_cast<AllocaInst>(pInst)) {
+    Type *allocatedType = AI->getAllocatedType();
+    
+    if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+      qGateArg tmpQArg;
+
+      Type *elementType = arrayType->getElementType();
+      uint64_t arraySize = arrayType->getNumElements();
+      if (elementType->isIntegerTy(16)){
+	if(debugOptimize)
+	  errs() << "New QBit Allocation Found: " << AI->getName() <<"\n";
+	qbitsInFuncShort.push_back(tmpQArg);
+      }
+      
+      else if (elementType->isIntegerTy(1)){
+	if(debugOptimize)
+	  errs() << "New CBit Allocation Found: " << AI->getName() <<"\n";
+	qbitsInFuncShort.push_back(tmpQArg);
+      }
+
+	  else if (elementType->isIntegerTy(8)){
+		qbitsInFuncShort.push_back(tmpQArg);
+	  }
+
+    }
+    else if(allocatedType->isIntegerTy(16)){
+        qGateArg tmpQArg;
+        qbitsInFuncShort.push_back(tmpQArg);
+    }
+	else if(allocatedType->isIntegerTy(8)){
+		qGateArg tmpQArg;
+		qbitsInFuncShort.push_back(tmpQArg);
+	}
+	//find argName2 in funcArgList - avoid printing out qbit declaration twice
+	//std::map<Function*, vector<qGateArg> >::iterator mIter = funcArgList.find(F);
+	//if(mIter != funcArgList.end()){
+    return;
+  }
+
+}
+
+void Optimize::analyzeAllocInst(Function* F, Instruction* pInst){
+  if (AllocaInst *AI = dyn_cast<AllocaInst>(pInst)) {
+    Type *allocatedType = AI->getAllocatedType();
+    
+    if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+      qGateArg tmpQArg;
+	  
+	  Type *elementType = arrayType->getElementType();
+      uint64_t arraySize = arrayType->getNumElements();
+      if (elementType->isIntegerTy(16)){
+	if(debugOptimize)
+	  errs() << "New QBit Allocation Found: " << AI->getName() <<"\n";
+	vectQbit.push_back(AI);
+	tmpQArg.isQbit = true;
+	tmpQArg.argPtr = AI;
+	tmpQArg.numDim = 1;
+	tmpQArg.dimSize[0] = arraySize;
+	tmpQArg.valOrIndex = arraySize;
+	//(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	qbitsInFunc.push_back(tmpQArg);
+	//(qbitsInitInFunc.find(F))->second.push_back(tmpQArg);	
+	qbitsInitInFunc.push_back(tmpQArg);	
+      }
+      
+      else if (elementType->isIntegerTy(1)){
+	if(debugOptimize)
+	  errs() << "New CBit Allocation Found: " << AI->getName() <<"\n";
+	vectQbit.push_back(AI); //Cbit added here
+	tmpQArg.isCbit = true;
+	tmpQArg.argPtr = AI;
+	tmpQArg.numDim = 1;
+	tmpQArg.dimSize[0] = arraySize;
+	tmpQArg.valOrIndex = arraySize;
+	//(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	qbitsInFunc.push_back(tmpQArg);
+	//(qbitsInitInFunc.find(F))->second.push_back(tmpQArg);	
+	qbitsInitInFunc.push_back(tmpQArg);	
+      }
+
+	  else if (elementType->isIntegerTy(8)){
+		vectQbit.push_back(AI); //Cbit added here
+		tmpQArg.isCbit = false;
+		tmpQArg.isAbit = true;
+		tmpQArg.argPtr = AI;
+		tmpQArg.numDim = 1;
+		tmpQArg.dimSize[0] = arraySize;
+		tmpQArg.valOrIndex = arraySize;
+		//(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+		qbitsInFunc.push_back(tmpQArg);
+		//(qbitsInitInFunc.find(F))->second.push_back(tmpQArg);	
+		qbitsInitInFunc.push_back(tmpQArg);	
+	  }
+
+      else if(elementType->isArrayTy()){
+	  errs() << "Multidimensional array\n";
+
+	  tmpQArg.dimSize[0] = arraySize;
+	  tmpQArg.numDim++;
+	  tmpQArg.valOrIndex = arraySize;
+
+	  //recurse on multi-dimensional array
+	  bool isQAlloc = getQbitArrDim(elementType,&tmpQArg);
+
+	  if(isQAlloc){
+	    vectQbit.push_back(AI);
+	    tmpQArg.argPtr = AI;
+	    //(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	    qbitsInFunc.push_back(tmpQArg);
+	    //(qbitsInitInFunc.find(F))->second.push_back(tmpQArg);
+	    qbitsInitInFunc.push_back(tmpQArg);
+
+	    if(debugOptimize)
+	      print_qgateArg(tmpQArg);
+	  }	  
+      }
+
+    }
+    else if(allocatedType->isIntegerTy(16)){
+        qGateArg tmpQArg;
+        if(debugOptimize) errs() << "Found New Qbit Allocation \n";
+        vectQbit.push_back(AI);
+        tmpQArg.isQbit = true;
+        tmpQArg.argPtr = AI;
+        tmpQArg.numDim = 1;
+//        tmpQArg.dimSize[0] = 1;
+        tmpQArg.dimSize[0] = cast<ConstantInt>(AI->getArraySize())->getSExtValue();
+        tmpQArg.valOrIndex = 1;
+        qbitsInFunc.push_back(tmpQArg);
+        qbitsInitInFunc.push_back(tmpQArg);
+    }
+
+    else if(allocatedType->isPointerTy()){
+      
+      /*Note: this is necessary if -mem2reg is not run on LLVM IR before.
+	Eg without -mem2reg
+	module(i8* %q){
+	%q.addr = alloca i8*, align 8
+	...
+	}
+	qbit q.addr must be mapped to argument q. Hence the following code.
+	If it is known that -O1 will be run, then this can be removed.
+      */
+      
+      Type *elementType = allocatedType->getPointerElementType();
+      if (elementType->isIntegerTy(16)){
+	vectQbit.push_back(AI);
+	
+	qGateArg tmpQArg;
+	tmpQArg.isPtr = true;
+	tmpQArg.isQbit = true;
+	tmpQArg.argPtr = AI;
+	
+	//(qbitsInFunc.find(F))->second.push_back(tmpQArg);
+	qbitsInFunc.push_back(tmpQArg);
+	
+	std::string argName = AI->getName();
+	unsigned pos = argName.find(".addr");
+	std::string argName2 = argName.substr(0,pos);
+
+	//find argName2 in funcArgList - avoid printing out qbit declaration twice
+	//std::map<Function*, vector<qGateArg> >::iterator mIter = funcArgList.find(F);
+	//if(mIter != funcArgList.end()){
+	  bool foundit = false;
+	  for(vector<qGateArg>::iterator vParamIter = funcArgList.begin();(vParamIter!=funcArgList.end() && !foundit);++vParamIter){
+	    if((*vParamIter).argPtr->getName() == argName2){ 
+	      foundit = true;
+	    }
+	  }
+	  if(!foundit) //do not add duplicate declaration	    
+	    qbitsInitInFunc.push_back(tmpQArg);
+	  //}
+      }
+	  else if (elementType->isIntegerTy(8)){
+		vectQbit.push_back(AI);
+		qGateArg tmpQArg;
+		tmpQArg.isPtr = true;
+		tmpQArg.isAbit = true;
+		tmpQArg.argPtr = AI;
+
+		qbitsInFunc.push_back(tmpQArg);
+
+		std::string argName = AI->getName();
+		unsigned pos = argName.find(".addr");
+		std::string argName2 = argName.substr(0,pos);
+		bool foundit = false;
+		for(vector<qGateArg>::iterator vParamIter = funcArgList.begin();(vParamIter!=funcArgList.end() && !foundit);++vParamIter){
+	    	if((*vParamIter).argPtr->getName() == argName2) foundit = true;
+	  	}
+		if(!foundit) qbitsInitInFunc.push_back(tmpQArg);
+	  }
+	}
+    return;
+  }
+
+}
+
+void Optimize::analyzeCallInst(Function* F, Instruction* pInst){
+  if(CallInst *CI = dyn_cast<CallInst>(pInst))
+    {
+      if(debugOptimize)      
+	errs() << "Call inst: " << CI->getCalledFunction()->getName() << "\n";
+
+      if(CI->getCalledFunction()->getName() == "store_cbit"){	//trace return values
+	qGateArg tmpQGateArg1;
+	tmpQGateArg1.isCbit = true;
+	tmpDepQbit.push_back(tmpQGateArg1);
+	backtraceOperand(CI->getArgOperand(0),2); //value Operand
+	Value* rtnVal = tmpDepQbit[0].argPtr;
+	tmpDepQbit.clear();
+
+	qGateArg tmpQGateArg2;
+	tmpQGateArg2.isCbit = true;
+	tmpQGateArg2.isPtr = true;
+	tmpDepQbit.push_back(tmpQGateArg2);	
+	backtraceOperand(CI->getArgOperand(1),0); //pointer Operand
+
+	//insert info in map here
+	mapInstRtn[rtnVal] = tmpDepQbit[0];
+
+	tmpDepQbit.clear();
+	return;
+      }
+      
+      bool tracked_all_operands = true;
+      
+      for(unsigned iop=0;iop<CI->getNumArgOperands();iop++){
+	tmpDepQbit.clear();
+	
+	qGateArg tmpQGateArg;
+	btCount=0;
+	
+	if(debugOptimize)
+	  errs() << "Call inst operand num: " << iop << "\n";
+	
+	tmpQGateArg.argNum = iop;
+	
+	
+	if(isa<UndefValue>(CI->getArgOperand(iop))){
+	  //errs() << "WARNING: LLVM IR code has UNDEF values. \n";
+	  tmpQGateArg.isUndef = true;	
+	  //exit(1);
+	  //assert(0 && "LLVM IR code has UNDEF values. Aborting...");
+	}
+	
+	Type* argType = CI->getArgOperand(iop)->getType();
+	if(argType->isPointerTy()){
+	  tmpQGateArg.isPtr = true;
+	  Type *argElemType = argType->getPointerElementType();
+	  if(argElemType->isIntegerTy(16))
+	    tmpQGateArg.isQbit = true;
+	  if(argElemType->isIntegerTy(1))
+	    tmpQGateArg.isCbit = true;
+	  if(argElemType->isIntegerTy(8))
+		tmpQGateArg.isAbit = true;
+	}
+	else if(argType->isIntegerTy(16)){
+	  tmpQGateArg.isQbit = true;
+	  tmpQGateArg.valOrIndex = 0;	 
+	}	  	
+	else if(argType->isIntegerTy(32)){
+	  if(ConstantInt *CInt = dyn_cast<ConstantInt>(CI->getArgOperand(iop))){
+	  	tmpQGateArg.isParam = true;
+	  	tmpQGateArg.valOrIndex = CInt->getZExtValue();
+	  }
+	}
+	else if(argType->isIntegerTy(8)){
+		tmpQGateArg.isAbit = true;
+		tmpQGateArg.valOrIndex = 0;
+	}
+	else if(argType->isIntegerTy(1)){
+	  tmpQGateArg.isCbit = true;
+	  tmpQGateArg.valOrIndex = 0;	 
+	}	  	
+	
+	//check if argument is constant int	
+	if(ConstantInt *CInt = dyn_cast<ConstantInt>(CI->getArgOperand(iop))){
+	  tmpQGateArg.valOrIndex = CInt->getZExtValue();
+	  if(debugOptimize){
+	    errs()<<" Found constant argument = "<<CInt->getValue()<<"\n";
+	  }
+	}
+	
+	//check if argument is constant float	
+	if(ConstantFP *CFP = dyn_cast<ConstantFP>(CI->getArgOperand(iop))){
+	  tmpQGateArg.val = CFP->getValueAPF().convertToDouble();
+	  tmpQGateArg.isDouble = true;
+	  if(debugOptimize){
+	    errs()<<" Call Inst = "<<*CI<<"\n";
+	    errs()<<" Found constant double argument = "<<tmpQGateArg.val<<"\n";
+	  }
+	}
+
+	tmpDepQbit.push_back(tmpQGateArg);
+	
+	tracked_all_operands &= backtraceOperand(CI->getArgOperand(iop),0);
+	
+	if(tmpDepQbit.size()>0){
+	  if(debugOptimize)
+	    print_qgateArg(tmpDepQbit[0]);
+	  
+	  allDepQbit.push_back(tmpDepQbit[0]);
+	  assert(tmpDepQbit.size() == 1 && "tmpDepQbit SIZE GT 1");
+	  tmpDepQbit.clear();
+	}
+	
+      }
+                  
+      //form info packet
+      FnCall qInfo;
+      qInfo.func = CI->getCalledFunction();
+      qInfo.instPtr = CI;
+      
+      if(allDepQbit.size() > 0){
+	if(debugOptimize)
+	  {
+	    errs() << "\nCall inst: " << CI->getCalledFunction()->getName();	    
+	    errs() << ": Found all arguments: ";       
+	    for(unsigned int vb=0; vb<allDepQbit.size(); vb++){
+	      if(allDepQbit[vb].argPtr)
+		errs() << allDepQbit[vb].argPtr->getName() <<" ";
+	      else
+		errs() << allDepQbit[vb].valOrIndex <<" ";
+	    }
+	    errs()<<"\n";
+	  }
+	
+	//populate vector of passed qubit arguments
+	for(unsigned int vb=0; vb<allDepQbit.size(); vb++)
+	  qInfo.qArgs.push_back(allDepQbit[vb]);
+	
+      }
+      
+      //map<Function*, vector<FnCall> >::iterator mvdpit = mapFunction.find(F);	
+      //(*mvdpit).second.push_back(qInfo);      
+      mapFunction.push_back(qInfo);
+
+      return;      
+    }
+}
+
+void Optimize::analyzeInst(Function* F, Instruction* pInst){
+  if(debugOptimize)
+    errs() << "--Processing Inst: "<<*pInst << '\n';
+
+  //analyzeAllocInst(F,pInst);
+  analyzeCallInst(F,pInst);
+    
+  if(debugOptimize)
+    {
+      errs() << "Opcode: "<<pInst->getOpcodeName() << "\n";
+      
+      unsigned numOps = pInst->getNumOperands();
+      errs() << "Num Operands: " << numOps << ": ";
+      
+      for(unsigned iop=0;iop<numOps;iop++){
+	errs() << pInst->getOperand(iop)->getName() << "; ";
+      }
+      errs() << "\n";		
+      return;
+    }
+    
+  return;
+}
+
+std::string Optimize::to_string(int var){
+	stringstream ss;
+	ss << var;
+	return ss.str();
+}
+
+void Optimize::printFuncHeader(Function* F, bool lastFunc)
+{
+
+  //map<Function*, vector<qGateArg> >::iterator mpItr;
+  //map<Function*, vector<qGateArg> >::iterator mpItr2;
+  //map<Function*, vector<qGateArg> >::iterator mvpItr;
+
+  //mpItr = qbitsInFunc.find(F);
+
+  //print name of function
+
+  funcArgList = mapFuncArgs.find(F)->second;
+  qbitsInitInFunc = mapQbitsInit.find(F)->second;
+
+  std::string newName = F->getName();
+  std::replace(newName.begin(), newName.end(), '.','_');
+  std::replace(newName.begin(), newName.end(), '-','_');
+
+  if(lastFunc) errs() << "\nmodule main";
+  else errs()<<"\nmodule "<< newName;
+  
+  //print arguments of function
+  //mpItr2=funcArgList.find(F);    
+  errs()<<" ( ";    
+  unsigned tmp_num_elem = funcArgList.size();
+  
+  if(tmp_num_elem > 0){
+    for(unsigned tmp_i=0;tmp_i<tmp_num_elem - 1;tmp_i++){
+      
+      qGateArg tmpQA = funcArgList[tmp_i];
+      
+      if(debugOptimize)
+	print_qgateArg(tmpQA);
+      
+      if(tmpQA.isQbit)
+	errs()<<"qbit";
+      else if(tmpQA.isCbit)
+	errs()<<"cbit";
+	  else if(tmpQA.isAbit)
+		errs() << "qbit";
+      else{
+	Type* argTy = tmpQA.argPtr->getType();
+	if(argTy->isDoubleTy()) errs() << "double";
+	else if(argTy->isFloatTy()) errs() << "float";
+	else if(argTy->isIntegerTy(32)){
+		string var = to_string(tmpQA.valOrIndex);
+		errs() << var;
+	}
+	else
+	  errs()<<"UNRECOGNIZED "<<argTy<<" ";
+      }
+      
+      if(tmpQA.isPtr)
+	errs()<<"*";	  
+      
+      errs()<<" "<<printVarName(tmpQA.argPtr->getName())<<" , ";
+    }
+    
+    if(debugOptimize)
+      print_qgateArg(funcArgList[tmp_num_elem-1]);
+    
+    if((funcArgList[tmp_num_elem-1]).isQbit)
+      errs()<<"qbit";
+    else if((funcArgList[tmp_num_elem-1]).isCbit)
+      errs()<<"cbit";
+	else if((funcArgList[tmp_num_elem-1]).isAbit)
+	  errs() << "qbit";
+    else{
+      Type* argTy = (funcArgList[tmp_num_elem-1]).argPtr->getType();
+      if(argTy->isDoubleTy()) errs() << "double";
+      else if(argTy->isFloatTy()) errs() << "float";
+	  else if(argTy->isIntegerTy(32)){
+			string var = to_string(funcArgList[tmp_num_elem-1].valOrIndex); 
+//			errs() << var; 
+			errs() << "int size"; 
+	  }
+	else
+	errs()<<"UNRECOGNIZED "<<argTy<<" ";
+    }
+    
+    if((funcArgList[tmp_num_elem-1]).isPtr)
+      errs()<<"*";
+    
+    errs() <<" "<<printVarName((funcArgList[tmp_num_elem-1]).argPtr->getName());
+  }
+  
+  errs()<<" ) {\n ";   
+  
+  //print qbits declared in function
+  //mvpItr=qbitsInitInFunc.find(F);	    
+  for(vector<qGateArg>::iterator vvit=qbitsInitInFunc.begin(),vvitE=qbitsInitInFunc.end();vvit!=vvitE;++vvit)
+    {	
+      if((*vvit).isQbit)
+	errs()<<"\tqbit "<<printVarName((*vvit).argPtr->getName());
+      if((*vvit).isCbit)
+	errs()<<"\tcbit "<<printVarName((*vvit).argPtr->getName());
+	  if((*vvit).isAbit)
+	errs() << "\tqbit "<<printVarName((*vvit).argPtr->getName());
+
+      //if only single-dimensional qbit arrays expected
+      //errs()<<"["<<(*vvit).valOrIndex<<"];\n ";
+
+      //if n-dimensional qbit arrays expected 
+      for(int ndim = 0; ndim < (*vvit).numDim; ndim++)
+        errs()<<"["<<(*vvit).dimSize[ndim]<<"]";
+        errs() << ";\n";
+    }
+  //errs() << "//--//-- Fn: " << F->getName() << " --//--//\n";
+}
+  
+void Optimize::genGateArray(Function* F)
+{
+  //map<Function*, vector<qGateArg> >::iterator mpItr;
+  //map<Function*, vector<qGateArg> >::iterator mpItr2;
+  //map<Function*, vector<qGateArg> >::iterator mvpItr;
+  
+  //mpItr = qbitsInFunc.find(F);
+//  if(qbitsInFunc.size()>0){
+    
+    mapFunction = mapMapFunc.find(F)->second; 
+    //print gates in function
+    //map<Function*, vector<FnCall> >::iterator mfvIt = mapFunction.find(F);
+    for(unsigned mIndex=0;mIndex<mapFunction.size();mIndex++){
+      if(mapFunction[mIndex].qArgs.size()>0)
+      {
+
+	string fToPrint = mapFunction[mIndex].func->getName();
+	if(fToPrint.find("llvm.") != string::npos)
+	  fToPrint = fToPrint.substr(5);
+	errs()<<"\t";
+
+	//print return operand before printing MeasZ
+	if(fToPrint.find("Meas") != string::npos){
+	  //get inst ptr
+	  Value* thisInstPtr = mapFunction[mIndex].instPtr;
+	  //find inst in mapInstRtn
+	  map<Value*, qGateArg>::iterator mvq = mapInstRtn.find(thisInstPtr);
+	  if(mvq!=mapInstRtn.end()){
+	    errs()<<printVarName(((*mvq).second).argPtr->getName());
+	    if(((*mvq).second).isPtr)
+	      errs()<<"["<<((*mvq).second).valOrIndex<<"]";
+	    errs()<<" = ";
+	  }	  
+	}
+	// Intrinsic Conversion
+	if(fToPrint.find("CNOT") != string::npos) fToPrint = "CNOT";
+	else if(fToPrint.find("Toffoli.") != string::npos) fToPrint = "Toffoli";
+	else if(fToPrint.find("MeasX") != string::npos) fToPrint = "MeasX";
+	else if(fToPrint.find("MeasZ") != string::npos) fToPrint = "MeasZ";
+	else if(fToPrint.find("H.i") != string::npos) fToPrint = "H";
+	else if(fToPrint.find("Fredkin") != string::npos) fToPrint = "Fredkin";
+	else if(fToPrint.find("PrepX") != string::npos) fToPrint = "PrepX";
+	else if(fToPrint.find("PrepZ") != string::npos) fToPrint = "PrepZ";
+	else if(fToPrint.substr(0,2) == "Rz") fToPrint = "Rz";
+	else if(fToPrint.find("S.") != string::npos) fToPrint = "S";
+	else if(fToPrint.find("T.") != string::npos) fToPrint = "T";
+	else if(fToPrint.find("Sdag") != string::npos) fToPrint = "Sdag";
+	else if(fToPrint.find("Tdag") != string::npos) fToPrint = "Tdag";
+	else if(fToPrint.find("X.") != string::npos) fToPrint = "X";
+	else if(fToPrint.find("Z.") != string::npos) fToPrint = "Z";
+
+	std::replace(fToPrint.begin(), fToPrint.end(), '.', '_');
+	std::replace(fToPrint.begin(), fToPrint.end(), '-', '_');
+	errs()<<fToPrint<<" ( ";
+
+	//print all but last argument
+	for(vector<qGateArg>::iterator vpIt=mapFunction[mIndex].qArgs.begin(), vpItE=mapFunction[mIndex].qArgs.end();vpIt!=vpItE-1;++vpIt)
+	  {
+	    if((*vpIt).isUndef)
+	      errs() << " UNDEF ";
+	    else{
+	      if((*vpIt).isQbit || (*vpIt).isCbit || (*vpIt).isAbit ){
+		errs()<<printVarName((*vpIt).argPtr->getName());
+		if(!((*vpIt).isPtr)){		  
+		  //if only single-dimensional qbit arrays expected
+		  //--if((*vpIt).numDim == 0)
+		  //errs()<<"["<<(*vpIt).valOrIndex<<"]";
+		  //--else
+		    //if n-dimensional qbit arrays expected 
+		    for(int ndim = 0; ndim < (*vpIt).numDim; ndim++)
+		      errs()<<"["<<(*vpIt).dimSize[ndim]<<"]";
+		}
+	      }
+		  else if((*vpIt).isParam){
+			errs() << (*vpIt).valOrIndex;
+		  }
+	      else{
+		//assert(!(*vpIt).isPtr); 
+		if((*vpIt).isPtr) //NOTE: not expecting non-quantum pointer variables as arguments to quantum functions. If they exist, then print out name of variable
+		  errs() << " UNRECOGNIZED ";
+		else if((*vpIt).isDouble)
+		  errs() << (*vpIt).val;
+		else
+		  errs()<<(*vpIt).valOrIndex;	      
+	      }
+	    }	    	    
+	    errs()<<" , ";
+	  }
+
+	//print last element	
+	qGateArg tmpQA = mapFunction[mIndex].qArgs.back();
+
+	if(tmpQA.isUndef)
+	  errs() << " UNDEF ";
+	else{
+	  if(tmpQA.isQbit || tmpQA.isCbit || tmpQA.isAbit){
+	    errs()<<printVarName(tmpQA.argPtr->getName());
+	    if(!(tmpQA.isPtr)){
+	      //if only single-dimensional qbit arrays expected
+	      //--if(tmpQA.numDim == 0)
+	      //errs()<<"["<<tmpQA.valOrIndex<<"]";
+	      //--else
+		//if n-dimensional qbit arrays expected 
+		for(int ndim = 0; ndim < tmpQA.numDim; ndim++)
+		  errs()<<"["<<tmpQA.dimSize[ndim]<<"]";	      	      	      
+	    }
+	  }
+	  else{
+	    //assert(!tmpQA.isPtr); //NOTE: not expecting non-quantum pointer variables as arguments to quantum functions. If they exist, then print out name of variable
+	    if(tmpQA.isPtr)
+	      errs() << " UNRECOGNIZED ";
+	    else if(tmpQA.isDouble) 
+	      errs() << tmpQA.val;
+	    else
+	      errs()<<tmpQA.valOrIndex;	    
+	  }
+	  
+	}
+	errs()<<" );\n ";	      
+      }
+    }
+
+    //errs() << "//--//-- End Fn: " << F->getName() << " --//--// \n";
+    errs()<<"}\n";
+//  }
+}
+
+
+bool Optimize::DetermineQFunc(Function* F)
+{
+    for(inst_iterator instIb = inst_begin(F),instIe=inst_end(F); instIb!=instIe;++instIb){
+        Instruction *pInst = &*instIb; // Grab pointer to instruction reference	      
+	    analyzeAllocInstShort(F,pInst);
+	}
+    if(qbitsInFuncShort.size() > 0) return true;
+    qbitsInFuncShort.clear();
+    return false;
+}
+
+unsigned Optimize::canSwap(vector<OpGate>& G, unsigned iInd, unsigned fInd)
+{
+    if(iInd > fInd) {
+        errs()<<"initial index larger than final index.\n";
+        return UINT_MAX-1;
+    }
+    
+    unsigned iPos = iInd, fPos = fInd;
+    for(unsigned i = iInd + 1; i <= fInd; i++){
+        if(ifCommute(G[iInd], G[i])){ iPos = i; }
+        else { break; }
+    }
+    for(unsigned i = fInd - 1; i >= iInd; i--){
+        if(ifCommute(G[fInd], G[i])){fPos = i;}
+        else{break;}
+    } 
+    if(iPos >= fPos - 1 ){
+        return max(fPos - 1, iInd); 
+    }
+    else{
+        return UINT_MAX; 
+    }
+}
+
+bool Optimize::ifCommute(OpGate G1, OpGate G2){
+    bool G1st = false, G2st = false;
+    if(G1.gateTy == 't' || G1.gateTy == 's' || G1.gateTy =='S' || G1.gateTy == 'T') {G1st =true;}
+    if(G2.gateTy == 't' || G2.gateTy == 's' || G2.gateTy =='S' || G2.gateTy == 'T') {G2st =true;}
+
+    if(G1.gateTy =='\0' || G2.gateTy == '\0') {return true;}
+
+    if(G1.gateTy != 'c' && G1.gateTy != 'o' && G2.gateTy != 'c' && G2.gateTy != 'o'){
+        if(G1.target != G2.target) {return true;}
+        else if(G1st && G2st) {return true;}
+        else {return false;}
+    }
+
+    else if((G1.gateTy != 'c' && G1.gateTy != 'o')){
+        if(G1.target != G2.target && G1.target != G2.control1 && G1.target != G2.control2){return true;}
+        if(G1st && G1.target != G2.target){return true;}
+        return false;
+    }
+
+    else if((G2.gateTy != 'c' && G2.gateTy != 'o')){
+        if(G2.target != G1.target && G2.target != G1.control1 && G2.target != G1.control2){return true;}
+        if(G2st && G1.target != G2.target){return true;}
+        return false;
+    }
+
+    else if(G1.target != G2.control1 && G1.target != G2.control2 && G2.target != G1.control1 && G2.target != G1.control2){
+        return true; 
+    }
+    return false;
+}
+
+bool Optimize::shareBit(OpGate G1, OpGate G2){
+    if((G1.target == G2.target && G1.target != 0) || (G1.target == G2.control1 && G1.target != 0) || (G1.target == G2.control2 && G1.target != 0) || (G1.control1 == G2.control2 && G1.control1 != 0) || (G1.control1 == G2.control1 && G1.control1 != 0) || (G1.control1 == G2.target && G1.control1 != 0) || (G1.control2 == G2.target && G1.control2 != 0) || (G1.control2 == G2.control1 && G1.control2 != 0) || (G1.control2 == G2.control2 && G1.control2 != 0)){ return true;}
+    else {return false;}
+}
+void Optimize::getFunctionArguments(Function* F)
+{
+  //std::vector<unsigned> qGateArgs;  
+
+  for(Function::arg_iterator ait=F->arg_begin();ait!=F->arg_end();++ait)
+    {    
+      std::string argName = (ait->getName()).str();
+      Type* argType = ait->getType();
+      unsigned int argNum=ait->getArgNo();         
+
+      qGateArg tmpQArg;
+      tmpQArg.argPtr = ait;
+      tmpQArg.argNum = argNum;
+
+      if(argType->isPointerTy()){
+	if(debugOptimize)
+	  errs()<<"Argument Type: " << *argType <<"\n";
+
+	tmpQArg.isPtr = true;
+
+	Type *elementType = argType->getPointerElementType();
+	if (elementType->isIntegerTy(16)){
+	  tmpQArg.isQbit = true;
+	  vectQbit.push_back(ait);
+	  qbitsInFunc.push_back(tmpQArg);
+	  funcArgList.push_back(tmpQArg);
+	}
+	else if (elementType->isIntegerTy(1)){
+	  tmpQArg.isCbit = true;
+	  vectQbit.push_back(ait);
+	  qbitsInFunc.push_back(tmpQArg);
+	  funcArgList.push_back(tmpQArg);
+	}
+	else if(elementType->isIntegerTy(8)){
+	  tmpQArg.isAbit = true;
+	  vectQbit.push_back(ait);
+	  qbitsInFunc.push_back(tmpQArg);
+	  funcArgList.push_back(tmpQArg);
+	}
+      }
+      else if (argType->isIntegerTy(16)){
+	tmpQArg.isQbit = true;
+	vectQbit.push_back(ait);
+	qbitsInFunc.push_back(tmpQArg);
+	funcArgList.push_back(tmpQArg);
+      }
+      else if (argType->isIntegerTy(32)){
+	tmpQArg.isParam = true;
+	vectQbit.push_back(ait);
+	funcArgList.push_back(tmpQArg);
+      }
+      else if (argType->isIntegerTy(1)){
+	tmpQArg.isCbit = true;
+	vectQbit.push_back(ait);
+	qbitsInFunc.push_back(tmpQArg);
+	funcArgList.push_back(tmpQArg);
+      }
+	  else if(argType->isIntegerTy(8)){
+		tmpQArg.isAbit = true;
+		vectQbit.push_back(ait);
+		qbitsInFunc.push_back(tmpQArg);
+		funcArgList.push_back(tmpQArg);
+	  }
+      else if(argType->isDoubleTy())     
+	funcArgList.push_back(tmpQArg);
+
+      if(debugOptimize)
+	print_qgateArg(tmpQArg);
+    }
+}
+
+unsigned Optimize::countGate(vector<OpGate>& G){
+    unsigned rtvl = 0;
+    for(unsigned i = 0; i < G.size(); i++){
+        if(G[i].gateTy != '\0') rtvl++; 
+    }
+    return rtvl;
+}
+//Convert llvm internal data structure to OpGate for cleaner qubit argument(of gate) presentation
+//and easier qubit map later
+void Optimize::optimal_initial(Function * F, vector<string> &B, vector<OpGate> &G){
+             
+    mapFunction = mapMapFunc.find(F)->second;
+    
+    B.push_back(" ");
+
+    unsigned i = 1;
+    for(vector<qGateArg>::iterator vvit=qbitsInitInFunc.begin(),vvitE=qbitsInitInFunc.end();vvit!=vvitE;++vvit){
+        
+        string qName = printVarName((*vvit).argPtr->getName());
+        unsigned dMul = 1;
+        //flatten multi-array 
+        for(unsigned ndim = 0; ndim < (*vvit).numDim; ndim++){
+            dMul *= dMul * (*vvit).dimSize[ndim];
+         }
+        for(unsigned dimIter = 0; dimIter < dMul; dimIter++){
+            string newQ = qName + '_' + to_string(dimIter);
+            B.push_back(newQ);
+            i++;
+        }
+    }
+
+    for(unsigned mIndex=0;mIndex<mapFunction.size();mIndex++){
+        OpGate nxtGate = {'\0', 0, 0, 0};
+
+	    string fName = mapFunction[mIndex].func->getName();
+
+        if(fName.find("H.") !=string::npos){ nxtGate.gateTy = 'h';}
+        else if(fName.find("CNOT") !=string::npos){ nxtGate.gateTy = 'c';}
+        else if(fName.find("Tof") !=string::npos){ nxtGate.gateTy = 'o';}
+        else if(fName.find("MeasX") !=string::npos){ nxtGate.gateTy = 'X';}
+        else if(fName.find("MeasZ") !=string::npos){ nxtGate.gateTy = 'Z';}
+        else if(fName.find("PrepX") !=string::npos){ nxtGate.gateTy = 'n';}
+        else if(fName.find("PrepZ") !=string::npos){ nxtGate.gateTy = 'm';}
+        else if(fName.find("Sdag") !=string::npos){ nxtGate.gateTy = 'S';}
+        else if(fName.find("S.") !=string::npos){ nxtGate.gateTy = 's';}
+        else if(fName.find("T.") !=string::npos){ nxtGate.gateTy = 't';}
+        else if(fName.find("Tdag") !=string::npos){ nxtGate.gateTy = 'T';}
+        else if(fName.substr(0,2) == "Rz"){ nxtGate.gateTy = 'r';}
+        else if(fName.find("X.") !=string::npos){ nxtGate.gateTy = 'x';}
+        else if(fName.find("Z.") !=string::npos){ nxtGate.gateTy = 'z';}
+       
+        unsigned ToC = 0; //target or control
+        for(vector<qGateArg>::iterator vpIt=mapFunction[mIndex].qArgs.begin(), vpItE=mapFunction[mIndex].qArgs.end();vpIt!=vpItE;++vpIt){
+           string qName = printVarName((*vpIt).argPtr->getName()) ;
+           unsigned qInd = 0;
+           for(vector<qGateArg>::iterator vvit=qbitsInitInFunc.begin(),vvitE=qbitsInitInFunc.end();vvit!=vvitE;++vvit){
+                   if((*vvit).argPtr == (*vpIt).argPtr){
+                       for(unsigned ndim = 0; ndim < (*vpIt).numDim-1; ndim++){
+                            qInd += (*vpIt).dimSize[ndim]*(*vvit).dimSize[ndim+1];
+                       }
+                       qInd += (*vpIt).dimSize[(*vpIt).numDim-1];
+                   }
+           }
+           qName = qName + '_' + to_string(qInd);
+           bool foundGate = false;
+           for(unsigned i = 1; i < B.size(); i++){
+
+               if(qName.compare(B[i]) == 0){
+                   if(nxtGate.gateTy == 'c'){
+                      if(ToC == 0) 
+                        {nxtGate.control1 = i;}
+                      if(ToC == 1)
+                        {nxtGate.target = i;}
+                   }
+                   else if(nxtGate.gateTy == 'o'){
+                      if(ToC == 0) 
+                        {nxtGate.control1 = i;}
+                      if(ToC == 1)
+                        {nxtGate.control2 = i;}
+                      if(ToC == 2)
+                        {nxtGate.target = i;}
+                   }
+                   else{
+                      if(ToC == 0)
+                        {nxtGate.target = i;}
+                   }
+                   foundGate = true;
+                   break;
+               } 
+           }
+           ToC++;
+           if(!foundGate){errs()<<"can't find the gate.\n";}
+       }
+       G.push_back(nxtGate);
+   }
+    //errs()<<"Printing OpGate list"<<"\n";
+    //for(vector<OpGate>::iterator Git = G.begin(), GitE = G.end(); Git != GitE; ++Git){
+    //   errs()<< Git->gateTy<<" "<<Git->control1<<" "<<Git->control2<< " " << Git->target<<"\n";
+    // } 
+    for(unsigned i = 0; i < B.size()+1; i++){
+        indMap.push_back(i);
+    }
+
+} 
+void Optimize::erase_OpGate(OpGate& g){
+    g.gateTy = '\0';
+    g.target = 0;
+    g.control1 = 0;
+    g.control2 = 0;
+    return;
+}
+void Optimize::optimal(vector<OpGate>& G, vector<unsigned>& M){
+
+    if(G.size() == 0) return;
+
+    //templates
+    for(unsigned gInd = 0; gInd < G.size(); gInd++){
+        temp_begin:
+        if(G[gInd].gateTy == '\0') continue;
+        if(G[gInd].gateTy == 'c'){
+            unsigned gOff = 1;
+            unsigned gCount = 0; 
+            while(((gOff + gInd) < G.size()) && gCount < OPT_THRESHOLD){
+               if(G[gInd+gOff].gateTy == 'c' && G[gInd+gOff].target == G[gInd].target && G[gInd+gOff].control1 == G[gInd].control1){
+                  unsigned newPos =  canSwap(G, gInd, gInd + gOff);
+                  if(newPos != UINT_MAX) {
+                      erase_OpGate(G[gInd]);
+                      erase_OpGate(G[gInd+gOff]);
+                      break;
+                  }
+               }       
+               if(G[gInd+gOff].gateTy == 'c' && G[gInd+gOff].target == G[gInd].control1 && G[gInd+gOff].control1 == G[gInd].target){
+
+                  unsigned newPos =  canSwap(G, gInd, gInd + gOff);
+                  if(newPos == UINT_MAX) {break;}
+                  if(newPos != gInd){
+                      OpGate temp = G[gInd];
+                      for(unsigned i =  gInd; i < newPos; i++){
+                          G[i] = G[i+1];
+                      }
+                      G[newPos] = temp;
+                      goto temp_begin;
+                  }
+                  else{
+                      erase_OpGate(G[gInd]);
+                      unsigned tempUn = G[gInd + gOff].target;
+                      G[gInd + gOff].target = G[gInd + gOff].control1;
+                      G[gInd + gOff].control1 = tempUn;
+                      tempUn = M[G[gInd].target];
+                      M[G[gInd].target] = M[G[gInd].control1];
+                      M[G[gInd].control1] = tempUn;
+                      break;
+                  }
+                  
+               }
+               gOff++;
+               if(shareBit(G[gInd], G[gInd + gOff])) {gCount++;}
+            }
+        }
+        if(G[gInd].gateTy != '\0'){
+            G[gInd].control1 = M[G[gInd].control1];
+            G[gInd].target = M[G[gInd].target];
+        }
+        
+    }
+
+}
+
+// run - Find datapaths for qubits
+bool Optimize::runOnModule(Module &M) {
+  vector<Function*> qFuncs;
+
+  CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+  unsigned sccNum = 0;
+
+//  for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode),
+//         E = scc_end(rootNode); sccIb != E; ++sccIb)
+//    {
+//      const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+//
+//      if(debugOptimize)
+//	errs() << "\nSCC #" << ++sccNum << " : ";      
+//
+//      for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(),
+//	     E = nextSCC.end(); nsccI != E; ++nsccI)
+//	{
+//	  Function *F=(*nsccI)->getFunction();	  
+//	  
+//	  if(F && !F->isDeclaration()){
+//        if(DetermineQFunc(F)){
+//            qFuncs.push_back(F);
+//        }
+//      }
+//    }
+//  }
+//
+//  bool hasMain = false;
+//  for( vector<Function*>::iterator it = qFuncs.begin(); it!=qFuncs.end(); it++)
+//  {
+//    if ((*it)->getName() == "main") hasMain = true;
+//  }
+//  if(!hasMain){
+//    vector<Function*>::iterator it = qFuncs.end();
+//    it--;
+//    (*it)->setName("main");
+//  }
+   
+  CallGraphNode* rootNode1 = getAnalysis<CallGraph>().getRoot();
+
+  sccNum = 0;
+
+  for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode1),
+         E = scc_end(rootNode1); sccIb != E; ++sccIb)
+    {
+      const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+
+      if(debugOptimize)
+	errs() << "\nSCC #" << ++sccNum << " : ";      
+      
+      for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(),
+	     E = nextSCC.end(); nsccI != E; ++nsccI)
+	{
+	  Function *F=(*nsccI)->getFunction();	  
+	  
+	  if(F && !F->isDeclaration()){
+	    if(debugOptimize)
+	    errs() << "Processing Function:" << F->getName() <<" \n ";
+
+	    //initialize map structures for this function
+	    //vector<qGateArg> myQIFVec, myQIFVec1, myQIFVec2;
+	    qbitsInFunc.clear();
+	    qbitsInitInFunc.clear();
+	    funcArgList.clear();
+
+	    //std::vector<FnCall> myFuncMapVec;
+	    mapFunction.clear();
+
+	    getFunctionArguments(F);
+
+	    //visit Alloc Insts in func and find if function is quantum or classical function
+
+	    for(inst_iterator instIb = inst_begin(F),instIe=inst_end(F); instIb!=instIe;++instIb){
+
+	      Instruction *pInst = &*instIb; // Grab pointer to instruction reference	      
+          
+	      if(debugOptimize)
+		errs() << "\n Processing Inst: "<<*pInst << "\n";
+
+	      analyzeAllocInst(F,pInst);
+	    }
+
+	    //map<Function*, vector<qGateArg> >::iterator mpItr = qbitsInFunc.find(F);
+	    if(qbitsInFunc.size()>0){ //Is Quantum Function
+          mapQbitsInit.insert( make_pair( F, qbitsInitInFunc ) );
+          mapFuncArgs.insert( make_pair( F, funcArgList ) );
+          qFuncs.push_back(F);
+	    
+	      for(inst_iterator instIb = inst_begin(F),instIe=inst_end(F); instIb!=instIe;++instIb){
+
+		Instruction *pInst = &*instIb; // Grab pointer to instruction reference	      
+		allDepQbit.clear();
+		
+		if(debugOptimize)
+		  errs() << "\n Processing Inst: "<<*pInst << "\n";
+		
+		analyzeInst(F,pInst); //spatil: need a bool return type?
+
+	      }
+          mapMapFunc.insert( make_pair( F, mapFunction ) );
+	    }
+	  }
+	  else{
+	    if(debugOptimize)
+	      errs() << "WARNING: Ignoring external node or dummy function.";
+	  }
+	  
+	}
+      if (nextSCC.size() == 1 && sccIb.hasLoop())
+	errs() << " (Has self-loop).";
+    }
+
+    bool hasMain = false;
+    for( vector<Function*>::iterator it = qFuncs.begin(); it!=qFuncs.end(); it++)
+    {
+      if ((*it)->getName() == "main") hasMain = true;
+    }
+
+    vector<Function*>::iterator lastItPos;
+    if(!hasMain){
+        lastItPos = qFuncs.end();
+        lastItPos--;
+    }
+
+    for(vector<Function*>::iterator it = qFuncs.begin(); it != qFuncs.end(); it++){
+        if((*it)->getName() == "main")   //assuming after flattening, the modules left are Toffoli and main, only care about main.
+        {
+            mapFunction = mapMapFunc.find(*it)->second;
+            //Convert llvm internal data structure to OpGate for cleaner qubit argument(of gate) presentation
+            //and easier qubit map later
+            optimal_initial((*it), bitMap, gateList);
+            
+            unsigned gNumBefore = 0;
+            unsigned gNumAfter = gateList.size();
+            while(gNumBefore != gNumAfter){
+                gNumBefore = gNumAfter;
+                optimal(gateList, indMap);
+                gNumAfter = countGate(gateList);
+                //errs()<<"Before:"<<gNumBefore<<" After:"<<gNumAfter<<"\n";
+            }
+            for(unsigned i = 1; i < bitMap.size();i++){
+                errs()<<"qubit "<<bitMap[i]<<"\n"; 
+            }
+            /*
+            for(unsigned i = 1; i < gateList.size();i++){
+                if(gateList[i].gateTy != '\0')
+                    errs()<<gateList[i].gateTy<<" "<<gateList[i].target<<"\n";
+            }*/
+            for(unsigned i = 0; i < gateList.size(); i++){
+                if(gateList[i].gateTy == '\0'){continue;}
+                if(gateList[i].gateTy == 'h'){errs()<<"H ";}
+                if(gateList[i].gateTy == 'c'){errs()<<"CNOT ";}
+                if(gateList[i].gateTy == 'o'){errs()<<"Tof ";}
+                if(gateList[i].gateTy == 'X'){errs()<<"MeasX ";}
+                if(gateList[i].gateTy == 'Z'){errs()<<"MeasZ ";}
+                if(gateList[i].gateTy == 'n'){errs()<<"PrepX ";}
+                if(gateList[i].gateTy == 'm'){errs()<<"PrepZ ";}
+                if(gateList[i].gateTy == 'S'){errs()<<"Sdag ";}
+                if(gateList[i].gateTy == 's'){errs()<<"S ";}
+                if(gateList[i].gateTy == 't'){errs()<<"T ";}
+                if(gateList[i].gateTy == 'T'){errs()<<"Tdag ";}
+                if(gateList[i].gateTy == 'r'){errs()<<"Rz "; }
+                if(gateList[i].gateTy == 'x'){ errs()<<"X ";}
+                if(gateList[i].gateTy == 'z'){ errs()<<"Z ";}
+
+                if(gateList[i].control2 > 0)
+                    {errs()<<bitMap[gateList[i].control2]<<",";
+                    }
+                if(gateList[i].control1 > 0){
+                    errs()<<bitMap[gateList[i].control1]<<",";
+                }
+                if(gateList[i].target > 0)
+                    {errs()<<bitMap[gateList[i].target];} 
+
+                errs()<<"\n";
+
+            }
+            /*
+            for(unsigned mIndex=0;mIndex<mapFunction.size();mIndex++){
+                errs()<<mapFunction[mIndex].func->getName()<<" ";  
+
+                for(vector<qGateArg>::iterator vpIt=mapFunction[mIndex].qArgs.begin(), vpItE=mapFunction[mIndex].qArgs.end();vpIt!=vpItE;++vpIt){
+                   qbitsInitInFunc = mapQbitsInit.find((*it))->second;
+                   errs()<<(*vpIt).argPtr->getName();
+                   for(int ndim = 0; ndim < (*vpIt).numDim; ndim++)
+                       errs()<<"["<<(*vpIt).dimSize[ndim]<<"]\n";
+                   errs()<<" ";
+                }
+                errs()<<"\n";
+            } 
+            */
+        }
+        /*
+        if(it == lastItPos) printFuncHeader((*it), true);
+        else printFuncHeader((*it), false);
+        genGateArray((*it));
+        mapFunction = mapMapFunc.find(*it)->second;
+        for(unsigned mIndex=0;mIndex<mapFunction.size();mIndex++){
+          if(mapFunction[mIndex].qArgs.size()>0){
+            errs()<<"func name: "<<mapFunction[mIndex].func->getName()<<" ";
+    
+          for(vector<qGateArg>::iterator vpIt=mapFunction[mIndex].qArgs.begin(), vpItE=mapFunction[mIndex].qArgs.end();vpIt!=vpItE;++vpIt){
+            errs()<<(*vpIt).argPtr->getName()<<" ";
+          }
+            errs()<<"\n";
+          }
+        }
+        */
+    
+    }
+
+  return false;
+}
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/ResourceCount2.cpp llvm/lib/Transforms/Scaffold/ResourceCount2.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/ResourceCount2.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/ResourceCount2.cpp	2017-10-12 11:09:31.094119615 +0800
@@ -0,0 +1,159 @@
+//===----------------------------- ResourceCount2.cpp -------------------------===//
+// This file implements the Scaffold Pass of counting the number of qbits and
+// gates in a program in callgraph post-order. Printing total for every function.
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "ResourceCount2"
+#include <vector>
+#include <limits>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/ADT/SCCIterator.h"
+
+
+using namespace llvm;
+
+// An anonymous namespace for the pass. Things declared inside it are
+// only visible to the current file.
+namespace {
+
+  // Derived from ModulePass to count qbits in functions
+  struct ResourceCount2 : public ModulePass {
+    static char ID; // Pass identification
+    ResourceCount2() : ModulePass(ID) {}
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();  
+      AU.addRequired<CallGraph>();    
+    }
+    
+    void CountFunctionResources (Function *F, std::map <Function*, unsigned long long* > FunctionResources) const {
+      // Traverse instruction by instruction
+      for (inst_iterator I = inst_begin(*F), E = inst_end(*F); I != E; ++I) {
+        Instruction *Inst = &*I;                            // Grab pointer to instruction reference
+
+        // Qubits?
+        if (AllocaInst *AI = dyn_cast<AllocaInst>(Inst)) {                  // Filter Allocation Instructions
+          Type *allocatedType = AI->getAllocatedType();
+
+          if (ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) { // Filter allocation of arrays
+            Type *elementType = arrayType->getElementType();
+            if (elementType->isIntegerTy(16)) {                           // Filter allocation Type (qbit=i16)
+              uint64_t arraySize = arrayType->getNumElements();            
+              FunctionResources[F][0] += arraySize;                
+            }
+          }
+        }
+
+        // Gates?
+        if (CallInst *CI = dyn_cast<CallInst>(Inst)) {      // Filter Call Instructions
+          Function *callee = CI->getCalledFunction();
+          if (callee->isIntrinsic()) {                      // Intrinsic (Gate) Functions calls
+            if (callee->getName().str() == "llvm.X") 
+              FunctionResources[F][1]++;
+            else if (callee->getName().str() == "llvm.Z") 
+              FunctionResources[F][2]++;
+            else if (callee->getName().str() == "llvm.H") 
+              FunctionResources[F][3]++;
+            else if (callee->getName().str() == "llvm.T") {
+              FunctionResources[F][4]++;
+	      //errs() << "CI: " << *CI << "\n";
+	      //errs() << "Tcount = " << FunctionResources[F][4] << "\n";
+	    }
+            else if (callee->getName().str() == "llvm.Tdag")
+              FunctionResources[F][5]++;
+            else if (callee->getName().str() == "llvm.S") 
+              FunctionResources[F][6]++;
+            else if (callee->getName().str() == "llvm.Sdag")
+              FunctionResources[F][7]++;
+            else if (callee->getName().str() == "llvm.CNOT")
+              FunctionResources[F][8]++;            
+            else if (callee->getName().str() == "llvm.PrepZ") 
+              FunctionResources[F][9]++;
+            else if (callee->getName().str() == "llvm.MeasZ") 
+              FunctionResources[F][10]++;
+          }
+
+          else {                                              // Non-intrinsic Function Calls
+            // Resource numbers must be previously entered
+            // for this call. Look them up and add to this function's numbers.
+            if (FunctionResources.find(callee) != FunctionResources.end()) {
+              unsigned long long* callee_numbers = FunctionResources.find(callee)->second;
+              for (int l=0; l<11; l++)
+                FunctionResources[F][l] += callee_numbers[l];
+            }
+          }
+
+        }
+
+      }
+    }
+
+    virtual bool runOnModule (Module &M) {
+      // Function* ---> Qubits | X | Z | H | T | CNOT | Toffoli | PrepZ | MeasZ | Rz | Ry
+      std::map <Function*, unsigned long long*> FunctionResources;
+
+      // iterate over all functions, and over all instructions in those functions
+      // find call sites that have constant integer values. In Post-Order.
+      CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+      
+      //fill in the gate count bottom-up in the call graph
+      for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode), E = scc_end(rootNode); sccIb != E; ++sccIb) {
+        const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+        //errs() << "\nSCC #" << ++sccNum << " : ";      
+        for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(), E = nextSCC.end(); nsccI != E; ++nsccI) {
+          Function *F = (*nsccI)->getFunction();	  
+          if (F && !F->isDeclaration()) {
+
+	    //errs() << "--Function: " << F->getName() << "\n";
+            // dynamically create array holding gate numbers for this function
+            unsigned long long* ResourceNumbers = new unsigned long long[11];
+            for (int k=0; k<11; k++)
+              ResourceNumbers[k] = 0;
+            FunctionResources.insert(std::make_pair(F, ResourceNumbers));
+
+            // count the gates of this function 
+            CountFunctionResources(F, FunctionResources);
+          }
+        }
+      }
+
+      // print results      
+      for (std::map<Function*, unsigned long long*>::iterator i = FunctionResources.begin(), e = FunctionResources.end(); i!=e; ++i) {
+        errs() << i->first->getName() << ": \t";
+	unsigned long long function_total_gates = 0;
+        for (int j=1; j<11; j++)
+          function_total_gates += (i->second)[j];
+        errs() << function_total_gates <<"\n"; //<< " \t";
+        //errs() << (i->second)[4] << "\n"; // T Gates
+      }
+
+      // free memory
+      for (std::map<Function*, unsigned long long*>::iterator i = FunctionResources.begin(), e = FunctionResources.end(); i!=e; ++i)
+        delete [] i->second;
+
+
+      return false;
+    } // End runOnModule
+  }; // End of struct ResourceCount2
+} // End of anonymous namespace
+
+
+
+char ResourceCount2::ID = 0;
+static RegisterPass<ResourceCount2> X("ResourceCount2", "Resource Counter Pass");
+
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/ResourceCount.cpp llvm/lib/Transforms/Scaffold/ResourceCount.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/ResourceCount.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/ResourceCount.cpp	2017-10-12 11:09:31.094119615 +0800
@@ -0,0 +1,217 @@
+//===----------------------------- ResourceCount2.cpp -------------------------===//
+// This file implements the Scaffold Pass of counting the number of qbits and
+// gates in a program in callgraph post-order. Printing total for every function.
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "ResourceCount2"
+#include <vector>
+#include <limits>
+#include <map>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/ADT/SCCIterator.h"
+
+#include "llvm/Constants.h"
+
+#define NCOUNTS 14
+
+using namespace llvm;
+
+// An anonymous namespace for the pass. Things declared inside it are
+// only visible to the current file.
+namespace {
+  unsigned long long app_total_gates;
+  // Derived from ModulePass to count qbits in functions
+  struct ResourceCount : public ModulePass {
+    static char ID; // Pass identification
+    ResourceCount() : ModulePass(ID) {}
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();  
+      AU.addRequired<CallGraph>();    
+    }
+    
+    void CountFunctionResources (Function *F, std::map <Function*, unsigned long long* > FunctionResources) const {
+      // Traverse instruction by instruction
+      for (inst_iterator I = inst_begin(*F), E = inst_end(*F); I != E; ++I) {
+        Instruction *Inst = &*I;                            // Grab pointer to instruction reference
+
+        // Qubits?
+        if (AllocaInst *AI = dyn_cast<AllocaInst>(Inst)) {                  // Filter Allocation Instructions
+          Type *allocatedType = AI->getAllocatedType();
+          Type *intType=NULL;
+          uint64_t arraySize=0;
+          //errs() << allocatedType->getTypeID() << " allocated: ";
+          //errs() << "Does it have a name? " << AI->getName() << "\n";
+          
+          if (ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) { // Filter allocation of arrays
+            Type *elementType = arrayType->getElementType();
+            //errs() << "dyncasted to array\n";
+            if(elementType->isIntegerTy(8) || elementType->isIntegerTy(16)){
+              //errs() << "inside ifstatement\n";
+              intType = elementType;
+              arraySize = arrayType->getNumElements();
+              //errs() << arraySize << "elements\n";
+            }
+          }
+          else{
+            if(allocatedType->isIntegerTy(8) || allocatedType->isIntegerTy(16)){
+              intType = allocatedType;
+              arraySize = 1;
+            }
+          }
+
+          if(intType){
+
+            if (intType->isIntegerTy(16)) {                           // Filter allocation Type (qbit=i16)
+              FunctionResources[F][0] += arraySize;                
+            }
+            if(intType->isIntegerTy(8)){
+              FunctionResources[F][1] += arraySize;
+              FunctionResources[F][2] += arraySize;
+              if(FunctionResources[F][3] < FunctionResources[F][2])
+                FunctionResources[F][3] = FunctionResources[F][2];
+            }
+          }
+
+        } // end of if allocated instruction
+
+        // Gates?
+        else if (CallInst *CI = dyn_cast<CallInst>(Inst)) {      // Filter Call Instructions
+          Function *callee = CI->getCalledFunction();
+          if (callee->isIntrinsic()) {                      // Intrinsic (Gate) Functions calls
+			FunctionResources[F][14]++;
+            if (callee->getName().startswith("llvm.X"))
+              FunctionResources[F][4]++;
+            else if (callee->getName().startswith("llvm.Z"))
+              FunctionResources[F][5]++;
+            else if (callee->getName().startswith("llvm.H"))
+              FunctionResources[F][6]++;
+            else if (callee->getName().startswith("llvm.Tdag")) {
+              FunctionResources[F][8]++;
+	      //errs() << "CI: " << *CI << "\n";
+	      //errs() << "Tcount = " << FunctionResources[F][4] << "\n";
+	        }
+            else if (callee->getName().startswith("llvm.T"))
+              FunctionResources[F][7]++;
+            else if (callee->getName().startswith("llvm.Sdag"))
+              FunctionResources[F][10]++;
+            else if (callee->getName().startswith("llvm.S"))
+              FunctionResources[F][9]++;
+            else if (callee->getName().startswith("llvm.CNOT"))
+              FunctionResources[F][11]++;            
+            else if (callee->getName().startswith("llvm.PrepZ"))
+              FunctionResources[F][12]++;
+            else if (callee->getName().startswith("llvm.MeasZ"))
+              FunctionResources[F][13]++;
+          }
+
+          else if(CI->getCalledFunction()->getName().startswith("afree")){
+            //errs() << "begin free\n";
+            Type *toAdd = (CI -> getArgOperand(0) -> getType());
+            //errs() << "name: " << CI->getArgOperand(0)->getName() << "\n";
+            uint64_t addNum=0;
+            if (llvm::ConstantInt* consInt = dyn_cast<llvm::ConstantInt>(CI->getArgOperand(1))){
+                addNum = consInt -> getLimitedValue();
+                errs() << addNum << "this is the value\n";
+            }
+            else{
+              addNum = 1;
+            }
+            FunctionResources[F][2] -= addNum;
+            errs() << "net then width" << FunctionResources[F][2] << FunctionResources[F][3] << "\n"; 
+            //errs() << "finish free\n";
+          }
+
+          else {  // Non-intrinsic Function Calls
+            // Resource numbers must be previously entered
+            // for this call. Look them up and add to this function's numbers.
+            if (FunctionResources.find(callee) != FunctionResources.end()) {
+              unsigned long long* callee_numbers = FunctionResources.find(callee)->second;
+			  FunctionResources[F][14] += callee_numbers[14];
+              if(callee_numbers[3] > FunctionResources[F][3] - FunctionResources[F][2])
+                FunctionResources[F][3] = FunctionResources[F][2] + callee_numbers[3];
+              for (int l=0; l<NCOUNTS; l++)
+                if(l!=3)
+                  FunctionResources[F][l] += callee_numbers[l];
+            }
+          } // else a non-intrinsic function call
+        } // end of call instruction
+        // here, we would want to detect the getelement
+      } // end of for each instruction
+    } // end of procedure
+
+    virtual bool runOnModule (Module &M) {
+      // Function* ---> Qubits | Gross Abits | Net Abits | Max Abit Width | X | Z | H | T | CNOT | Toffoli | PrepZ | MeasZ | Rz | Ry
+      std::map <Function*, unsigned long long*> FunctionResources;
+      std::map <Function*, unsigned long long> FunctionTotals;
+  	  std::vector<Function*> callStack;
+	  app_total_gates = 0;
+
+      // iterate over all functions, and over all instructions in those functions
+      // find call sites that have constant integer values. In Post-Order.
+      CallGraphNode* rootNode = getAnalysis<CallGraph>().getRoot();
+      
+      //fill in the gate count bottom-up in the call graph
+      for (scc_iterator<CallGraphNode*> sccIb = scc_begin(rootNode), E = scc_end(rootNode); sccIb != E; ++sccIb) {
+        const std::vector<CallGraphNode*> &nextSCC = *sccIb;
+        for (std::vector<CallGraphNode*>::const_iterator nsccI = nextSCC.begin(), E = nextSCC.end(); nsccI != E; ++nsccI) {
+          Function *F = (*nsccI)->getFunction();	  
+          if (F && !F->isDeclaration()) {
+            // dynamically create array holding gate numbers for this function
+            unsigned long long* ResourceNumbers = new unsigned long long[NCOUNTS];
+            for (int k=0; k<NCOUNTS+1; k++)
+              ResourceNumbers[k] = 0;
+            FunctionResources.insert(std::make_pair(F, ResourceNumbers));
+            // count the gates of this function 
+            CountFunctionResources(F, FunctionResources);
+          }
+        }
+      }
+      
+      // print results     
+      errs() << "\tQubit\tGross A\tNet A\tWidth\tX\tZ\tH\tT\tT_dag\tS\tS_dag\tCNOT\tPrepZ\tMeasZ\n";
+      for (std::map<Function*, unsigned long long*>::iterator i = FunctionResources.begin(), e = FunctionResources.end(); i!=e; ++i) {
+        errs() << "Function: " << i->first->getName() << "\n";
+		unsigned long long function_total_gates = 0;
+        for (int j=0; j<NCOUNTS; j++){
+		  if(j > 3){
+          	function_total_gates += (i->second)[j];
+		  }
+          errs() << "\t" << (i->second)[j];
+	  	}
+		if(i->first->getName() == "main") app_total_gates = function_total_gates;
+        errs() << "\n";
+        errs() << function_total_gates <<"\n"; //<< " \t";
+      }
+	  errs() << "total_gates = "<< app_total_gates << "\n";
+
+      // free memory
+      for (std::map<Function*, unsigned long long*>::iterator i = FunctionResources.begin(), e = FunctionResources.end(); i!=e; ++i)
+        delete [] i->second;
+
+
+      return false;
+    } // End runOnModule
+  }; // End of struct ResourceCount2
+} // End of anonymous namespace
+
+
+
+char ResourceCount::ID = 0;
+static RegisterPass<ResourceCount> X("ResourceCount", "Resource Counter Pass");
+
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/Reverse.cpp llvm/lib/Transforms/Scaffold/Reverse.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/Reverse.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/Reverse.cpp	2017-10-12 11:09:31.094119615 +0800
@@ -0,0 +1,390 @@
+//===------------------------------ Reverse.cpp ---------------------------===//
+//
+// This file implements the Scaffold Pass of reversing functions. In the 
+// initial stage of the compiler, we search all of the IR
+// code for functions beginning with "_reverse_". For any of these functions,
+// we see which function they are meant to reverse; either an intrinsic 
+// function, or a user-defined function. For intrinsic functions, we already 
+// know their inverses. Otherwise, we can reverse user-defined functions 
+// with an "Instruction Visitor," an llvm construct which allows us to 
+// manipulate each individual instruction. Using this visitor, we place the 
+// inverse of each original instruction in reverse of the original order
+// of the instructions.
+//
+// For reasons inherent to the uncertainty of quantum computation, this
+// functionality is often crucial for optimal use of memory, specifically
+// for automatic garbage-collection.
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//===---------------------------------------------------------------------===//
+//
+#include <map>
+
+#include "llvm/ADT/ValueMap.h" 
+
+#include "llvm/Function.h"
+#include "llvm/Instructions.h"
+#include "llvm/Intrinsics.h"
+#include "llvm/LLVMContext.h"
+#include "llvm/Pass.h"
+
+#include "llvm/Support/InstIterator.h"
+#include "llvm/Support/InstVisitor.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+#include "llvm/Transforms/Utils/Cloning.h"
+
+using namespace llvm;
+
+namespace {
+    // We need to use a ModulePass in order to insert new 
+    // Functions into the target code
+    class FunctionReverse : public ModulePass {
+      public:
+        static char ID;
+        // Prefix of functions that should be replaced with the reverse 
+        // of the function with the prefix dropped
+        static const std::string REVERSE_PREFIX;
+        FunctionReverse() : ModulePass(ID) {}
+        // an InstVisitor is an LLVM construct which allows to manipulate
+        // each instruction in our function
+        struct InsertReverseFunctionsVisitor : 
+        public InstVisitor<InsertReverseFunctionsVisitor> {
+            // The reversed function implementations will be Functions 
+            // in M's FunctionList
+            Module *M;
+            // We need to know the inverse of every intrinsic function 
+            // before reversing any functions
+            ValueMap<Function *, Function *> IntrinsicInverses;
+
+            // The constructor is called once per module (in runOnModule)
+            InsertReverseFunctionsVisitor(Module *module) : M(module) {
+                // This table maps each intrinsic function to its inverse
+                std::vector<std::vector<Type*> > onePerm;
+                std::vector<std::vector<Type*> > twoPerms;
+                std::vector<std::vector<Type*> > threePerms;
+                //std::vector<ArrayRef<Type*> > prepTys;
+                //std::vector<ArrayRef<Type*> > RTys;
+                std::vector<Type*> v;
+                //errs() << "About to get type pointers\n";
+                Type *aa = Type::getInt8Ty(M->getContext());
+                Type *qq = Type::getInt16Ty(M->getContext());
+                Type *dd = Type::getDoubleTy(M->getContext());
+                Type *ii = Type::getInt32Ty(M->getContext());
+                /*
+                v.push_back(aa);
+                v.push_back(dd);
+                RTys.push_back(makeArrayRef(v));
+                v.pop_back();
+                v.pop_back();
+                v.push_back(qq);
+                v.push_back(dd);
+                RTys.push_back(makeArrayRef(v));
+
+
+                v.push_back(aa);
+                v.push_back(ii);
+                prepTys.push_back(makeArrayRef(v));
+                v.pop_back();
+                v.pop_back();
+                v.push_back(qq);
+                v.push_back(ii);
+                prepTys.push_back(makeArrayRef(v));
+                */
+                //errs() << "About to make onePerm\n";
+
+                v.push_back(aa);
+                onePerm.push_back(v);//a
+                v.pop_back();
+
+                v.push_back(qq);
+                onePerm.push_back(v);//q
+                v.pop_back();
+
+                //errs() << "About to make twoPerms\n";
+
+                v.push_back(aa);
+                v.push_back(aa);
+                twoPerms.push_back(v);//aa
+                v.pop_back();
+                v.push_back(qq);
+                twoPerms.push_back(v);//aq
+                v.pop_back();
+                v.pop_back();
+                v.push_back(qq);
+                v.push_back(aa);
+                twoPerms.push_back(v);//qa
+                v.pop_back();
+                v.push_back(qq);
+                twoPerms.push_back(v);//qq
+
+                //errs() << "About to do threePerms\n";
+
+                v.push_back(qq);
+                threePerms.push_back(v);//qqq
+                v.pop_back();
+
+                v.push_back(aa);
+                threePerms.push_back(v);//qqa
+                v.pop_back();
+                v.pop_back();
+
+                v.push_back(aa);
+                v.push_back(aa);
+                threePerms.push_back(v);//qaa
+                v.pop_back();
+
+                v.push_back(qq);
+                threePerms.push_back(v);//qaq
+                v.pop_back();
+                v.pop_back();
+                v.pop_back();
+
+                v.push_back(aa);
+                v.push_back(qq);
+                v.push_back(qq);
+                threePerms.push_back(v);//aqq
+                v.pop_back();
+
+                v.push_back(aa);
+                threePerms.push_back(v);//aqa
+                v.pop_back();
+                v.pop_back();
+
+                v.push_back(aa);
+                v.push_back(aa);
+                threePerms.push_back(v);//aaa
+                v.pop_back();
+
+                v.push_back(qq);
+                threePerms.push_back(v);//aaq
+
+                for(int i=0; i<2; i++){
+                  llvm::ArrayRef<Type*> ar = llvm::makeArrayRef(onePerm[i]);
+
+                  //errs() << "doing one perm getDeclaration for " << i;
+
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::H, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::H, ar);
+
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::MeasX, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::MeasX, ar);
+
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::MeasZ, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::MeasZ, ar);
+
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::PrepX, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::PrepX, ar);
+
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::PrepZ, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::PrepZ, ar);
+                
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::Rx, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::Rx, ar);
+                
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::Ry, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::Ry, ar);
+                
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::Rz, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::Rz, ar);
+                 
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::S, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::Sdag, ar);
+
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::Sdag, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::S, ar);
+
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::T, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::Tdag, ar);
+
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::Tdag, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::T, ar);
+
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::X, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::X, ar);
+
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::Y, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::Y, ar);
+
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::Z, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::Z, ar);
+                }
+
+                //errs() << "2perms getDeclaration\n";
+                
+                for(int i=0; i<4; i++){
+                  llvm::ArrayRef<Type*> ar = llvm::makeArrayRef(twoPerms[i]);
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::CNOT, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::CNOT, ar);
+                }
+                //errs() << "3perms getDeclaration\n";
+                
+                for(int i=0; i<8; i++){
+                  llvm::ArrayRef<Type*> ar = llvm::makeArrayRef(threePerms[i]);
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::Toffoli, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::Toffoli, ar);
+
+                  IntrinsicInverses[Intrinsic::getDeclaration
+                  (M, Intrinsic::Fredkin, ar)] = Intrinsic::getDeclaration
+                  (M, Intrinsic::Fredkin, ar);
+                }
+                
+                //errs() << "store_cbit getDeclaration\n";
+                IntrinsicInverses[M->getFunction("store_cbit")] 
+                = M->getFunction("store_cbit");
+            }
+            // Returns a pointer to the inverse of the specified
+            // function and creates it if it doesn't exist yet
+            Function *GetOrCreateInverseFunction(Function *Func) {
+                if (IntrinsicInverses.count(Func)) {
+                    return IntrinsicInverses[Func];
+                }
+                const std::string ReverseFuncName = 
+                    Func->getName().str() + "_Reverse";
+                Function *ReverseFunc = M->getFunction(ReverseFuncName);
+                // If it doesn't exist yet, create it
+                if (!ReverseFunc) {
+                    ValueMap<const Value*, WeakVH> VMap;
+                    ReverseFunc = CloneFunction
+                       (Func, VMap, false /* ModuleLevelChanges */);
+                    ReverseFunc->setName(ReverseFuncName);
+                    BasicBlock &BB = ReverseFunc->front();
+                    // Finds all of the call instructions 
+                    // in the cloned reverse function
+                    std::vector<CallInst *> V;
+                    BasicBlock::iterator It;
+                    BasicBlock::iterator E = BB.end();
+                    CallInst *CI;
+                    
+                    for (It = BB.begin(); It != E; It++) {
+                        if ( (CI = dyn_cast<CallInst>(&*It)) ) {
+                            V.push_back(CI);
+                        }
+                    }
+                    // Iterates backwards through the list of call 
+                    // instructions, inverts the functions call by the 
+                    // instructions and moves them to the end of the 
+                    // reversed function
+                    std::vector<CallInst *>::reverse_iterator I;
+                    Function *Inverse;
+                    std::vector<CallInst *>::reverse_iterator F = V.rend();
+                    for (I = V.rbegin(); I != F; I++) {
+                        Inverse = GetOrCreateInverseFunction
+                            ((*I)->getCalledFunction());
+                        (*I)->setCalledFunction(Inverse);
+                        (*I)->removeFromParent();
+                        BB.getInstList().insert(&BB.back(), *I);
+                    }
+                    M->getFunctionList().push_back(ReverseFunc);
+                }
+                return ReverseFunc;
+            } // GetOrCreateInverseFunction()
+
+            // Gets called very time the target LLVM IR code  
+            // has a function call
+            // Overrides visitCallInst in the InstVisitor class
+            void visitCallInst(CallInst &I) {
+                // Get the current function
+                Function *CF = I.getCalledFunction();
+                if (CF->getName().startswith(REVERSE_PREFIX)) {
+                    // Stores the number of times a reverse function is 
+                    // prefixed with '_reverse_'; If this number is odd, it 
+                    // it will be replaced by the function's reverse 
+                    // otherwiseit will be replaced by the function itself
+                    int numReverses = 0;
+                    StringRef ForwardFunctionName = CF->getName();
+                    
+                    while(ForwardFunctionName.startswith(REVERSE_PREFIX)){
+                        ForwardFunctionName = ForwardFunctionName.drop_front
+                            (REVERSE_PREFIX.size());
+                        ++numReverses;
+                    }
+                    
+                    Function *ForwardFunction;
+                    // The Toffoli function is special becuase it has 
+                    // been rewritten to have a different function name
+                    if (ForwardFunctionName == "Toffoli")
+                        ForwardFunction = M->getFunction("ToffoliImpl");
+                    else
+                        ForwardFunction = M->getFunction(ForwardFunctionName);
+                    
+                    // If the function name was not found in the current 
+                    // module we can search for it in the intrinsics by 
+                    // prepending "llvm." to it
+                    if (ForwardFunction == NULL) {
+                        const std::string IntrinsicForwardFunctionName 
+                            = "llvm." + ForwardFunctionName.str();
+                        ForwardFunction = M->getFunction
+                            (IntrinsicForwardFunctionName);
+                    }
+
+                    // If no function exists for the base after the 
+                    // _reverse_, print an error message
+                    if (ForwardFunction == NULL) {
+                        errs() << 
+                        "Error: Could not invert non-existent function " 
+                        << ForwardFunctionName << "\n";
+                    }
+                    // If a function exists, but different arguments are 
+                    // supplied to the call site than the type of the 
+                    // function, print an error message
+                    else if (CF->getFunctionType() != ForwardFunction->
+                        getFunctionType()) {
+                        errs() << "Error: reversed function " << CF->getName()
+                               << " did not match type of foward function " 
+                               << ForwardFunctionName << "\n";
+                    }
+
+                    Function *ReplacementFunction = numReverses % 2 == 1 ? 
+                        GetOrCreateInverseFunction(ForwardFunction) 
+                        : ForwardFunction;
+                    // Now that we have the replacement function, this 
+                    // performs the insertion into the target code
+                    const FunctionType *FuncType = ReplacementFunction
+                        ->getFunctionType();
+                    std::vector<Value*> Args(FuncType->getNumParams());
+                    unsigned i;
+                    for (i=0; i<FuncType->getNumParams(); i++) {
+                        Args[i] = I.getArgOperand(i);
+                    }
+                    CallInst::Create(ReplacementFunction, 
+                        ArrayRef<Value*>(Args), "", &I);
+                    I.eraseFromParent();
+                }
+            } // visitCallInst()
+        }; // struct InsertReverseFunctionsVisitor
+
+
+        virtual bool runOnModule(Module &M) {
+                InsertReverseFunctionsVisitor IRFV(&M);
+                IRFV.visit(M);
+
+                return true;
+            } // runOnModule()
+
+    }; // struct FunctionReverse
+} // namespace
+
+char FunctionReverse::ID = 0;
+const std::string FunctionReverse::REVERSE_PREFIX = "_reverse_";
+static RegisterPass<FunctionReverse> X("FunctionReverse", 
+    "Function Reverser", false, false);
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/Rotations.cpp llvm/lib/Transforms/Scaffold/Rotations.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/Rotations.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/Rotations.cpp	2017-10-12 11:09:31.094119615 +0800
@@ -0,0 +1,226 @@
+// Scaffold
+// This pass stops at Rz gates in the call graphs and decomposes them into
+// sequences of clifford+T gates
+//
+
+#include <cstdlib>
+#include <cstdio>
+#include <sstream>
+#include <string>
+
+#include "llvm/ADT/ArrayRef.h"
+
+#include "llvm/Constants.h"
+#include "llvm/Function.h"
+#include "llvm/Instructions.h"
+#include "llvm/Intrinsics.h"
+#include "llvm/LLVMContext.h"
+#include "llvm/Pass.h"
+
+#include "llvm/Support/CallSite.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/InstVisitor.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/CommandLine.h"
+
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+
+using namespace llvm;
+
+static cl::opt<unsigned>
+SqctLevels("sqct-levels", cl::init(1), cl::Hidden,
+  cl::desc("The rotation decomposition precision"));
+
+
+namespace {
+	// We need to use a ModulePass in order to create new Functions
+	struct Rotations : public ModulePass {
+		static char ID;
+		Rotations() : ModulePass(ID) {}
+
+		struct RotationVisitor : public InstVisitor<RotationVisitor> {
+			// All decompositions will be created as Functions in M's FunctionList
+			Module *M;
+			// The constructor is called once per module (in runOnModule)
+			RotationVisitor(Module *module) : M(module) {}
+
+			// private:
+			std::string exec(const char* cmd) {
+				FILE* pipe = popen(cmd, "r");
+				if (!pipe) return "ERROR";
+				char buffer[128];
+				std::string result = "";
+				while(!feof(pipe)) {
+					if (fgets(buffer, 128, pipe) != NULL)
+						result += buffer;
+				}
+				pclose(pipe);
+				return result;
+			} // exec()
+			// public: 
+			void visitCallInst(CallInst &I) {
+				// Determine whether this is an Rz gate
+				Function *CF = I.getCalledFunction();
+				// Is this an intrinsic?
+				if (!CF->isIntrinsic()) return;
+				// If it is a rotation, what is the axis?
+				std::string axis;
+				switch (CF->getIntrinsicID()) {
+					case Intrinsic::Rz:
+						axis = std::string(" Z ");
+						break;
+					case Intrinsic::Rx:
+						axis = std::string(" X ");
+						break;
+					case Intrinsic::Ry:
+						axis = std::string(" Y ");
+						break;
+					default:
+						return;
+				}
+				// Detemine whether we know the rotation angle
+				if (!isa<ConstantFP>(I.getArgOperand(1))) {
+					errs() << "Unknown rotation angle\n";
+					return;
+				}
+				// Extract the target qubit from the CallInst
+				// Using CallSite
+				// CallSite CS(&I);
+				// Value *Target = CS.getArgument(0);
+				// errs() << *Target << "\n";
+				// END CallSite
+				Value *Target = I.getArgOperand(0);
+				// Extract the rotation angle from the CallInst
+				double Angle = cast<ConstantFP>(I.getArgOperand(1))
+					->getValueAPF()
+					.convertToDouble();
+				// If the angle is 0, delete the rotation
+				if ( Angle == 0.0 || Angle == -0.0 ) {
+					errs() << "Rotation angle is " << Angle << " for " << Target->getName() << "\n";
+					I.eraseFromParent();
+					return;
+				}
+				// Create a unique function name (for lookup later)
+				std::string buf; raw_string_ostream ss(buf);
+				ss << "DecomposeRotation_" << Angle;
+				std::string FuncName = ss.str();
+				// Sanitize strings
+				for (std::string::iterator iter = FuncName.begin(); iter < FuncName.end(); iter++) {
+					switch (*iter) {
+						case '-': FuncName.replace(iter,iter+1,"n"); break;
+						case '+': FuncName.erase(iter); iter--; break;
+						case '.': FuncName.replace(iter,iter+1,"_"); break;
+						case '"': FuncName.erase(iter); iter--; break;
+					}
+				}
+				// Create a FunctionType object with 'void' return type and one 'qbit'
+				// parameter
+				FunctionType *FuncType = FunctionType::get(
+					Type::getVoidTy(getGlobalContext()),
+					ArrayRef<Type*>(Type::getInt16Ty(getGlobalContext())),
+					false);
+				// Lookup the Function in the module
+				Function *DR = M->getFunction(FuncName);
+				// If it does not exist perform a decomposition
+				if (!DR) {
+					// Create the new function
+					DR = Function::Create(FuncType, GlobalVariable::ExternalLinkage,
+						FuncName, M);
+
+					Function::arg_iterator args = DR->arg_begin(); //set name of variable
+					Value* qArg = args;
+					qArg->setName("q");
+
+					// Create a BasicBlock and insert it at the end of the Function
+					BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "", DR, 0);
+					// Populate the BasicBlock
+					// Build rotation decomposition command
+					std::string buf; std::ostringstream ss2;
+					char *path = getenv("ROTATIONPATH");
+					if (!path) {
+						errs() << "Rotation decomposer not found!\n";
+						return;
+					}          
+          char *prec = getenv("PRECISION");
+          if (std::string(path).find("gridsynth") != std::string::npos) {
+    			  ss2 << path << " \"(" << std::fixed << Angle << ")\"" << " -d " << prec;          
+          }
+          else if (std::string(path).find("sqct") != std::string::npos) {
+            ss2 << path << " " << Angle << axis << SqctLevels;
+          }
+          else {
+            errs() << "Invalid rotation decomposer!\n";
+            return;
+          }
+          
+          buf = ss2.str();
+          raw_string_ostream ss3(buf);          
+					errs() << "Calling '" << ss3.str() << "'\n";
+					// Capture result
+          // if basic rotation angle, do not decompose
+          //if (Angle == 3.14 || Angle == 1.57 || Angle == 0) 
+					std::string circuit = exec(ss3.str().c_str());
+
+					// For each gate in decomposition:
+          // (the decomposed string is given in the reverse order that ops must be applied)
+					for (int i=circuit.length()-2; i>=0; i--) {
+						Function *gate = NULL;
+						switch(circuit[i]) {
+							case 'T':
+								gate = Intrinsic::getDeclaration(M, Intrinsic::T, makeArrayRef(Target->getType()));
+								break;
+							case 't':
+								gate = Intrinsic::getDeclaration(M, Intrinsic::Tdag, makeArrayRef(Target->getType()));
+								break;
+							case 'S':
+								gate = Intrinsic::getDeclaration(M, Intrinsic::S, makeArrayRef(Target->getType()));
+								break;
+							case 's':
+								gate = Intrinsic::getDeclaration(M, Intrinsic::Sdag, makeArrayRef(Target->getType()));
+								break;
+							case 'H':
+								gate = Intrinsic::getDeclaration(M, Intrinsic::H, makeArrayRef(Target->getType()));
+								break;
+							case 'X':
+								gate = Intrinsic::getDeclaration(M, Intrinsic::X, makeArrayRef(Target->getType()));
+								break;
+							case 'Y':
+								gate = Intrinsic::getDeclaration(M, Intrinsic::Y, makeArrayRef(Target->getType()));
+								break;
+							case 'Z':
+								gate = Intrinsic::getDeclaration(M, Intrinsic::Z, makeArrayRef(Target->getType()));
+								break;
+							default:
+								continue;
+						}
+						CallInst *newCallInst;
+						newCallInst = CallInst::Create(gate, ArrayRef<Value*>(DR->arg_begin()),
+								// Insert at front
+								// "", BB->front());
+								// Insert at end
+								"", BB);
+						//newCallInst->setTailCall();
+					}
+					ReturnInst::Create(getGlobalContext(), 0, BB);
+				} // endif 'decomposition not found'
+				// Replace the old Rz call with the new call to Decomposed_Rotation
+				BasicBlock::iterator ii(&I);
+				ReplaceInstWithInst(I.getParent()->getInstList(), ii,
+					CallInst::Create(DR, ArrayRef<Value*>(Target)));
+				// } // endif 'found Rz'
+			} // visitCallInst()
+
+		}; // struct RotationVisitor
+
+		virtual bool runOnModule(Module &M) {
+			RotationVisitor RV(&M);
+			RV.visit(M);
+
+			return true;
+		} // runOnModule()
+		
+	}; // struct Rotations
+} // namespace
+
+char Rotations::ID = 0;
+static RegisterPass<Rotations> X("Rotations", "Rotation Decomposition", false, false);
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/RuntimeFrequencyEstimationHybrid.cpp llvm/lib/Transforms/Scaffold/RuntimeFrequencyEstimationHybrid.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/RuntimeFrequencyEstimationHybrid.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/RuntimeFrequencyEstimationHybrid.cpp	2017-10-12 11:09:31.094119615 +0800
@@ -0,0 +1,357 @@
+//===------------------ RuntimeResourceEst-Memoized.cpp  ------------------===//
+//
+//                     The LLVM Scaffold Compiler Infrastructure
+//
+// This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#include <sstream>
+#include <iomanip>
+#include "llvm/Pass.h"
+#include "llvm/Module.h"
+#include "llvm/Function.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Constants.h"
+#include "llvm/Intrinsics.h"
+#include "llvm/Support/InstVisitor.h" 
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/LLVMContext.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+
+using namespace llvm;
+using namespace std;
+
+#define _MAX_FUNCTION_NAME 90
+#define _MAX_INT_PARAMS 4
+#define _MAX_DOUBLE_PARAMS 4
+
+#define _X 0
+#define _Z 1
+#define _H 2
+#define _T 3
+#define _Tdag 4
+#define _S 5
+#define _Sdag 6
+#define _CNOT 7
+#define _PrepZ 8
+#define _MeasZ 9
+#define _PrepX 10
+#define _MeasX 11
+#define _Fredkin 12
+#define _Toffoli 13
+#define _Rz 14
+
+bool debugRTFreqEstHyb = false;
+
+
+namespace {
+
+  vector<Instruction*> vInstRemove;
+
+  struct RTFreqEstHyb : public ModulePass {
+
+    static char ID;  // Pass identification, replacement for typeid
+
+    //external instrumentation function
+    Function* qasmGate; 
+    Function* qasmResSum; 
+    Function* memoize; 
+    Function* qasmInitialize; 
+    Function* exit_scope;
+
+    //uint32_t rep_val;
+    Value* rep_val;
+
+    RTFreqEstHyb() : ModulePass(ID) {  }
+
+    void visitCallInst (BasicBlock::iterator I, AllocaInst* strAlloc, AllocaInst* intArrAlloc, AllocaInst* doubleArrAlloc) {
+      CallInst *CI = dyn_cast<CallInst>(&*I);
+
+      Function* CF = CI->getCalledFunction();
+
+      if(debugRTFreqEstHyb)
+        errs() << "\tCalls: " << CF->getName() << "\n";
+
+      int gateIndex = 0;
+      bool isIntrinsicQuantum = true;
+      bool delAfterInst = true; // do not delete Meas gates because it will invalidate cbit stores
+
+      bool isQuantumModuleCall = false;
+
+      // is this a call to a quantum module? Only those should be instrumented
+      // quantum modules arguments are either qbit or qbit* type
+      for(unsigned iop=0;iop < CI->getNumArgOperands(); iop++) {
+        if (CI->getArgOperand(iop)->getType()->isPointerTy())
+          if(CI->getArgOperand(iop)->getType()->getPointerElementType()->isIntegerTy(16))
+            isQuantumModuleCall = true;
+        if (CI->getArgOperand(iop)->getType()->isIntegerTy(16))
+          isQuantumModuleCall = true;
+      }
+      
+      if(CF->getName().find("store_cbit") != std::string::npos)
+        vInstRemove.push_back((Instruction*)CI);
+      
+      if(CF->isIntrinsic()) {
+        if(CF->getIntrinsicID() == Intrinsic::CNOT) gateIndex = _CNOT;
+        else if(CF->getIntrinsicID() == Intrinsic::Fredkin) gateIndex = _Fredkin;
+        else if(CF->getIntrinsicID() == Intrinsic::H) gateIndex = _H;
+        else if(CF->getIntrinsicID() == Intrinsic::MeasX) { gateIndex = _MeasX; delAfterInst = false; }
+        else if(CF->getIntrinsicID() == Intrinsic::MeasZ) { gateIndex = _MeasZ; delAfterInst = false; }
+        else if(CF->getIntrinsicID() == Intrinsic::PrepX) gateIndex = _PrepX;
+        else if(CF->getIntrinsicID() == Intrinsic::PrepZ) gateIndex = _PrepZ;
+        else if(CF->getIntrinsicID() == Intrinsic::Rz) gateIndex = _Rz;
+        else if(CF->getIntrinsicID() == Intrinsic::S) gateIndex = _S;
+        else if(CF->getIntrinsicID() == Intrinsic::T) gateIndex = _T;
+        else if(CF->getIntrinsicID() == Intrinsic::Sdag) gateIndex = _Sdag;
+        else if(CF->getIntrinsicID() == Intrinsic::Tdag) gateIndex = _Tdag;
+        else if(CF->getIntrinsicID() == Intrinsic::Toffoli) gateIndex = _Toffoli;
+        else if(CF->getIntrinsicID() == Intrinsic::X) gateIndex = _X;
+        else if(CF->getIntrinsicID() == Intrinsic::Z) gateIndex = _Z;
+        else { isIntrinsicQuantum = false; delAfterInst = false; }
+        if (isIntrinsicQuantum) {
+          vector <Value*> vectCallArgs;
+
+          Constant* gateID = ConstantInt::get(Type::getInt32Ty(getGlobalContext()), gateIndex, false);	
+          //Constant* RepeatConstant = ConstantInt::get(Type::getInt32Ty(getGlobalContext()) , rep_val, false);
+          
+          vectCallArgs.push_back(gateID);
+          //vectCallArgs.push_back(RepeatConstant);
+          vectCallArgs.push_back(rep_val);       
+          
+          ArrayRef<Value*> call_args(vectCallArgs);  
+          
+          //CallInst::Create(qasmGate, "", (Instruction*)CI);
+          
+          if(delAfterInst)
+            vInstRemove.push_back((Instruction*)CI);
+
+        }
+      }
+      
+      else if (!CF->isDeclaration() && isQuantumModuleCall){
+        // insert memoize call before this function call
+        // int memoize ( char *function_name, int *int_params, unsigned num_ints, double *double_params, unsigned num_doubles, unsigned repeat)          
+        
+        vector <Value*> vectCallArgs;
+        
+        std::stringstream ss;
+        ss << std::left << std::setw (_MAX_FUNCTION_NAME-1) << std::setfill(' ') << CF->getName().str();
+        Constant *StrConstant = ConstantDataArray::getString(CI->getContext(), ss.str());                   
+        
+        new StoreInst(StrConstant,strAlloc,"",(Instruction*)CI);	  	  
+        Value* Idx[2];	  
+        Idx[0] = Constant::getNullValue(Type::getInt32Ty(CI->getContext()));  
+        Idx[1] = ConstantInt::get(Type::getInt32Ty(CI->getContext()),0);
+        GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", (Instruction*)CI);
+        
+        Value *intArgPtr;
+        vector<Value*> vIntArgs;
+        unsigned num_ints = 0;
+        Value *doubleArgPtr;
+        vector<Value*> vDoubleArgs;
+        unsigned num_doubles = 0;
+
+        for(unsigned iop=0; iop < CI->getNumArgOperands(); iop++) {
+          Value *callArg = CI->getArgOperand(iop);
+          // Integer Arguments
+          if(ConstantInt *CInt = dyn_cast<ConstantInt>(callArg)){
+            intArgPtr = CInt;
+            num_ints++;
+            vIntArgs.push_back(intArgPtr);          
+          }
+          else if (callArg->getType() == Type::getInt32Ty(CI->getContext())){ //FIXME: make sure it's an integer
+            intArgPtr = CastInst::CreateIntegerCast(callArg, Type::getInt32Ty(CI->getContext()), false, "", (Instruction*)CI);
+            num_ints++;
+            vIntArgs.push_back(intArgPtr);          
+          }
+
+          // Double Arguments
+          if(ConstantFP *CDouble = dyn_cast<ConstantFP>(CI->getArgOperand(iop))){ 
+            doubleArgPtr = CDouble;
+            vDoubleArgs.push_back(doubleArgPtr);          
+            num_doubles++;
+          }
+          else if (callArg->getType() == Type::getDoubleTy(CI->getContext())){ //FIXME: make sure it's an integer
+            doubleArgPtr = CastInst::CreateFPCast(callArg, Type::getDoubleTy(CI->getContext()), "", (Instruction*)CI);          
+            num_doubles++;
+            vDoubleArgs.push_back(doubleArgPtr);          
+          }
+        }
+        
+        for (unsigned i=0; i<num_ints; i++) {
+          Value *Int = vIntArgs[i];        
+          Idx[1] = ConstantInt::get(Type::getInt32Ty(CI->getContext()),i);        
+          Value *intPtr = GetElementPtrInst::CreateInBounds(intArrAlloc, Idx, "", (Instruction*)CI);        
+          new StoreInst(Int, intPtr, "", (Instruction*)CI);
+        }
+        Idx[1] = ConstantInt::get(Type::getInt32Ty(CI->getContext()),0);        
+        GetElementPtrInst* intArrPtr = GetElementPtrInst::CreateInBounds(intArrAlloc, Idx, "", (Instruction*)CI);
+
+        for (unsigned i=0; i<num_doubles; i++) {
+          Value *Double = vDoubleArgs[i];     
+          Idx[1] = ConstantInt::get(Type::getInt32Ty(CI->getContext()),i);        
+          Value *doublePtr = GetElementPtrInst::CreateInBounds(doubleArrAlloc, Idx, "", (Instruction*)CI);        
+          new StoreInst(Double, doublePtr, "", (Instruction*)CI);          
+        }
+        GetElementPtrInst* doubleArrPtr = GetElementPtrInst::CreateInBounds(doubleArrAlloc, Idx, "", (Instruction*)CI);
+
+        Constant *IntNumConstant = ConstantInt::get(Type::getInt32Ty(getGlobalContext()) , num_ints, false);       
+        Constant *DoubleNumConstant = ConstantInt::get(Type::getInt32Ty(getGlobalContext()) , num_doubles, false);          
+
+        //Constant *RepeatConstant = ConstantInt::get(Type::getInt32Ty(getGlobalContext()) , rep_val, false);
+
+        vectCallArgs.push_back(cast<Value>(strPtr));
+        vectCallArgs.push_back(cast<Value>(intArrPtr));
+        vectCallArgs.push_back(IntNumConstant);          
+        vectCallArgs.push_back(cast<Value>(doubleArrPtr));
+        vectCallArgs.push_back(DoubleNumConstant);          
+        //vectCallArgs.push_back(RepeatConstant);       
+        vectCallArgs.push_back(rep_val);       
+
+        ArrayRef<Value*> call_args(vectCallArgs);  
+        
+        CallInst::Create(memoize, call_args, "", (Instruction*)CI);      
+
+        //CallInst::Create(memoize, getMemoizeArgs(CI, strAlloc, intArrAlloc, doubleArrAlloc), "", (Instruction*)CI);
+        
+        //vector <Value*> vectCallArgs2;              
+        //vectCallArgs2.push_back(rep_val);       
+        //ArrayRef<Value*> call_args2(vectCallArgs2);   
+
+        CallInst::Create(exit_scope, "", (&*++I));
+        
+        isIntrinsicQuantum = false;
+        delAfterInst = false;
+      }
+
+      else if (CF->getName().find("qasmRepLoopStart") != string::npos) {
+        rep_val = CI->getArgOperand(0);
+        vInstRemove.push_back((Instruction*)CI);
+      }
+      
+      else if (CF->getName().find("qasmRepLoopEnd") != string::npos) {
+        rep_val = ConstantInt::get(Type::getInt32Ty(getGlobalContext()), 1, false);
+        vInstRemove.push_back((Instruction*)CI);        
+      }           
+      
+    }
+    
+    void visitFunction(Function &F) {
+      // insert alloca instructions at the beginning for subsequent memoize calls   
+      bool isQuantumModule = false;
+      for(Function::arg_iterator ait=F.arg_begin();ait!=F.arg_end();++ait) {
+        if (ait->getType()->isPointerTy())
+          if(ait->getType()->getPointerElementType()->isIntegerTy(16))
+            isQuantumModule = true;
+        if (ait->getType()->isIntegerTy(16))
+          isQuantumModule = true;       
+      }
+      if (F.getName() == "main") 
+          isQuantumModule = true;      
+      if(!F.isDeclaration() && isQuantumModule){
+        BasicBlock* BB_first = &(F.front());
+        BasicBlock::iterator BBiter = BB_first->getFirstNonPHI();
+        while(isa<AllocaInst>(BBiter))
+          ++BBiter;
+        Instruction* pInst = &(*BBiter);
+  
+        ArrayType *strTy = ArrayType::get(Type::getInt8Ty(pInst->getContext()), _MAX_FUNCTION_NAME);
+        AllocaInst *strAlloc = new AllocaInst(strTy,"",pInst);
+        
+        ArrayType *intArrTy = ArrayType::get(Type::getInt32Ty(pInst->getContext()), _MAX_INT_PARAMS);
+        AllocaInst *intArrAlloc = new AllocaInst(intArrTy, "", pInst);
+
+        ArrayType *doubleArrTy = ArrayType::get(Type::getDoubleTy(pInst->getContext()), _MAX_DOUBLE_PARAMS);        
+        AllocaInst *doubleArrAlloc = new AllocaInst(doubleArrTy,"",pInst);
+
+        if(debugRTFreqEstHyb)
+          errs() << "Function: " << F.getName() << "\n";
+        for (Function::iterator BB = F.begin(); BB != F.end(); ++BB) {
+          for (BasicBlock::iterator I = (*BB).begin(); I != (*BB).end(); ++I) {
+            if (dyn_cast<CallInst>(&*I))
+              visitCallInst(I, strAlloc, intArrAlloc, doubleArrAlloc);
+          }
+        }
+      }
+    }
+    
+    bool runOnModule(Module &M) {
+      //rep_val = 1;  
+      rep_val = ConstantInt::get(Type::getInt32Ty(getGlobalContext()), 1, false);
+
+      // void exit_scope ()      
+      exit_scope = cast<Function>(M.getOrInsertFunction("exit_scope", Type::getVoidTy(M.getContext()), (Type*)0));
+
+      //void initialize ()
+      qasmInitialize = cast<Function>(M.getOrInsertFunction("qasm_initialize", Type::getVoidTy(M.getContext()), (Type*)0));
+      
+      //void qasm_resource_summary ()
+      qasmResSum = cast<Function>(M.getOrInsertFunction("qasm_resource_summary", Type::getVoidTy(M.getContext()), (Type*)0));
+
+      // void qasmGate ()      
+      qasmGate = cast<Function>(M.getOrInsertFunction("qasm_gate", Type::getVoidTy(M.getContext()), (Type*)0));      
+
+      // int memoize (char*, int*, unsigned, double*, unsigned, unsigned)
+      vector <Type*> vectParamTypes2;
+      vectParamTypes2.push_back(Type::getInt8Ty(M.getContext())->getPointerTo());      
+      vectParamTypes2.push_back(Type::getInt32Ty(M.getContext())->getPointerTo());
+      vectParamTypes2.push_back(Type::getInt32Ty(M.getContext()));
+      vectParamTypes2.push_back(Type::getDoubleTy(M.getContext())->getPointerTo());
+      vectParamTypes2.push_back(Type::getInt32Ty(M.getContext()));
+      vectParamTypes2.push_back(Type::getInt32Ty(M.getContext()));
+      ArrayRef<Type*> Param_Types2(vectParamTypes2);
+      Type* Result_Type2 = Type::getInt32Ty(M.getContext());
+      memoize = cast<Function> (  
+          M.getOrInsertFunction(
+            "memoize",                          /* Name of Function */
+            FunctionType::get(                  /* Type of Function */
+              Result_Type2,                     /* Result */
+              Param_Types2,                     /* Params */
+              false                             /* isVarArg */
+              )
+            )
+          );
+
+      // iterate over instructions to instrument the initialize and exit scope calls
+      // insert alloca instructions at the beginning for subsequent memoize calls         
+      for (Module::iterator F = M.begin(); F != M.end(); ++F) {
+        visitFunction(*F);
+      }      
+
+      // insert initialization and termination functions in "main"
+      Function* F = M.getFunction("main");
+      if(F){
+        BasicBlock* BB_last = &(F->back());
+        TerminatorInst *BBTerm = BB_last->getTerminator();
+        CallInst::Create(qasmResSum, "",(Instruction*)BBTerm);	
+
+        BasicBlock* BB_first = &(F->front());
+        BasicBlock::iterator BBiter = BB_first->getFirstNonPHI();
+        while(isa<AllocaInst>(BBiter))
+          ++BBiter;
+        CallInst::Create(qasmInitialize, "", (Instruction*)&(*BBiter));
+      }
+
+      // removing instructions that were marked for deletion
+      for(vector<Instruction*>::iterator iterInst = vInstRemove.begin(); iterInst != vInstRemove.end(); ++iterInst) {      
+        if (debugRTFreqEstHyb)
+          errs() << "removing call to: " << (dyn_cast<CallInst>(*iterInst))->getCalledFunction()->getName() << "\n";
+        (*iterInst)->eraseFromParent();
+      }
+
+      return true;      
+    }
+    
+    void print(raw_ostream &O, const Module* = 0) const { 
+      errs() << "Ran Runtime Resource Estimator Validator \n";
+    }  
+  };
+}
+
+char RTFreqEstHyb::ID = 0;
+static RegisterPass<RTFreqEstHyb>
+X("runtime-frequency-estimation-hybrid", "Estimate frequency of modules at runtime");
+  
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/RuntimeResourceEst.cpp llvm/lib/Transforms/Scaffold/RuntimeResourceEst.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/RuntimeResourceEst.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/RuntimeResourceEst.cpp	2017-10-12 11:09:31.094119615 +0800
@@ -0,0 +1,172 @@
+//===- QBitDataPath.cpp - Generate datapaths for qubits in code -----------===//
+//
+//                     The LLVM Scaffold Compiler Infrastructure
+//
+// This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#include "llvm/Pass.h"
+#include "llvm/Module.h"
+#include "llvm/Function.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Constants.h"
+#include "llvm/Intrinsics.h"
+#include "llvm/Support/InstVisitor.h" 
+#include "llvm/Support/raw_ostream.h"
+
+using namespace llvm;
+using namespace std;
+
+#define _CNOT 0
+#define _Fredkin 1
+#define _H 2
+#define _MeasX 3
+#define _MeasZ 4
+#define _PrepX 5
+#define _PrepZ 6
+#define _S 7
+#define _T 8
+#define _Sdag 9
+#define _Tdag 10
+#define _Toffoli 11
+#define _X 12
+#define _Y 13
+#define _Z 14
+#define _Rz 15
+
+bool debugRTResourceEst = false;
+
+namespace {
+
+  vector<Instruction*> vInstRemove;
+
+  struct RTResourceEst : public ModulePass, public InstVisitor<RTResourceEst> {
+    friend class InstVisitor<RTResourceEst>;
+
+    static char ID;  // Pass identification, replacement for typeid
+
+    Function* qasmGate; //external instrumentation function
+    Function* qasmQbitDecl; //external instrumentation function    
+    Function* qasmCbitDecl; //external instrumentation function    
+    Function* qasmResSum; //external instrumentation function    
+
+    RTResourceEst() : ModulePass(ID) {  }
+
+    void instrumentInst(Function* F,Instruction* pInst, int intParam, bool isCall){
+      SmallVector<Value*,16> call_args;
+      Value* intArg = ConstantInt::get(Type::getInt32Ty(pInst->getContext()),intParam);	
+      call_args.push_back(intArg);
+
+      CallInst::Create(F, call_args,"",(Instruction*)pInst);
+
+      if(isCall)
+	vInstRemove.push_back(pInst);
+    }
+    
+    void visitCallInst(CallInst &I) {
+      CallInst *CI = dyn_cast<CallInst>(&I);
+
+      Function* CF = CI->getCalledFunction();
+
+      int gateIndex = 14;
+      bool isIntrinsicQuantum = true;
+
+      bool delAfterInst = true;
+
+      if(CF->isIntrinsic()){
+	  if(CF->getIntrinsicID() == Intrinsic::CNOT) gateIndex = _CNOT;
+	  else if(CF->getIntrinsicID() == Intrinsic::Fredkin) gateIndex = _Fredkin;
+	  else if(CF->getIntrinsicID() == Intrinsic::H) gateIndex = _H;
+	  else if(CF->getIntrinsicID() == Intrinsic::MeasX) { gateIndex = _MeasX; delAfterInst = false; }
+	  else if(CF->getIntrinsicID() == Intrinsic::MeasZ) { gateIndex = _MeasZ; delAfterInst = false; }
+	  else if(CF->getIntrinsicID() == Intrinsic::PrepX) gateIndex = _PrepX;
+	  else if(CF->getIntrinsicID() == Intrinsic::PrepZ) gateIndex = _PrepZ;
+	  else if(CF->getIntrinsicID() == Intrinsic::Rz) gateIndex = _Rz;
+	  else if(CF->getIntrinsicID() == Intrinsic::S) gateIndex = _S;
+	  else if(CF->getIntrinsicID() == Intrinsic::T) gateIndex = _T;
+	  else if(CF->getIntrinsicID() == Intrinsic::Sdag) gateIndex = _Sdag;
+	  else if(CF->getIntrinsicID() == Intrinsic::Tdag) gateIndex = _Tdag;
+	  else if(CF->getIntrinsicID() == Intrinsic::Toffoli) gateIndex = _Toffoli;
+	  else if(CF->getIntrinsicID() == Intrinsic::X) gateIndex = _X;
+	  else if(CF->getIntrinsicID() == Intrinsic::Y) gateIndex = _Y;
+	  else if(CF->getIntrinsicID() == Intrinsic::Z) gateIndex = _Z;
+	  else { isIntrinsicQuantum = false; delAfterInst = false; }
+      }
+      else{
+	isIntrinsicQuantum = false;
+	delAfterInst = false;
+      }
+      
+      if(isIntrinsicQuantum)
+	instrumentInst(qasmGate,CI,gateIndex,delAfterInst);
+      
+    }
+    
+    void visitAllocaInst(AllocaInst &I) {
+      AllocaInst *AI = dyn_cast<AllocaInst>(&I);
+	
+      Type *allocatedType = AI->getAllocatedType();
+	
+      if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+	
+	Type *elementType = arrayType->getElementType();
+	uint64_t arraySize = arrayType->getNumElements();
+	if (elementType->isIntegerTy(16)){
+	  if(debugRTResourceEst)
+	    errs() << "New QBit Allocation Found: " << AI->getName() <<"\n";
+	  
+	  //instrumentation
+	  instrumentInst(qasmQbitDecl,AI,arraySize,false);
+	  }
+	  
+	if (elementType->isIntegerTy(1)){
+	  if(debugRTResourceEst)
+	    errs() << "New CBit Allocation Found: " << AI->getName() <<"\n";
+	  
+	  //instrumentation
+	  instrumentInst(qasmCbitDecl,AI,arraySize,false);
+	}
+      }
+    } // visitAllocaInst
+    
+    void visitFunction(Function &F){
+      if(F.getName() == "main"){
+	BasicBlock* BB = &F.back();
+	TerminatorInst *BBTerm = BB->getTerminator();
+	CallInst::Create(qasmResSum, "",(Instruction*)BBTerm);	
+      }
+    }
+    
+    bool runOnModule(Module &M){
+      qasmGate = cast<Function>(M.getOrInsertFunction("qasm_gate", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), (Type*)0));
+      
+      qasmQbitDecl = cast<Function>(M.getOrInsertFunction("qasm_qbit_decl", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), (Type*)0));
+      
+      qasmCbitDecl = cast<Function>(M.getOrInsertFunction("qasm_cbit_decl", Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), (Type*)0));
+      
+      qasmResSum = cast<Function>(M.getOrInsertFunction("qasm_resource_summary", Type::getVoidTy(M.getContext()), (Type*)0));
+            
+      visit(M);
+
+
+      //errs() << "Removing instructions:\n";
+      for(vector<Instruction*>::iterator iterInst = vInstRemove.begin(); iterInst != vInstRemove.end(); ++iterInst){
+	//errs() << *(*iterInst) << "\n";
+	(*iterInst)->eraseFromParent();
+      }     
+      
+      return true;      
+    }
+    
+    void print(raw_ostream &O, const Module* = 0) const { 
+      errs() << "Ran Runtime Resource Estimator Validator \n";
+    }  
+  };
+}
+
+char RTResourceEst::ID = 0;
+static RegisterPass<RTResourceEst>
+X("runtime-resource-estimation", "Estimate qbits and qgates at runtime");
+  
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/RuntimeResourceEst-Memoized.cpp llvm/lib/Transforms/Scaffold/RuntimeResourceEst-Memoized.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/RuntimeResourceEst-Memoized.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/RuntimeResourceEst-Memoized.cpp	2017-10-12 11:09:31.094119615 +0800
@@ -0,0 +1,383 @@
+//===------------------ RuntimeResourceEst-Memoized.cpp  ------------------===//
+//
+//                     The LLVM Scaffold Compiler Infrastructure
+//
+// This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#include "llvm/Pass.h"
+#include "llvm/Module.h"
+#include "llvm/Function.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Constants.h"
+#include "llvm/Intrinsics.h"
+#include "llvm/Support/InstVisitor.h" 
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/LLVMContext.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+
+using namespace llvm;
+using namespace std;
+
+#define _X 0
+#define _Z 1
+#define _H 2
+#define _T 3
+#define _Tdag 4
+#define _S 5
+#define _Sdag 6
+#define _CNOT 7
+#define _PrepZ 8
+#define _MeasZ 9
+#define _PrepX 10
+#define _MeasX 11
+#define _Fredkin 12
+#define _Toffoli 13
+#define _Rz 14
+
+bool debugMemoInstrumentation = false;
+
+
+namespace {
+
+  vector<Instruction*> vInstRemove;
+
+  vector<BasicBlock::iterator> vectSplitInsts;
+
+  vector<BasicBlock::iterator> vectSplitInsts2;  
+
+  vector<BranchInst*> vBranchReplace;
+
+  struct RTResourceEst_Mem : public ModulePass {
+
+    static char ID;  // Pass identification, replacement for typeid
+
+    //external instrumentation function
+    Function* qasmGate; 
+    Function* qasmQbitDecl; 
+    Function* qasmCbitDecl; 
+    Function* qasmResSum; 
+    Function* memoize; 
+    Function* qasmInitialize; 
+    Function* exit_scope;
+
+    RTResourceEst_Mem() : ModulePass(ID) {  }
+
+    void instrumentInst(Function* F, Instruction* pInst, int intParam, bool toDel){
+      SmallVector<Value*,16> call_args;
+      Value* intArg = ConstantInt::get(Type::getInt32Ty(pInst->getContext()),intParam);	
+      call_args.push_back(intArg);
+
+      CallInst::Create(F, call_args, "", (Instruction*)pInst);
+
+      if(toDel)
+	      vInstRemove.push_back(pInst);
+    }
+    
+
+    void visitCallInst (BasicBlock::iterator I) {
+      CallInst *CI = dyn_cast<CallInst>(&*I);
+
+      Function* CF = CI->getCalledFunction();
+
+      int gateIndex = 0;
+      bool isIntrinsicQuantum = true;
+      bool delAfterInst = true; // do not delete Meas gates because it will invalidate cbit stores
+
+      bool isQuantumModuleCall = false;
+
+      // is this a call to a quantum module? Only those should be instrumented
+      // quantum modules arguments are either qbit or qbit* type
+      for(unsigned iop=0;iop < CI->getNumArgOperands(); iop++) {
+        if (CI->getArgOperand(iop)->getType()->isPointerTy())
+          if(CI->getArgOperand(iop)->getType()->getPointerElementType()->isIntegerTy(16))
+            isQuantumModuleCall = true;
+        if (CI->getArgOperand(iop)->getType()->isIntegerTy(16))
+          isQuantumModuleCall = true;
+      }
+      
+      if(CF->isIntrinsic()) {
+        if(CF->getIntrinsicID() == Intrinsic::CNOT) gateIndex = _CNOT;
+        else if(CF->getIntrinsicID() == Intrinsic::Fredkin) gateIndex = _Fredkin;
+        else if(CF->getIntrinsicID() == Intrinsic::H) gateIndex = _H;
+        else if(CF->getIntrinsicID() == Intrinsic::MeasX) { gateIndex = _MeasX; delAfterInst = false; }
+        else if(CF->getIntrinsicID() == Intrinsic::MeasZ) { gateIndex = _MeasZ; delAfterInst = false; }
+        else if(CF->getIntrinsicID() == Intrinsic::PrepX) gateIndex = _PrepX;
+        else if(CF->getIntrinsicID() == Intrinsic::PrepZ) gateIndex = _PrepZ;
+        else if(CF->getIntrinsicID() == Intrinsic::Rz) gateIndex = _Rz;
+        else if(CF->getIntrinsicID() == Intrinsic::S) gateIndex = _S;
+        else if(CF->getIntrinsicID() == Intrinsic::T) gateIndex = _T;
+        else if(CF->getIntrinsicID() == Intrinsic::Sdag) gateIndex = _Sdag;
+        else if(CF->getIntrinsicID() == Intrinsic::Tdag) gateIndex = _Tdag;
+        else if(CF->getIntrinsicID() == Intrinsic::Toffoli) gateIndex = _Toffoli;
+        else if(CF->getIntrinsicID() == Intrinsic::X) gateIndex = _X;
+        else if(CF->getIntrinsicID() == Intrinsic::Z) gateIndex = _Z;
+        else { isIntrinsicQuantum = false; delAfterInst = false; }
+        if (isIntrinsicQuantum)
+          instrumentInst(qasmGate,CI,gateIndex,delAfterInst);
+
+      }
+      
+      else if (!CF->isDeclaration() && isQuantumModuleCall){
+        // insert memoize call before this function call
+        // int memoize ( char *function_name, int *int_params, unsigned num_ints, double *double_params, unsigned num_doubles)          
+        vector <Value*> vectCallArgs;
+        
+        Constant *StrConstant = ConstantDataArray::getString(CI->getContext(), CF->getName());           
+        ArrayType* strTy = cast<ArrayType>(StrConstant->getType());
+        AllocaInst* strAlloc = new AllocaInst(strTy,"",(Instruction*)CI);
+        new StoreInst(StrConstant,strAlloc,"",(Instruction*)CI);	  	  
+        Value* Idx[2];	  
+        Idx[0] = Constant::getNullValue(Type::getInt32Ty(CI->getContext()));  
+        Idx[1] = ConstantInt::get(Type::getInt32Ty(CI->getContext()),0);
+        GetElementPtrInst* strPtr = GetElementPtrInst::Create(strAlloc, Idx, "", (Instruction*)CI);
+        
+        vector<uint32_t> valueOfInt;
+        unsigned num_ints = 0;
+        vector<double> valueOfDouble;
+        unsigned num_doubles = 0;
+
+        for(unsigned iop=0;iop < CI->getNumArgOperands(); iop++) {
+          if(ConstantInt *CInt = dyn_cast<ConstantInt>(CI->getArgOperand(iop))){
+            valueOfInt.push_back((uint32_t)CInt->getZExtValue());
+            num_ints++;
+          }
+          if(ConstantFP *CDouble = dyn_cast<ConstantFP>(CI->getArgOperand(iop))){ 
+            valueOfDouble.push_back(CDouble->getValueAPF().convertToDouble());
+            num_doubles++;
+          }
+        }
+
+        Constant *IntArrayConstant = ConstantDataArray::get(CI->getContext(), ArrayRef<uint32_t>(valueOfInt));
+        ArrayType *intArrTy = cast<ArrayType>(IntArrayConstant->getType());
+        AllocaInst *intArrAlloc = new AllocaInst(intArrTy,"",(Instruction*)CI);
+        new StoreInst(IntArrayConstant,intArrAlloc,"",(Instruction*)CI);
+        GetElementPtrInst* intArrPtr = GetElementPtrInst::CreateInBounds(intArrAlloc, Idx, "", (Instruction*)CI);
+
+        Constant *DoubleArrayConstant = ConstantDataArray::get(CI->getContext(), ArrayRef<double>(valueOfDouble));
+        ArrayType *doubleArrTy = cast<ArrayType>(DoubleArrayConstant->getType());
+        AllocaInst *doubleArrAlloc = new AllocaInst(doubleArrTy,"",(Instruction*)CI);
+        new StoreInst(DoubleArrayConstant,doubleArrAlloc,"",(Instruction*)CI);	  	  
+        GetElementPtrInst* doubleArrPtr = GetElementPtrInst::CreateInBounds(doubleArrAlloc, Idx, "", (Instruction*)CI);
+        
+        Constant *IntNumConstant = ConstantInt::get(Type::getInt32Ty(getGlobalContext()) , num_ints, false);       
+        Constant *DoubleNumConstant = ConstantInt::get(Type::getInt32Ty(getGlobalContext()) , num_doubles);          
+
+        vectCallArgs.push_back(cast<Value>(strPtr));
+        vectCallArgs.push_back(cast<Value>(intArrPtr));
+        vectCallArgs.push_back(IntNumConstant);          
+        vectCallArgs.push_back(cast<Value>(doubleArrPtr));
+        vectCallArgs.push_back(DoubleNumConstant);          
+
+        ArrayRef<Value*> call_args(vectCallArgs);   
+
+        CallInst::Create(memoize, call_args, "", (Instruction*)CI);      
+        //instrumentInst(memoize, CI, call_args, false);
+        
+        // mark instruction for split basicblock 
+        vectSplitInsts.push_back(I);
+        vectSplitInsts2.push_back(++I);                    
+        isIntrinsicQuantum = false;
+        delAfterInst = false;
+      }
+      
+    }
+    
+    /*void visitAllocaInst(AllocaInst *AI) {
+	
+      Type *allocatedType = AI->getAllocatedType();
+	
+      if(ArrayType *arrayType = dyn_cast<ArrayType>(allocatedType)) {      
+        
+        Type *elementType = arrayType->getElementType();
+        uint64_t arraySize = arrayType->getNumElements();
+        if (elementType->isIntegerTy(16)){
+            errs() << "New QBit Allocation Found: " << AI->getName() <<"\n";
+          
+          //instrumentation
+          //instrumentInst(qasmQbitDecl,AI,arraySize,false);
+        }
+          
+        if (elementType->isIntegerTy(1)){
+            errs() << "New CBit Allocation Found: " << AI->getName() <<"\n";
+          
+          //instrumentation
+          //instrumentInst(qasmCbitDecl,AI,arraySize,false);
+        }
+      }
+    } // visitAllocaInst/
+    */
+
+    void visitFunction(Function &F) {
+      // insert initialization and termination functions in "main"
+      if(F.getName() == "main"){
+        BasicBlock* BB_last = &(F.back());
+        TerminatorInst *BBTerm = BB_last->getTerminator();
+        CallInst::Create(qasmResSum, "",(Instruction*)BBTerm);	
+
+        BasicBlock* BB_first = &(F.front());
+        BasicBlock::iterator BBiter = BB_first->getFirstNonPHI();
+        while(isa<AllocaInst>(BBiter))
+          ++BBiter;
+        CallInst::Create(qasmInitialize, "", (Instruction*)&(*BBiter));
+        return;
+      }
+
+      // insert exit_scope instruction in other quantum modules for end of scope indication      
+      bool isQuantumModule = false;
+      for(Function::arg_iterator ait=F.arg_begin();ait!=F.arg_end();++ait) {
+        if (ait->getType()->isPointerTy())
+          if(ait->getType()->getPointerElementType()->isIntegerTy(16))
+            isQuantumModule = true;
+        if (ait->getType()->isIntegerTy(16))
+          isQuantumModule = true;        
+      }
+      if(!F.isDeclaration() && isQuantumModule){
+        BasicBlock* BB_last = &(F.back());
+        TerminatorInst *BBTerm = BB_last->getTerminator();
+        CallInst::Create(exit_scope, "",(Instruction*)BBTerm);	
+      }
+    }
+    
+    bool runOnModule(Module &M) {
+      // void qasm_qbit_decl (int)
+      qasmQbitDecl = cast<Function>(M.getOrInsertFunction("qasm_qbit_decl", 
+                                    Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), 
+                                    (Type*)0));
+      
+      // void qasm_cbit_decl (int)
+      qasmCbitDecl = cast<Function>(M.getOrInsertFunction("qasm_cbit_decl", 
+                                    Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), 
+                                    (Type*)0));
+
+      // void exit_scope ()      
+      exit_scope = cast<Function>(M.getOrInsertFunction("exit_scope", Type::getVoidTy(M.getContext()), (Type*)0));
+
+      //void initialize ()
+      qasmInitialize = cast<Function>(M.getOrInsertFunction("qasm_initialize", Type::getVoidTy(M.getContext()), (Type*)0));
+      
+      //void qasm_resource_summary ()
+      qasmResSum = cast<Function>(M.getOrInsertFunction("qasm_resource_summary", Type::getVoidTy(M.getContext()), (Type*)0));
+
+      // void qasmGate (int gate_id)      
+      qasmGate = cast<Function>(M.getOrInsertFunction("qasm_gate", 
+            Type::getVoidTy(M.getContext()), Type::getInt32Ty(M.getContext()), (Type*)0));      
+
+
+      // int memoize (char*, int*, unsigned, double*, unsigned)
+      vector <Type*> vectParamTypes2;
+      vectParamTypes2.push_back(Type::getInt8Ty(M.getContext())->getPointerTo());      
+      vectParamTypes2.push_back(Type::getInt32Ty(M.getContext())->getPointerTo());
+      vectParamTypes2.push_back(Type::getInt32Ty(M.getContext()));
+      vectParamTypes2.push_back(Type::getDoubleTy(M.getContext())->getPointerTo());
+      vectParamTypes2.push_back(Type::getInt32Ty(M.getContext()));
+      ArrayRef<Type*> Param_Types2(vectParamTypes2);
+      Type* Result_Type2 = Type::getInt32Ty(M.getContext());
+      memoize = cast<Function> (  
+          M.getOrInsertFunction(
+            "memoize",                          /* Name of Function */
+            FunctionType::get(                  /* Type of Function */
+              Result_Type2,                     /* Result */
+              Param_Types2,                     /* Params */
+              false                             /* isVarArg */
+              )
+            )
+          );
+      
+      // iterate over instructions to instrument
+      for (Module::iterator F = M.begin(); F != M.end(); ++F) {
+        for (Function::iterator BB = (*F).begin(); BB != (*F).end(); ++BB) {
+          for (BasicBlock::iterator I = (*BB).begin(); I != (*BB).end(); ++I) {
+            if (dyn_cast<CallInst>(&*I))
+              visitCallInst(I); 
+            //else if (AllocaInst *AI = dyn_cast<AllocaInst>(&*I))
+            //  visitAllocaInst(AI);
+          }
+        }
+      }
+       
+
+      // split the if.then part
+      for(vector<BasicBlock::iterator>::iterator v = vectSplitInsts.begin(); v != vectSplitInsts.end(); ++v) {
+        Instruction *pInst = &*(*v);
+        BasicBlock *BB = pInst->getParent();
+        BB->splitBasicBlock(*v, Twine("memoize.if.then"));
+      }
+
+      // split the if.end part
+      for(vector<BasicBlock::iterator>::iterator v = vectSplitInsts2.begin(); v != vectSplitInsts2.end(); ++v) {
+        Instruction *pInst = &*(*v);
+        BasicBlock *BB = pInst->getParent();
+        BB->splitBasicBlock(*v, Twine("memoize.if.end"));
+      }
+
+      // second iteration over instructions -- to change branches to conditional branch
+      for (Module::iterator F = M.begin(); F != M.end(); ++F) {
+        for (Function::iterator BB = (*F).begin(); BB != (*F).end(); ++BB) {
+          for (BasicBlock::iterator I = (*BB).begin(); I != (*BB).end(); ++I) {
+            if (BranchInst *BI = dyn_cast<BranchInst>(&*I)) {
+              if (BI->isUnconditional() && BI->getSuccessor(0)->getName().find("memoize.if.then")!=string::npos) {
+                vBranchReplace.push_back(BI);
+                              }
+            }
+          }
+        }
+        visitFunction(*F); // visit function must happen after Basic Block splittings since it creates
+                          // the "exit_scope()" call for all functions, and they must always be at the end        
+      }
+      
+
+      // removing instructions that were marked for deletion
+      for(vector<Instruction*>::iterator iterInst = vInstRemove.begin(); iterInst != vInstRemove.end(); ++iterInst) {
+        if (debugMemoInstrumentation)
+          errs() << "removing call to: " << (dyn_cast<CallInst>(*iterInst))->getCalledFunction()->getName() << "\n";
+        (*iterInst)->eraseFromParent();
+      }
+
+      // replacing branches ...
+      for(vector<BranchInst*>::iterator iterInst = vBranchReplace.begin(); iterInst != vBranchReplace.end(); ++iterInst) {
+        BranchInst* BI = (*iterInst);
+        if (debugMemoInstrumentation){
+          errs() << "replacing branch: \n";
+          BI->dump();
+        }
+
+        BasicBlock::iterator ii(BI);
+        Instruction *memoizeInstruction = &*(--ii);                              // the call to memoize
+               
+        BasicBlock *currentBlock = BI->getParent();
+        BasicBlock *trueBlock = BI->getSuccessor(0)->getTerminator()->getSuccessor(0);
+        BasicBlock *falseBlock = BI->getSuccessor(0);
+
+        if (debugMemoInstrumentation) {
+          errs() << "current block: " << currentBlock->getName() << "\n";
+          errs() << "true block: " << trueBlock->getName() << "\n";
+          errs() << "false block: " << falseBlock->getName() << "\n";
+        }
+
+        // erasing this currentBlock's unconditional branch instruction
+        currentBlock->getTerminator()->eraseFromParent();
+
+        // inserting ICmpInst at the end of currentBlock
+        ICmpInst *test = new ICmpInst(*currentBlock, CmpInst::ICMP_EQ, 
+            memoizeInstruction, ConstantInt::get(Type::getInt32Ty(M.getContext()), 1), "shadow check");
+                
+        BranchInst::Create (trueBlock, falseBlock, test, currentBlock);
+        
+      }
+      
+      return true;      
+    }
+    
+    void print(raw_ostream &O, const Module* = 0) const { 
+      errs() << "Ran Runtime Resource Estimator Validator \n";
+    }  
+  };
+}
+
+char RTResourceEst_Mem::ID = 0;
+static RegisterPass<RTResourceEst_Mem>
+X("runtime-resource-estimation-memoized", "Estimate qbits and qgates at runtime with memoization");
+  
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/SortCloneArguments.cpp llvm/lib/Transforms/Scaffold/SortCloneArguments.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/SortCloneArguments.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/SortCloneArguments.cpp	2017-10-12 11:09:31.094119615 +0800
@@ -0,0 +1,142 @@
+//===-------------------------- FunctionClone.cpp ------------------------===//
+// This file implements the Scaffold pass of sorting integer/double arguments
+// in functions that have been cloned based on their constant arguments.
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "FunctionClone"
+#include <sstream>
+#include <iostream>
+#include <iomanip>
+#include "llvm/Pass.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/Transforms/Utils/Cloning.h"
+#include "llvm/BasicBlock.h"
+#include "llvm/Instruction.h"
+#include "llvm/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/ScalarEvolution.h"
+#include "llvm/Analysis/ScalarEvolutionExpressions.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+#include "llvm/Support/CallSite.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/ADT/SCCIterator.h"
+
+#define _MAX_FUNCTION_NAME 32
+#define _MAX_INT_PARAMS 4
+#define _MAX_DOUBLE_PARAMS 4
+
+// DEBUG switch
+bool debugSortArgs = false;
+
+using namespace llvm;
+
+// An anonymous namespace for the pass. Things declared inside it are
+// only visible to the current file.
+namespace {
+
+  // Derived from ModulePass to work on callgraph
+  struct SortCloneArguments : public ModulePass {
+    static char ID; // Pass identification
+    SortCloneArguments() : ModulePass(ID) {}
+
+    bool runOnModule (Module &M);
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+        AU.setPreservesAll();  
+        AU.addRequired<CallGraph>();
+    }
+
+  }; // End of struct SortCloneArguments
+} // End of anonymous namespace
+
+
+char SortCloneArguments::ID = 0;
+static RegisterPass<SortCloneArguments> X("SortCloneArguments", "Sorting Arguments of Cloned Function", false, false);
+
+bool SortCloneArguments::runOnModule (Module &M) {
+   
+  for (Module::iterator F = M.begin(); F != M.end(); ++F) {
+    if(F->isIntrinsic() || F->isDeclaration() || F->getName()=="main")
+      continue;
+    //----- Only Modifying Function Names: Therefore the correspondence bewteen name order and
+    //----- argument order breaks, but thats not important
+      
+      std::string originalName = F->getName().str();
+      if (debugSortArgs)
+        errs() << "Function: " << originalName << "\n";
+      std::string::size_type found_pos_begin, found_pos_end, found_pos_begin_new;
+
+      std::vector<int> originalInts;
+      std::vector<double> originalDoubles;
+      
+      // for IntParams
+      found_pos_begin = originalName.find("_IP");
+      while (found_pos_begin != std::string::npos){
+        //because there might be numbers more than 1 digit long, need to find begin and end
+        found_pos_end = originalName.find_first_not_of("0123456789",found_pos_begin+3);
+        std::string intString = originalName.substr(found_pos_begin+3, found_pos_end-(found_pos_begin+3));
+        if (debugSortArgs)
+          errs() << "\tint: " << intString << "\n";
+        originalInts.push_back(atoi(intString.c_str()));
+        //next one
+        found_pos_begin_new = originalName.find("_IP",found_pos_end);  
+        found_pos_begin = found_pos_begin_new;
+      }
+      
+      // for DoubleParams
+      found_pos_begin = originalName.find("_DP");
+      while (found_pos_begin != std::string::npos){
+        //because there might be numbers more than 1 digit long, need to find begin and end
+        found_pos_end = originalName.find_first_not_of("0123456789e.-",found_pos_begin+3);
+        std::string doubleString = originalName.substr(found_pos_begin+3, found_pos_end-(found_pos_begin+3));
+        if (debugSortArgs)
+          errs() << "\tdouble: " << doubleString << "\n";
+        originalDoubles.push_back(atof(doubleString.c_str()));
+        //next one
+        found_pos_begin_new = originalName.find("_DP",found_pos_end);  
+        found_pos_begin = found_pos_begin_new;
+      }
+      
+      // concatanate the rest with zero and then sort
+      for (int i=originalInts.size(); i<_MAX_INT_PARAMS; i++)
+        originalInts.push_back(0);
+      for (int i=originalDoubles.size(); i<_MAX_DOUBLE_PARAMS; i++)
+        originalDoubles.push_back(0);      
+
+      std::sort(originalInts.begin(), originalInts.end());
+      std::sort(originalDoubles.begin(), originalDoubles.end());      
+
+      // what's the name without all the parameters?
+      std::string::size_type originalCoreEnd;
+      originalCoreEnd = originalName.find(std::string("_IP"));
+      if (originalCoreEnd == std::string::npos) // maybe it's all doubles?
+        originalCoreEnd = originalName.find(std::string("_DP"));        
+      std::string originalCore = originalName.substr(0, originalCoreEnd);
+      if(debugSortArgs)
+        errs() << "\toriginalCore: " << originalCore << "\n";
+
+      // construct the new clone name with ordered parameters
+      std::stringstream ss;
+      for (std::vector<int>::iterator i = originalInts.begin(), e = originalInts.end(); i!=e; ++i)
+        ss << "_IP" << *i;
+      //for (std::vector<double>::iterator i = originalDoubles.begin(), e = originalDoubles.end(); i!=e; ++i)
+      //  ss << "_DP" << std::fixed << *i;
+      
+      std::string specializedName = originalCore + ss.str();
+      if(debugSortArgs)
+        errs() << "\tspecializedName: " << specializedName << "\n";
+      
+      F->setName(specializedName);
+  }
+  return true;
+}
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/Toffoli.cpp llvm/lib/Transforms/Scaffold/Toffoli.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/Toffoli.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/Toffoli.cpp	2017-10-12 11:09:31.094119615 +0800
@@ -0,0 +1,207 @@
+// Scaffold
+// This pass implements a fault tolerant implementation of Toffoli gates
+//
+
+#include <cstdlib>
+#include <cstdio>
+
+#include "llvm/ADT/ArrayRef.h"
+
+#include "llvm/Constants.h"
+#include "llvm/Function.h"
+#include "llvm/Instructions.h"
+#include "llvm/Intrinsics.h"
+#include "llvm/LLVMContext.h"
+#include "llvm/Pass.h"
+
+#include "llvm/Support/CallSite.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/InstVisitor.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+
+using namespace llvm;
+
+namespace {
+	// We need to use a ModulePass in order to create new Functions
+	struct ToffoliReplace : public ModulePass {
+		static char ID;
+		ToffoliReplace() : ModulePass(ID) {}
+
+		struct ToffoliVisitor : public InstVisitor<ToffoliVisitor> {
+			// The Toffoli implementation will be a Function in M's FunctionList
+			Module *M;
+			// The constructor is called once per module (in runOnModule)
+			ToffoliVisitor(Module *module) : M(module) {}
+
+			void visitCallInst(CallInst &I) {
+				// Determine whether this is a Toffoli gate
+				Function *CF = I.getCalledFunction();
+				if (CF->isIntrinsic() && CF->getIntrinsicID() == Intrinsic::Toffoli) {
+					// Retrieve the FT Toffoli implementation
+					std::string implName = "ToffoliImpl";
+		            std::vector<Type*> ArgTypes(3);
+				    for (int i=0; i<3; i++){
+					    ArgTypes[i] = I.getArgOperand(i)->getType();//Type::getInt16Ty(getGlobalContext());
+                        if(ArgTypes[i] == Type::getInt16Ty(getGlobalContext()))
+                            implName.append("_Q");
+                        else
+                            implName.append("_A");
+                    }
+                        
+                    Function *ToffoliImpl = M->getFunction(implName);
+                    if(!ToffoliImpl){
+						FunctionType *FuncType = FunctionType::get(
+								Type::getVoidTy(getGlobalContext()),
+								ArrayRef<Type*>(ArgTypes),
+								false);
+						ToffoliImpl = Function::Create(FuncType,
+								GlobalVariable::ExternalLinkage,
+								implName,
+								M);
+						ToffoliImpl->addFnAttr(Attribute::AlwaysInline);
+
+						// Build Function;
+						// Fetch arguments
+						Function::arg_iterator arg_it = ToffoliImpl->arg_begin();
+						Value *Target = arg_it++;	            
+						Value *Control1 = arg_it++;
+						Value *Control2 = arg_it;
+            
+                        Control1->setName("control1");
+                        Control2->setName("control2");
+                        Target->setName("target");
+
+						// Fetch gate definitions
+						//Function* gate_H = Intrinsic::getDeclaration(M, Intrinsic::H);
+						//Function* gate_T = Intrinsic::getDeclaration(M, Intrinsic::T);
+						//Function* gate_t = Intrinsic::getDeclaration(M, Intrinsic::Tdag);
+						//Function* gate_S = Intrinsic::getDeclaration(M, Intrinsic::S);
+						//Function* gate_CNOT = Intrinsic::getDeclaration(M, Intrinsic::CNOT);
+
+						// Create BasicBlock
+						BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "", ToffoliImpl, 0);
+            
+            /*
+            // -- The standard implementation of Toffoli gates (Mike and Ike)
+            // CNOT shorthands
+						std::vector<Value*> C2T; C2T.push_back(Target); C2T.push_back(Control2);
+						std::vector<Value*> C1T; C1T.push_back(Target); C1T.push_back(Control1);
+						std::vector<Value*> C1C2; C1C2.push_back(Control2); C1C2.push_back(Control1);
+						// Construct circuit
+						CallInst::Create(gate_H, ArrayRef<Value*>(Target), "", BB)->setTailCall();
+						CallInst::Create(gate_CNOT, ArrayRef<Value*>(C2T), "", BB)->setTailCall();
+						CallInst::Create(gate_t, ArrayRef<Value*>(Target), "", BB)->setTailCall();
+						CallInst::Create(gate_CNOT, ArrayRef<Value*>(C1T), "", BB)->setTailCall();
+						CallInst::Create(gate_T, ArrayRef<Value*>(Target), "", BB)->setTailCall();
+						CallInst::Create(gate_CNOT, ArrayRef<Value*>(C2T), "", BB)->setTailCall();
+						CallInst::Create(gate_t, ArrayRef<Value*>(Target), "", BB)->setTailCall();
+						CallInst::Create(gate_CNOT, ArrayRef<Value*>(C1T), "", BB)->setTailCall();
+						CallInst::Create(gate_t, ArrayRef<Value*>(Control2), "", BB)->setTailCall();
+						CallInst::Create(gate_T, ArrayRef<Value*>(Target), "", BB)->setTailCall();
+						CallInst::Create(gate_CNOT, ArrayRef<Value*>(C1C2), "", BB)->setTailCall();
+						CallInst::Create(gate_H, ArrayRef<Value*>(Target), "", BB)->setTailCall();
+						CallInst::Create(gate_t, ArrayRef<Value*>(Control2), "", BB)->setTailCall();
+						CallInst::Create(gate_CNOT, ArrayRef<Value*>(C1C2), "", BB)->setTailCall();
+						CallInst::Create(gate_T, ArrayRef<Value*>(Control1), "", BB)->setTailCall();
+						CallInst::Create(gate_S, ArrayRef<Value*>(Control2), "", BB)->setTailCall();
+            */
+
+            // -- Improved T-depth Toffoli gate (Amy et al.)
+            // CNOT shorthands
+
+						std::vector<Value*> C1C2; C1C2.push_back(Control2); C1C2.push_back(Control1); 
+                        std::vector<Type*> C1C2ty; C1C2ty.push_back(ArgTypes[2]); C1C2ty.push_back(ArgTypes[1]);
+
+						std::vector<Value*> C2T; C2T.push_back(Target); C2T.push_back(Control2);
+                        std::vector<Type*> C2Tty; C2Tty.push_back(ArgTypes[0]); C2Tty.push_back(ArgTypes[2]);
+
+
+						std::vector<Value*> TC1; TC1.push_back(Control1); TC1.push_back(Target);
+						std::vector<Type*> TC1ty; TC1ty.push_back(ArgTypes[1]); TC1ty.push_back(ArgTypes[0]);
+            
+						std::vector<Value*> C2C1; C2C1.push_back(Control1); C2C1.push_back(Control2);            
+						std::vector<Type*> C2C1ty; C2C1ty.push_back(ArgTypes[1]); C2C1ty.push_back(ArgTypes[2]);            
+						
+                        // Construct circuit
+
+                        //t is Tdag, T is T
+						CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::H, ArrayRef<Type*>(ArgTypes[2])), 
+                                         ArrayRef<Value*>(Target), "", BB)->setTailCall();
+
+						CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::Tdag, ArrayRef<Type*>(ArgTypes[1])), 
+                                         ArrayRef<Value*>(Control1), "", BB)->setTailCall();
+
+						CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::T, ArrayRef<Type*>(ArgTypes[2])),
+                                         ArrayRef<Value*>(Control2), "", BB)->setTailCall();
+
+						CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::T, ArrayRef<Type*>(ArgTypes[0])),
+                                         ArrayRef<Value*>(Target), "", BB)->setTailCall();
+                                   
+						CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(C1C2ty)),
+						                 ArrayRef<Value*>(C1C2), "", BB)->setTailCall();
+
+						CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(TC1ty)),
+						                 ArrayRef<Value*>(TC1), "", BB)->setTailCall();
+            
+            CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::Tdag, ArrayRef<Type*>(ArgTypes[1])),
+						                 ArrayRef<Value*>(Control1), "", BB)->setTailCall();
+            
+            CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(C2Tty)),
+						                 ArrayRef<Value*>(C2T), "", BB)->setTailCall();
+            
+            CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(C2C1ty)),
+						                 ArrayRef<Value*>(C2C1), "", BB)->setTailCall();
+            
+            CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::Tdag, ArrayRef<Type*>(ArgTypes[1])),
+						                 ArrayRef<Value*>(Control1), "", BB)->setTailCall();
+            
+            CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::Tdag, ArrayRef<Type*>(ArgTypes[2])),
+						                 ArrayRef<Value*>(Control2), "", BB)->setTailCall();
+            
+            CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::T, ArrayRef<Type*>(ArgTypes[0])),
+			                             ArrayRef<Value*>(Target), "", BB)->setTailCall();
+            
+            CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(TC1ty)),
+						                 ArrayRef<Value*>(TC1), "", BB)->setTailCall();
+            
+            CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::S, ArrayRef<Type*>(ArgTypes[1])),
+						                 ArrayRef<Value*>(Control1), "", BB)->setTailCall();
+            
+            CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(C2Tty)),
+						                 ArrayRef<Value*>(C2T), "", BB)->setTailCall();
+            
+            CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::CNOT, ArrayRef<Type*>(C1C2ty)),
+						                 ArrayRef<Value*>(C1C2), "", BB)->setTailCall();
+            
+            CallInst::Create(Intrinsic::getDeclaration(M, Intrinsic::H, ArrayRef<Type*>(ArgTypes[0])),
+						                 ArrayRef<Value*>(Target), "", BB)->setTailCall();
+                        //end TODO
+
+						ReturnInst::Create(getGlobalContext(), 0, BB);
+					}//end !ToffoliImpl
+					std::vector<Value*>  Args(3);
+					for (int i=0; i<3; i++)
+						Args[i] = I.getArgOperand(i);
+					BasicBlock::iterator ii(&I);
+					ReplaceInstWithInst(I.getParent()->getInstList(), ii,
+						CallInst::Create(ToffoliImpl, ArrayRef<Value*>(Args)));
+
+				} // endif 'found Toffoli'
+			} // visitCallInst()
+		}; // struct ToffoliVisitor
+
+		virtual bool runOnModule(Module &M) {
+			ToffoliVisitor TV(&M);
+			TV.visit(M);
+
+			return true;
+		} // runOnModule()
+		
+	}; // struct ToffoliReplace
+} // namespace
+
+char ToffoliReplace::ID = 0;
+static RegisterPass<ToffoliReplace> X("ToffoliReplace", "Toffoli Replacer", false, false);
+
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/XformCbitStores.cpp llvm/lib/Transforms/Scaffold/XformCbitStores.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scaffold/XformCbitStores.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm/lib/Transforms/Scaffold/XformCbitStores.cpp	2017-10-12 11:09:31.094119615 +0800
@@ -0,0 +1,86 @@
+//===- XformCbitStores.cpp - Transform stores to Cbits  -------------------===//
+//===------------- into calls to dummy function that cannot ---------------===//
+//===--------------  be eliminated by deadcode_elim  ----------------------===//
+//
+//                     The LLVM Scaffold Compiler Infrastructure
+//
+//        This file was created by Scaffold Compiler Working Group
+//
+//===----------------------------------------------------------------------===//
+
+
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/Constants.h"
+#include "llvm/Function.h"
+#include "llvm/Instructions.h"
+#include "llvm/Intrinsics.h"
+#include "llvm/LLVMContext.h"
+#include "llvm/Pass.h"
+#include "llvm/Support/InstIterator.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/InstVisitor.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+
+using namespace llvm;
+using namespace std;
+
+namespace {
+  struct XformCbitStores : public ModulePass {
+    static char ID;
+    XformCbitStores() : ModulePass(ID) {}
+    
+
+    virtual bool runOnModule(Module &M) {
+      
+      //create a new function called store_cbit(i1,i1*)      
+      string dummyFuncName = "store_cbit";
+
+      vector<Type*> dummyFuncArgs;
+      dummyFuncArgs.push_back(Type::getInt1Ty(getGlobalContext()));
+      dummyFuncArgs.push_back(Type::getInt1PtrTy(getGlobalContext()));
+      ArrayRef<Type*> dummyFuncArgsRef(dummyFuncArgs);
+
+      FunctionType *dummyFuncType = FunctionType::get(
+						      Type::getVoidTy(getGlobalContext()),
+						      dummyFuncArgsRef,
+						      false);      
+      
+      Function* dummy_store_func = Function::Create(dummyFuncType, GlobalVariable::ExternalLinkage,dummyFuncName, &M);      
+      
+      for(Module::iterator F = M.begin(), E = M.end(); F!= E; ++F){
+	for(inst_iterator I = inst_begin(F), IE = inst_end(F); I != IE; ++I){
+	  
+	  Instruction *pInst = &*I;
+	  
+	  if(StoreInst* SI = dyn_cast<StoreInst>(pInst)) {	    
+	    Value* valOp = SI->getValueOperand();
+	    Value* ptrOp = SI->getPointerOperand();
+	    
+	    Type* valType = valOp->getType();
+	    Type* ptrType = ptrOp->getType();
+	    Type* ptrElemType = ptrType->getPointerElementType();
+	    
+	    if(valType->isIntegerTy(1) && ptrElemType->isIntegerTy(1))
+	      {
+		//errs()<<"Found a Cbit Store\n";
+
+		//take both arguments and create a new call inst		
+		vector<Value*> callArgs;
+		callArgs.push_back(valOp);
+		callArgs.push_back(ptrOp);
+		ArrayRef<Value*> callArgsRef(callArgs);
+
+		//insert the call inst after or before the store inst
+		CallInst::Create(dummy_store_func,callArgsRef,"",(Instruction*)SI);		
+	      }	    
+	  } // dyn_cast<StoreInst>
+	}
+      }	    
+      return true;
+    } // runOnModule()    
+  }; // struct XformCbitStores
+} // namespace
+
+char XformCbitStores::ID = 0;
+static RegisterPass<XformCbitStores> X("xform-cbit-stores", "Transform Cbit Stores into a dummy function to avoid deadcode elim", false, false);
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scalar/JumpThreading.cpp llvm/lib/Transforms/Scalar/JumpThreading.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scalar/JumpThreading.cpp	2017-10-12 11:11:50.293435018 +0800
+++ llvm/lib/Transforms/Scalar/JumpThreading.cpp	2017-10-12 11:09:31.096119633 +0800
@@ -1404,7 +1404,6 @@
   // now have to update all uses of the value to use either the original value,
   // the cloned value, or some PHI derived value.  This can require arbitrary
   // PHI insertion, of which we are prepared to do, clean these up now.
-  SSAUpdater SSAUpdate;
   SmallVector<Use*, 16> UsesToRename;
   for (BasicBlock::iterator I = BB->begin(); I != BB->end(); ++I) {
     // Scan all uses of this instruction to see if it is used outside of its
@@ -1424,19 +1423,21 @@
     // If there are no uses outside the block, we're done with this instruction.
     if (UsesToRename.empty())
       continue;
+    else{
+      DEBUG(dbgs() << "JT: Renaming non-local uses of: " << *I << "\n");
 
-    DEBUG(dbgs() << "JT: Renaming non-local uses of: " << *I << "\n");
-
-    // We found a use of I outside of BB.  Rename all uses of I that are outside
-    // its block to be uses of the appropriate PHI node etc.  See ValuesInBlocks
-    // with the two values we know.
-    SSAUpdate.Initialize(I->getType(), I->getName());
-    SSAUpdate.AddAvailableValue(BB, I);
-    SSAUpdate.AddAvailableValue(NewBB, ValueMapping[I]);
-
-    while (!UsesToRename.empty())
-      SSAUpdate.RewriteUse(*UsesToRename.pop_back_val());
-    DEBUG(dbgs() << "\n");
+      // We found a use of I outside of BB.  Rename all uses of I that are outside
+      // its block to be uses of the appropriate PHI node etc.  See ValuesInBlocks
+      // with the two values we know.
+      SSAUpdater SSAUpdate;
+      SSAUpdate.Initialize(I->getType(), I->getName());
+      SSAUpdate.AddAvailableValue(BB, I);
+      SSAUpdate.AddAvailableValue(NewBB, ValueMapping[I]);
+
+      while (!UsesToRename.empty())
+        SSAUpdate.RewriteUse(*UsesToRename.pop_back_val());
+      DEBUG(dbgs() << "\n");
+    }
   }
 
 
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Scalar/LoopUnrollPass.cpp llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Scalar/LoopUnrollPass.cpp	2017-10-12 11:11:50.294435028 +0800
+++ llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp	2017-10-12 11:09:31.098119652 +0800
@@ -135,6 +135,8 @@
   ScalarEvolution *SE = &getAnalysis<ScalarEvolution>();
 
   BasicBlock *Header = L->getHeader();
+  //errs() << "Loop Unroll: F[" << Header->getParent()->getName()
+  //      << "] Loop %" << Header->getName() << "\n";
   DEBUG(dbgs() << "Loop Unroll: F[" << Header->getParent()->getName()
         << "] Loop %" << Header->getName() << "\n");
   (void)Header;
@@ -182,6 +184,7 @@
     unsigned NumInlineCandidates;
     unsigned LoopSize = ApproximateLoopSize(L, NumInlineCandidates, TD);
     DEBUG(dbgs() << "  Loop Size = " << LoopSize << "\n");
+    //ajavadia: don't want this feature because it prevents function cloning from functioning correctly.
     if (NumInlineCandidates != 0) {
       DEBUG(dbgs() << "  Not unrolling loop with inlinable calls.\n");
       return false;
@@ -215,7 +218,7 @@
       DEBUG(dbgs() << "  partially unrolling with count: " << Count << "\n");
     }
   }
-
+  
   // Unroll the loop.
   if (!UnrollLoop(L, Count, TripCount, UnrollRuntime, TripMultiple, LI, &LPM))
     return false;
diff -Naur /data/project/xiangzhai/llvm-31/lib/Transforms/Utils/LoopUnroll.cpp llvm/lib/Transforms/Utils/LoopUnroll.cpp
--- /data/project/xiangzhai/llvm-31/lib/Transforms/Utils/LoopUnroll.cpp	2017-10-12 11:11:50.300435090 +0800
+++ llvm/lib/Transforms/Utils/LoopUnroll.cpp	2017-10-12 11:09:31.103119698 +0800
@@ -267,6 +267,7 @@
     std::vector<BasicBlock*> NewBlocks;
 
     for (LoopBlocksDFS::RPOIterator BB = BlockBegin; BB != BlockEnd; ++BB) {
+      
       ValueToValueMapTy VMap;
       BasicBlock *New = CloneBasicBlock(*BB, VMap, "." + Twine(It));
       Header->getParent()->getBasicBlockList().push_back(New);
@@ -275,6 +276,7 @@
       // incoming values from the previous block.
       if (*BB == Header)
         for (unsigned i = 0, e = OrigPHINode.size(); i != e; ++i) {
+          
           PHINode *NewPHI = cast<PHINode>(VMap[OrigPHINode[i]]);
           Value *InVal = NewPHI->getIncomingValueForBlock(LatchBlock);
           if (Instruction *InValI = dyn_cast<Instruction>(InVal))
@@ -283,7 +285,7 @@
           VMap[OrigPHINode[i]] = InVal;
           New->getInstList().erase(NewPHI);
         }
-
+        
       // Update our running map of newest clones
       LastValueMap[*BB] = New;
       for (ValueToValueMapTy::iterator VI = VMap.begin(), VE = VMap.end();
@@ -313,14 +315,14 @@
       if (*BB == LatchBlock)
         Latches.push_back(New);
 
-      NewBlocks.push_back(New);
+      NewBlocks.push_back(New); 
     }
 
     // Remap all instructions in the most recent iteration
     for (unsigned i = 0; i < NewBlocks.size(); ++i)
       for (BasicBlock::iterator I = NewBlocks[i]->begin(),
            E = NewBlocks[i]->end(); I != E; ++I)
-        ::RemapInstruction(I, LastValueMap);
+        ::RemapInstruction(I, LastValueMap); 
   }
 
   // Loop over the PHI nodes in the original block, setting incoming values.
@@ -342,6 +344,7 @@
       PN->addIncoming(InVal, Latches.back());
     }
   }
+  
 
   // Now that all the basic blocks for the unrolled iterations are in place,
   // set up the branches to connect them.
@@ -405,10 +408,15 @@
     }
   }
 
+
   // FIXME: Reconstruct dom info, because it is not preserved properly.
   // Incrementally updating domtree after loop unrolling would be easy.
-  if (DominatorTree *DT = LPM->getAnalysisIfAvailable<DominatorTree>())
-    DT->runOnFunction(*L->getHeader()->getParent());
+  if (DominatorTree *DT = LPM->getAnalysisIfAvailable<DominatorTree>())  
+  //DT->runOnFunction(*L->getHeader()->getParent());
+  //if (DominatorTreeWrapperPass *DTWP = LPM->getAnalysisIfAvailable<DominatorTreeWrapperPass>()){
+  //   DT = &DTWP->getDomTree();
+  //   DT->recalculate(*L->getHeader()->getParent());
+  //}
 
   // Simplify any new induction variables in the partially unrolled loop.
   if (SE && !CompletelyUnroll) {
diff -Naur /data/project/xiangzhai/llvm-31/lib/VMCore/Type.cpp llvm/lib/VMCore/Type.cpp
--- /data/project/xiangzhai/llvm-31/lib/VMCore/Type.cpp	2017-10-12 11:11:50.307435162 +0800
+++ llvm/lib/VMCore/Type.cpp	2017-10-12 11:09:31.109119753 +0800
@@ -261,6 +261,9 @@
 IntegerType *Type::getInt16Ty(LLVMContext &C) { return &C.pImpl->Int16Ty; }
 IntegerType *Type::getInt32Ty(LLVMContext &C) { return &C.pImpl->Int32Ty; }
 IntegerType *Type::getInt64Ty(LLVMContext &C) { return &C.pImpl->Int64Ty; }
+//Scaffold
+IntegerType *Type::getInt128Ty(LLVMContext &C) { return getIntNTy(C, 128); }
+
 
 IntegerType *Type::getIntNTy(LLVMContext &C, unsigned N) {
   return IntegerType::get(C, N);
diff -Naur /data/project/xiangzhai/llvm-31/lib/VMCore/Verifier.cpp llvm/lib/VMCore/Verifier.cpp
--- /data/project/xiangzhai/llvm-31/lib/VMCore/Verifier.cpp	2017-10-12 11:11:50.308435172 +0800
+++ llvm/lib/VMCore/Verifier.cpp	2017-10-12 11:09:31.110119762 +0800
@@ -1858,6 +1858,7 @@
     }
 
     unsigned GotBits = cast<IntegerType>(EltTy)->getBitWidth();
+//	errs() << "BITS: " << GotBits << "\n";
     Suffix += ".";
 
     if (EltTy != Ty)
@@ -2014,11 +2015,11 @@
   // has a suffix and not.
   if (!Suffix.empty()) {
     std::string Name(Intrinsic::getName(ID));
-    if (Name + Suffix != F->getName()) {
-      CheckFailed("Overloaded intrinsic has incorrect suffix: '" +
-                  F->getName().substr(Name.length()) + "'. It should be '" +
-                  Suffix + "'", F);
-    }
+//    if (Name + Suffix != F->getName()) {
+//      CheckFailed("Overloaded intrinsic has incorrect suffix: '" +
+//                  F->getName().substr(Name.length()) + "'. It should be '" +
+//                  Suffix + "'", F);
+//    }
   }
 
   // Check parameter attributes.
diff -Naur /data/project/xiangzhai/llvm-31/Makefile.config.in llvm/Makefile.config.in
--- /data/project/xiangzhai/llvm-31/Makefile.config.in	2017-10-12 11:11:50.061432631 +0800
+++ llvm/Makefile.config.in	2017-10-12 11:09:30.885117694 +0800
@@ -351,10 +351,3 @@
 
 # Flags to control building support for OProfile JIT API
 USE_OPROFILE := @USE_OPROFILE@
-
-ifeq ($(USE_INTEL_JITEVENTS), 1)
-  OPTIONAL_COMPONENTS += IntelJITEvents
-endif
-ifeq ($(USE_OPROFILE), 1)
-  OPTIONAL_COMPONENTS += OProfileJIT
-endif
diff -Naur /data/project/xiangzhai/llvm-31/Makefile.rules llvm/Makefile.rules
--- /data/project/xiangzhai/llvm-31/Makefile.rules	2017-10-12 11:11:50.062432641 +0800
+++ llvm/Makefile.rules	2017-10-12 11:09:30.885117694 +0800
@@ -100,7 +100,6 @@
 	$(Verb) $(LLVMBuildTool) \
 	  --native-target "$(TARGET_NATIVE_ARCH)" \
 	  --enable-targets "$(TARGETS_TO_BUILD)" \
-	  --enable-optional-components "$(OPTIONAL_COMPONENTS)" \
 	  --write-library-table $(LLVMConfigLibraryDependenciesInc) \
 	  --write-make-fragment $(LLVMBuildMakeFrag)
 
diff -Naur /data/project/xiangzhai/llvm-31/test/Archive/IsNAN.o llvm/test/Archive/IsNAN.o
--- /data/project/xiangzhai/llvm-31/test/Archive/IsNAN.o	2017-10-12 11:11:50.326435358 +0800
+++ llvm/test/Archive/IsNAN.o	1970-01-01 08:00:00.000000000 +0800
@@ -1,7 +0,0 @@
-ELF                            4     (   UE$UE]E$   %  $ >  9:;  .?:;@I<   I  .?:;@I<  .G@
-   :;I
-  	.G@
-   "           -       GNU C++ 3.4.0 /proj/work/llvm/build/../llvm/lib/Support/IsNAN.cpp long double int char double    llvm    IsNAN _ZN4llvm5IsNANEf j       IsNAN  _ZN4llvm5IsNANEd j   y     float 	            Uf     	      -   Ud  y   x  _    G   
-    /proj/work/llvm/build/../llvm/lib/Support  IsNAN.cpp         c      |                AB             AB"        &     IsNAN 	  IsNAN                      -            GCC: (GNU) 3.4.0  .symtab .strtab .shstrtab .rel.text .data .bss .debug_abbrev .rel.debug_info .rel.debug_line .rel.debug_frame .rel.debug_pubnames .rel.debug_aranges .note.GNU-stack .comment                                                       4   -                     	           X                 %             d                      +             d                      0              d                     B                 &                 >   	           h  @               R                c                  N   	                            b              t  D                  ^   	                    
-         s                &                  o   	                                                                  	                                                                                                                                                                 	                >                                                                                                                                               
-                                                                                   %           6               IsNAN.cpp _ZN4llvm5IsNANEf __isnanf _ZN4llvm5IsNANEd __isnan        '                                           T               0     4                    
\  newline 
diff -Naur /data/project/xiangzhai/llvm-31/tools/llvm-config/llvm-config.cpp llvm/tools/llvm-config/llvm-config.cpp
--- /data/project/xiangzhai/llvm-31/tools/llvm-config/llvm-config.cpp	2017-10-12 11:11:50.602438197 +0800
+++ llvm/tools/llvm-config/llvm-config.cpp	2017-10-12 11:09:31.398122409 +0800
@@ -54,8 +54,7 @@
 static void VisitComponent(StringRef Name,
                            const StringMap<AvailableComponent*> &ComponentMap,
                            std::set<AvailableComponent*> &VisitedComponents,
-                           std::vector<StringRef> &RequiredLibs,
-                           bool IncludeNonInstalled) {
+                           std::vector<StringRef> &RequiredLibs) {
   // Lookup the component.
   AvailableComponent *AC = ComponentMap.lookup(Name);
   assert(AC && "Invalid component name!");
@@ -66,14 +65,10 @@
     return;
   }
 
-  // Only include non-installed components if requested.
-  if (!AC->IsInstalled && !IncludeNonInstalled)
-    return;
-
   // Otherwise, visit all the dependencies.
   for (unsigned i = 0; AC->RequiredLibraries[i]; ++i) {
     VisitComponent(AC->RequiredLibraries[i], ComponentMap, VisitedComponents,
-                   RequiredLibs, IncludeNonInstalled);
+                   RequiredLibs);
   }
 
   // Add to the required library list.
@@ -88,11 +83,8 @@
 /// \param Components - The names of the components to find libraries for.
 /// \param RequiredLibs [out] - On return, the ordered list of libraries that
 /// are required to link the given components.
-/// \param IncludeNonInstalled - Whether non-installed components should be
-/// reported.
 void ComputeLibsForComponents(const std::vector<StringRef> &Components,
-                              std::vector<StringRef> &RequiredLibs,
-                              bool IncludeNonInstalled) {
+                              std::vector<StringRef> &RequiredLibs) {
   std::set<AvailableComponent*> VisitedComponents;
 
   // Build a map of component names to information.
@@ -115,7 +107,7 @@
     }
 
     VisitComponent(ComponentLower, ComponentMap, VisitedComponents,
-                   RequiredLibs, IncludeNonInstalled);
+                   RequiredLibs);
   }
 
   // The list is now ordered with leafs first, we want the libraries to printed
@@ -286,10 +278,6 @@
         PrintLibFiles = true;
       } else if (Arg == "--components") {
         for (unsigned j = 0; j != array_lengthof(AvailableComponents); ++j) {
-          // Only include non-installed components when in a development tree.
-          if (!AvailableComponents[j].IsInstalled && !IsInDevelopmentTree)
-            continue;
-
           OS << ' ';
           OS << AvailableComponents[j].Name;
         }
@@ -322,8 +310,7 @@
 
     // Construct the list of all the required libraries.
     std::vector<StringRef> RequiredLibs;
-    ComputeLibsForComponents(Components, RequiredLibs,
-                             /*IncludeNonInstalled=*/IsInDevelopmentTree);
+    ComputeLibsForComponents(Components, RequiredLibs);
 
     for (unsigned i = 0, e = RequiredLibs.size(); i != e; ++i) {
       StringRef Lib = RequiredLibs[i];
diff -Naur /data/project/xiangzhai/llvm-31/utils/llvm-build/llvmbuild/componentinfo.py llvm/utils/llvm-build/llvmbuild/componentinfo.py
--- /data/project/xiangzhai/llvm-31/utils/llvm-build/llvmbuild/componentinfo.py	2017-10-12 11:11:50.628438465 +0800
+++ llvm/utils/llvm-build/llvmbuild/componentinfo.py	2017-10-12 11:09:31.420122611 +0800
@@ -68,21 +68,6 @@
     def get_llvmbuild_fragment(self):
         abstract
 
-    def get_parent_target_group(self):
-        """get_parent_target_group() -> ComponentInfo or None
-
-        Return the nearest parent target group (if any), or None if the
-        component is not part of any target group.
-        """
-
-        # If this is a target group, return it.
-        if self.type_name == 'TargetGroup':
-            return self
-
-        # Otherwise recurse on the parent, if any.
-        if self.parent_instance:
-            return self.parent_instance.get_parent_target_group()
-
 class GroupComponentInfo(ComponentInfo):
     """
     Group components have no semantics as far as the build system are concerned,
@@ -110,22 +95,16 @@
     type_name = 'Library'
 
     @staticmethod
-    def parse_items(items):
+    def parse(subpath, items):
         kwargs = ComponentInfo.parse_items(items)
         kwargs['library_name'] = items.get_optional_string('library_name')
         kwargs['required_libraries'] = items.get_list('required_libraries')
         kwargs['add_to_library_groups'] = items.get_list(
             'add_to_library_groups')
-        kwargs['installed'] = items.get_optional_bool('installed', True)
-        return kwargs
-
-    @staticmethod
-    def parse(subpath, items):
-        kwargs = LibraryComponentInfo.parse_items(items)
         return LibraryComponentInfo(subpath, **kwargs)
 
     def __init__(self, subpath, name, dependencies, parent, library_name,
-                 required_libraries, add_to_library_groups, installed):
+                 required_libraries, add_to_library_groups):
         ComponentInfo.__init__(self, subpath, name, dependencies, parent)
 
         # If given, the name to use for the library instead of deriving it from
@@ -140,9 +119,6 @@
         # considered part of.
         self.add_to_library_groups = list(add_to_library_groups)
 
-        # Whether or not this library is installed.
-        self.installed = installed
-
     def get_component_references(self):
         for r in ComponentInfo.get_component_references(self):
             yield r
@@ -164,8 +140,6 @@
         if self.add_to_library_groups:
             print >>result, 'add_to_library_groups = %s' % ' '.join(
                 self.add_to_library_groups)
-        if not self.installed:
-            print >>result, 'installed = 0'
         return result.getvalue()
 
     def get_library_name(self):
@@ -191,20 +165,6 @@
     def get_llvmconfig_component_name(self):
         return self.get_library_name().lower()
 
-class OptionalLibraryComponentInfo(LibraryComponentInfo):
-    type_name = "OptionalLibrary"
-
-    @staticmethod
-    def parse(subpath, items):
-      kwargs = LibraryComponentInfo.parse_items(items)
-      return OptionalLibraryComponentInfo(subpath, **kwargs)
-
-    def __init__(self, subpath, name, dependencies, parent, library_name,
-                 required_libraries, add_to_library_groups, installed):
-      LibraryComponentInfo.__init__(self, subpath, name, dependencies, parent,
-                                    library_name, required_libraries,
-                                    add_to_library_groups, installed)
-
 class LibraryGroupComponentInfo(ComponentInfo):
     type_name = 'LibraryGroup'
 
@@ -415,7 +375,7 @@
     for t in (GroupComponentInfo,
               LibraryComponentInfo, LibraryGroupComponentInfo,
               ToolComponentInfo, BuildToolComponentInfo,
-              TargetGroupComponentInfo, OptionalLibraryComponentInfo))
+              TargetGroupComponentInfo))
 def load_from_path(path, subpath):
     # Load the LLVMBuild.txt file as an .ini format file.
     parser = ConfigParser.RawConfigParser()
diff -Naur /data/project/xiangzhai/llvm-31/utils/llvm-build/llvmbuild/main.py llvm/utils/llvm-build/llvmbuild/main.py
--- /data/project/xiangzhai/llvm-31/utils/llvm-build/llvmbuild/main.py	2017-10-12 11:11:50.628438465 +0800
+++ llvm/utils/llvm-build/llvmbuild/main.py	2017-10-12 11:09:31.420122611 +0800
@@ -312,26 +312,15 @@
 
             f.close()
 
-    def write_library_table(self, output_path, enabled_optional_components):
+    def write_library_table(self, output_path):
         # Write out the mapping from component names to required libraries.
         #
         # We do this in topological order so that we know we can append the
         # dependencies for added library groups.
         entries = {}
         for c in self.ordered_component_infos:
-            # Skip optional components which are not enabled.
-            if c.type_name == 'OptionalLibrary' \
-                and c.name not in enabled_optional_components:
-                continue
-
-            # Skip target groups which are not enabled.
-            tg = c.get_parent_target_group()
-            if tg and not tg.enabled:
-                continue
-
             # Only certain components are in the table.
-            if c.type_name not in ('Library', 'OptionalLibrary', \
-                                   'LibraryGroup', 'TargetGroup'):
+            if c.type_name not in ('Library', 'LibraryGroup', 'TargetGroup'):
                 continue
 
             # Compute the llvm-config "component name". For historical reasons,
@@ -339,12 +328,10 @@
             llvmconfig_component_name = c.get_llvmconfig_component_name()
             
             # Get the library name, or None for LibraryGroups.
-            if c.type_name == 'Library' or c.type_name == 'OptionalLibrary':
+            if c.type_name == 'Library':
                 library_name = c.get_prefixed_library_name()
-                is_installed = c.installed
             else:
                 library_name = None
-                is_installed = True
 
             # Get the component names of all the required libraries.
             required_llvmconfig_component_names = [
@@ -357,8 +344,7 @@
 
             # Add the entry.
             entries[c.name] = (llvmconfig_component_name, library_name,
-                               required_llvmconfig_component_names,
-                               is_installed)
+                               required_llvmconfig_component_names)
 
         # Convert to a list of entries and sort by name.
         entries = entries.values()
@@ -366,16 +352,16 @@
         # Create an 'all' pseudo component. We keep the dependency list small by
         # only listing entries that have no other dependents.
         root_entries = set(e[0] for e in entries)
-        for _,_,deps,_ in entries:
+        for _,_,deps in entries:
             root_entries -= set(deps)
-        entries.append(('all', None, root_entries, True))
+        entries.append(('all', None, root_entries))
 
         entries.sort()
 
         # Compute the maximum number of required libraries, plus one so there is
         # always a sentinel.
         max_required_libraries = max(len(deps)
-                                     for _,_,deps,_ in entries) + 1
+                                     for _,_,deps in entries) + 1
 
         # Write out the library table.
         make_install_dir(os.path.dirname(output_path))
@@ -396,21 +382,18 @@
         print >>f, '  /// The name of the library for this component (or NULL).'
         print >>f, '  const char *Library;'
         print >>f, ''
-        print >>f, '  /// Whether the component is installed.'
-        print >>f, '  bool IsInstalled;'
-        print >>f, ''
         print >>f, '\
   /// The list of libraries required when linking this component.'
         print >>f, '  const char *RequiredLibraries[%d];' % (
             max_required_libraries)
         print >>f, '} AvailableComponents[%d] = {' % len(entries)
-        for name,library_name,required_names,is_installed in entries:
+        for name,library_name,required_names in entries:
             if library_name is None:
                 library_name_as_cstr = '0'
             else:
                 library_name_as_cstr = '"lib%s.a"' % library_name
-            print >>f, '  { "%s", %s, %d, { %s } },' % (
-                name, library_name_as_cstr, is_installed,
+            print >>f, '  { "%s", %s, { %s } },' % (
+                name, library_name_as_cstr,
                 ', '.join('"%s"' % dep
                           for dep in required_names))
         print >>f, '};'
@@ -795,11 +778,6 @@
                       help=("Enable the given space or semi-colon separated "
                             "list of targets, or all targets if not present"),
                       action="store", default=None)
-    group.add_option("", "--enable-optional-components",
-                      dest="optional_components", metavar="NAMES",
-                      help=("Enable the given space or semi-colon separated "
-                            "list of optional components"),
-                      action="store", default=None)
     parser.add_option_group(group)
 
     (opts, args) = parser.parse_args()
@@ -841,8 +819,7 @@
 
     # Write out the required library table, if requested.
     if opts.write_library_table:
-        project_info.write_library_table(opts.write_library_table,
-                                         opts.optional_components)
+        project_info.write_library_table(opts.write_library_table)
 
     # Write out the make fragment, if requested.
     if opts.write_make_fragment:
diff -Naur /data/project/xiangzhai/llvm-31/utils/unittest/LLVMBuild.txt llvm/utils/unittest/LLVMBuild.txt
--- /data/project/xiangzhai/llvm-31/utils/unittest/LLVMBuild.txt	2017-10-12 11:10:03.492417405 +0800
+++ llvm/utils/unittest/LLVMBuild.txt	2017-10-12 11:09:31.422122630 +0800
@@ -20,11 +20,9 @@
 name = gtest
 parent = Libraries
 required_libraries = Support
-installed = 0
 
 [component_1]
 type = Library
 name = gtest_main
 parent = Libraries
 required_libraries = gtest
-installed = 0
diff -Naur /data/project/xiangzhai/llvm-31/utils/vim/llvm.vim llvm/utils/vim/llvm.vim
--- /data/project/xiangzhai/llvm-31/utils/vim/llvm.vim	2017-10-12 11:11:50.636438547 +0800
+++ llvm/utils/vim/llvm.vim	2017-10-12 11:09:31.427122676 +0800
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language:   llvm
 " Maintainer: The LLVM team, http://llvm.org/
-" Version:      $Revision$
+" Version:      $Revision: 137806 $
 
 if version < 600
   syntax clear
diff -Naur /data/project/xiangzhai/llvm-31/utils/vim/tablegen.vim llvm/utils/vim/tablegen.vim
--- /data/project/xiangzhai/llvm-31/utils/vim/tablegen.vim	2017-10-12 11:11:50.636438547 +0800
+++ llvm/utils/vim/tablegen.vim	2017-10-12 11:09:31.427122676 +0800
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language:   TableGen
 " Maintainer: The LLVM team, http://llvm.org/
-" Version:    $Revision$
+" Version:    $Revision: 151164 $
 
 if version < 600
   syntax clear
diff -Naur /data/project/xiangzhai/llvm-31/utils/vim/vimrc llvm/utils/vim/vimrc
--- /data/project/xiangzhai/llvm-31/utils/vim/vimrc	2017-10-12 11:11:50.636438547 +0800
+++ llvm/utils/vim/vimrc	2017-10-12 11:09:31.427122676 +0800
@@ -1,5 +1,5 @@
 " LLVM coding guidelines conformance for VIM
-" $Revision$
+" $Revision: 117415 $
 "
 " Maintainer: The LLVM Team, http://llvm.org
 " WARNING:    Read before you source in all these commands and macros!  Some
